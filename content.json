{"pages":[{"title":"About me","text":"An imaginative front-end worker. 个人信息年龄：26学位：计算机本科邮箱：qilanbei@163.com技术博客: https://qilanbei.github.io工作经验：3.5年求职岗位：前端开发工程师 自我评价 90后双子座小朋友，毕业于计算机专业，从事前端开发工作，喜欢指尖在键盘上疯狂飞舞的感觉，个人博客 qilanbei.github.io； 具有较好的产品意识，愿意将产品效果做为工作最重要的驱动因素； 掌握 vue、react 前端框架，对代码规范有强烈强迫症，代码规范习惯良好； 具有较强的学习能力和逻辑分析能力，具备很好的抗压能力； 具有丰富的部门沟通经验与推进能力，获得优秀员工称号，具有强烈的责任心和团队意识。 技能介绍 能够独立承担WEB前端核心模块的设计、实现产品项目以及后期维护； 掌握 es6、h5、css 模块化等前端技术，能够运用css预处理器：sass\\less\\stylus； 运用 Vue、React 主流框架独立完成多个前端项目； 能够进行微信小程序项目开发以及功能实现； 掌握 canvas，svg 图形绘制，熟练运用 echarts 完成图表项目； 能够很好的配合前后端的沟通工作，完成前后端数据接口对接与数据渲染； 掌握 TCP/HTTP 协议，能够运用 SSE、webSocket 完成实时数据统计； 熟练使用 gulp、webpack 自动化项目构建工具，完成项目构建； 根据业务需求涉及的新的知识和架构能尽早的掌握和运用于实践开发当中； 熟练使用Git代码版本管理工具，并熟悉运用多种linux终端命令。 工作经历 北京***有限公司，用户体验部-前端开发工程师，2017.11~至今 配合项目团队根据原型设计完成前端工作以及与后台工程师紧密配合，确保代码有效对接，完成数据交互、动态展现； 独立负责Vue框架**平台片库资源传输平台项目的开发、优化修复和升级工作，项目涉及：web、微信H5项目； 独立负责Vue框架**平台下传输统计以及任务分发统计等数据实时监控数据屏项目； 配合负责React框架***媒资平台项目开发以及维护工作； 配合负责**平台的小程序开发以及维护工作； 独立负责公司官网开发，利用Hugo、go template模板快速开发； 独立负责angularJS影院管理tms分发任务项目以及维护工作，涉及长链接处理实时任务传输数据； 参与Web平台数据可视化项目工作及长链接SSE和websocket技术攻关； 根据业务需求涉及的新的知识和架构能尽早的掌握和运用于实践开发当中。 上海***信息技术服务有限公司，技术研发部-前端开发工程师，2016.12~2017.10 根据工作安排高效高质地完成代码编写，确保符合规范的前端代码规范，提高用户交互体验； 负责使用前端流行框架完成面向微信H5、主流浏览器的开发，产品涉及活动页面，后台管理系统； 与后端开发团队紧密配合，确保代码有效对接，优化网站前端性能； 网站开发，微信公众号 h5 页面开发等项目； 配合完成智能垃圾分类屏幕前端交互开发。 部分项目经历 **快传（vue+webpack、elementUI、长链接）电影数字拷贝专业级传输工具，实现电影一键发送任务自动接收、影院组织管理平台以及后台管理系统 影院TMS管理（angularJS、Jquery、SemanticUI、长链接）影院管理人员下载片库资源，TMS配置，发送TMS任务，传输数据统计的影院TMS管理平台 **快传小程序（微信小程序，udp广播等）微信小程序实现影院活动宣传，快速查询终端信息，方便影院人员管理盒子以及任务管理 数据屏实时监控平台（主要技术：vue+webpack、Echarts、长链接）利用配合实时数据实现飞鱼院线平台实时数据监控平台，包括：影院统计，终端部署以及内存占用统计，任务实时下载统计，总传输量统计等数据监控 **个人版（vue+webpack、elementUI）影院根据城市开启召集活动，提供购票的影院管理平台 公司官网（Hugo、Jquery、go template模板、Ajax、OwlCarouselUI）凤凰云祥（北京）信息科技有限公司（以下简称：凤凰云祥）是凤凰卫视的全资下属公司，为企业的信息化发展提供产品工具、系统设计、技术支持和咨询服务 Oceans企业平台（React+webpack、socket.io、blueprintUI）利用React实现PaaS方式的服务能力平台，包括媒资，文件传输管理，会议视频等企业服务功能 **垃圾分类积分平台（vue+webpack、JqueryJS、Ajax）使用Vue框架完成智能垃圾分类积分平台，功能：活动管理、积分管理等 **银行投融资平台（JqueryJS、Ajax、My97DatePicker、Umeditor、gulp、droploadJS）该银行投融资平台是通过互联网的方式，为全国各地投资客户提供投资服务，为有融资需求的企业和个人提供融资服务的互联网金融服务平台，平台基于P2B和P2P业务模式 **营销平台（vue+webpack、JqueryJS、animation、scss、gulp)该平台是基于互联网金融的特色和技术，打造了组件化的营销平台体系，为银行未来互联网化提供有利的机会，并通过营销平台获取新的客户 **客户信息建档系统（JqueryJS、Ajax、bootstrap、fullpageJS、移动端TouchSlider)小微商户和农户的基本信息，加大农村普惠金融服务力度，提高客户经理工作质效，减少重复劳动，提升全市农村信用社信息化管理水平，引入移动信息化技术，为全市客户经理提供手机办公平台 技能清单★★★★★☆ JavaScript &amp; DOM &amp; CSS★★★★★☆ JqueryJS★★★★★☆ Vue 全家桶★★★☆☆☆ React &amp; Webpack★★★★☆☆ ElementUI等UI库★★★★☆☆ Websocket &amp; SSE★★★★☆☆ EchartsJS★★★★☆☆ Hugo、Hexo★★★★☆☆ 小程序★★★☆☆☆ angularJS","link":"/about/index.html"}],"posts":[{"title":"Object.defineProperty()有何名堂？","text":"有关Object.defineProperty() defineProperty是个啥来自MDN中的解释： Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 语法： Object.defineProperty(obj, prop, descriptor) 参数： object 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript对象（即用户定义的对象或内置对象）或 DOM 对象。 prop(property name) 必需。 一个包含属性名称的字符串。 descriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。 属性描述符： 数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的 存取描述符是由getter-setter函数对描述的属性 数据描述符还具有以下可选键值： value: 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable: 当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。默认为 false。 configurable: 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable: 当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。 存取描述符还具有以下可选键值： get: 当访问该属性时会调用此函数。执行时不传入任何参数，但会传入 this 对象（由于继承关系，this 不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。默认为 undefined。 set: 当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined。 configurable: 同数据描述符configurable enumerable: 同数据描述符enumerable 注意: 属性描述符有以上两种主要形式：数据描述符和存取描述符，描述符必须是这两种形式之一，不能同时是两者；即：如果一个描述符同时拥有 value 或 writable 和 get 或 set 键，则会产生一个异常 如果一个描述符不具有 value、writable、get 和 set 中的任意一个键，那么它将被认为是一个数据描述符。 这些选项不一定是自身属性，也要考虑继承来的属性。为了确认保留这些默认值，在设置之前，可能要冻结 Object.prototype，明确指定所有的选项，或者通过 Object.create(null) 将 proto 属性指向 null 1234567891011121314// 使用 __proto__var obj = {};var descriptor = Object.create(null); // 没有继承的属性// 默认没有 enumerable，没有 configurable，没有 writabledescriptor.value = 'static';Object.defineProperty(obj, 'key', descriptor);// 以上相当于显式写法，如下Object.defineProperty(obj, \"key\", { enumerable: false, configurable: false, writable: false, value: \"static\"}); 当 writable 属性设置为 false 时，该属性被称为“不可写的”，它不能被重新赋值，哪怕是相同的赋值。 123456789101112131415161718192021var obj = {}Object.defineProperty(obj, 'a', { value: 37, writable: false})obj.a = 25; // 结果不会报错，但是obj.a的数值还是37，不会被改变// 但是在严格模式下，这样操作就会报异常(function () { 'use strict' var obj = {}; Object.defineProperty(obj, 'b', { value: 37, writable: false }); obj.b = 25; return obj.b;}())// 抛异常：Cannot assign to read only property 'b' of object 示例: 1、利用defineProperty()方法创建属性 123456789101112131415161718192021222324// 添加一个数据描述符var obj = {}Object.defineProperty(obj, 'a', { value: 37, writable: true, configurable: true, enumerable: true})// 给对象添加一个存取描述符var bValue;Object.defineProperty(obj, 'b', { get: function () { return bValue }, set: function (newValue) { bValue = newValue }, configurable: true, enumerable: true})// 这样设置后，除非重新定义 obj.b，否则 obj.b 的值总是与 bValue 相同，无论 bValue 的值如何变化bValue = 4console.log(obj.b) // expected output: 4 enumerable 定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举。 1234567891011121314151617var o = {};Object.defineProperty(o, \"a\", { value : 1, enumerable: true });Object.defineProperty(o, \"b\", { value : 2, enumerable: false });Object.defineProperty(o, \"c\", { value : 3 }); // enumerable 默认为 falseo.d = 4; // 如果使用直接赋值的方式创建对象的属性，则 enumerable 为 true// 通过 判断是否可枚举o.propertyIsEnumerable('a'); // trueo.propertyIsEnumerable('b'); // falseo.propertyIsEnumerable('c'); // falseo.propertyIsEnumerable('d'); // truevar p = { ...o }p.a // undefined 不可枚举// 扩展运算符本身也是要通过for in Object.keys来遍历取值赋值，如果 enumerable 为 false 取不到值 configurable 特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改 123456789var o = {};Object.defineProperty(o, 'a', { get() { return 1; }, configurable: false});Object.defineProperty(o, 'a', { configurable: true}); // throws a TypeError 考虑特性被赋予的默认特性值非常重要，通常，使用点运算符和 Object.defineProperty() 为对象的属性赋值时，数据描述符中的属性默认值是不同的 123456789101112131415161718192021var o = {};o.a = 1;// 等同于：Object.defineProperty(o, \"a\", { value: 1, writable: true, configurable: true, enumerable: true});// 另一方面，Object.defineProperty(o, \"a\", { value : 1 });// 等同于：Object.defineProperty(o, \"a\", { value: 1, writable: false, configurable: false, enumerable: false}); Getter &amp; Setter 123456789101112131415161718192021222324252627// Getter 为读取属性时调用的函数. Setter 为设置属性是调用的函数, Setter 会有一个参数, 即设置的那个值function Archiver() { var temperature = null; var archive = []; Object.defineProperty(this, 'temperature', { get: function() { console.log('get!'); return temperature; }, set: function(value) { temperature = value; archive.push({ val: temperature }); } }); this.getArchive = function () { return archive }}var arc = new Archiver();arc.temperature; // expected output: 'get!'arc.temperature = 11;arc.temperature = 13;console.log(arc.getArchive()) // expected output: [{ val: 11 }, { val: 13 }] 继承属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。如果这些方法用一个变量 value 存值，该值会被所有对象共享function myClass () {}var value;Object.defineProperty(myClass.prototype, 'x', { get () { return value }, set (v) { value = v }})var a = new myClass()var b = new myClass()a.x = 1console.log(b.x) // expected output: 1myClass.prototype.isPrototypeOf(a) // truemyClass.prototype.isPrototypeOf(b) // true// 这可以通过将值存储在另一个属性中解决。在 get 和 set 方法中，this 指向某个被访问和修改属性的对象function myClass () {}Object.defineProperty(myClass.prototype, 'x', { get () { return this.store_x }, set (v) { this.store_x = v }})var a = new myClass()var b = new myClass()a.x = 1console.log(b.x) // expected output: undefined","link":"/2019/09/19/ObjectdefineProperty/"},{"title":"有关Object.assign()","text":"Object.assign 知识点 Object.assign() 介绍ES6提供了Object.assign()，用于合并/复制对象的属性。 语法为：Object.assign(target, source_1, ..., source_n) 查看MDN上面详细的解释： Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 使用示例12345678910const target = { a: 1, b: 2 };const source = { b: 4, c: 5 };const returnedTarget = Object.assign(target, source);console.log(target);// expected output: Object { a: 1, b: 4, c: 5 }console.log(returnedTarget);// expected output: Object { a: 1, b: 4, c: 5 } 根据示例可以看出：如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。 特性简介 属性名可以为字符串或者 Symbol，String类型和 Symbol 类型的属性都会被拷贝 注意: Object.assign 不管source对象值为 null、undefined还是NaN，都不会报错 如果 target 参数不是对象，则会先转成对象，然后返回，由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。 12Object.assign(undefined) // 报错Object.assign(null) // 报错 除了字符串会以数组形式，拷贝入目标对象，其他值(非异常值，如：undefined等)都会被转化为 object 类型 1234Object.assign(1) // 转化为 number 对象// expected output: Number {1} Object.assign(true) // 转化为 boolean 对象// expected output: Boolean {true} Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性 如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用 123456789101112131415161718var obj1 = {a: {b: 1}};var obj2 = Object.assign({}, obj1);obj1.a.b = 2;console.log(obj2.a.b) // expected output: 2// 因为 `Object.assign` 实现的是浅拷贝，// 只是将obj1 里面的 对象a 拷贝给 obj2，对象a存储的是{b: 1}的地址// 目标对象 obj2 拷贝得到的是这个对象的引用，即：obj2.a 指向的是{b: 1}的地址// 所以当 obj1.a.b = 2; a指向{b: 1}的地址 里面的值发生了改变，// 自然下次 obj2.a.b 再进行查询的时候 值是变化后的 2 // 打个比方：我obj1有一把仓库的钥匙a, // 你obj2复制了一把和钥匙a一模一样的钥匙，// 我昨天拿着钥匙a去仓库放了一筐鸡蛋，你在我之后去仓库看，// 因为是同一个仓库，你也会看到是多了一筐鸡蛋，// 或者你去放这个鸡蛋，我去看也是你放置后的结果 当Object.assign用来处理数组时，会把数组视为对象 12345Object.assign([1, 2, 3], [4, 5])// expected output: [4， 5, 3】// 因为 Object.assign 会将 [1, 2, 3] 和 [4, 5] 两个数组转化为对象，// 相当于 {0: 1, 1: 2, 2: 3} 合并 {0: 4, 1: 5}// 所以输出：[4， 5, 3】 实际用途 初始化对象属性 构造器正是为了初始化对象的属性，通常，我们不得不多次重复属性的名字。示例代码的constructor中，x与y均重复了两次： 123456class Point { constructor(x, y) { this.x = x; this.y = y; }} Object.assign()可以帮助我们减少一些重复： 12345class Point { constructor(x, y) { Object.assign(this, { x, y }); }} 也可给对象添加方法 123456789// 为对象添加方法Object.assign(SomeClass.prototype, { someMethod(arg1, arg2) {}, anotherMethod() {}});// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) {};SomeClass.prototype.anotherMethod = function () {}; 合并多个对象 1const merge =(target, ...sources) =&gt; Object.assign(target, ...sources); 为属性指定默认值 12345678const DEFAULTS = { params: {}, data: {}, headers: {}};function funName (options) { let options = Object.assign({}, DEFAULTS, options);} 复制对象 使用Object.assign()深度复制对象，包括其prototype（深复制） 123456789101112131415161718var Point = function(x) { this.x = x;};Point.prototype.y = 2;var obj = new Point(1);var copy1 = Object.assign({ __proto__: obj.__proto__ }, obj); // expected output: {x:1,y:2}// （深复制）或者:var copy2 = Object.getPrototypeOf(obj);return Object.assign(Object.create(copy), obj);console.log(copy1, copy2); // expected output: {x:1,y:2} 仅复制自身属性（浅复制）： 123456var obj = new Point(1);var copy = Object.assign({}, obj);console.log(copy);// expected output: {x:1} 归纳参考：ES6之Object.assign()详解 MDN关于Object.assign()","link":"/2019/07/31/Object-assign/"},{"title":"关于要不要写分号;","text":"关于要不要写分号的问题 “究竟要不要加分号”已经是一个争论很久的问题了，实际上，行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。 但是，在今天来看，行尾使用分号貌似是一种”麻烦”，恰好 JavaScript 语言又提供了相对可用的分号自动补全规则，所以，很多 JavaScript 的程序员都是倾向于不写分号（我就是不写分号党）。 先说说自动插入分号规则，自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条： 要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号； 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号； 源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。 举例一 1234let a = 1void function(a){ console.log(a);}(a); 在这个例子中，第一行的结尾处有换行符，接下来 void 关键字接在 1 之后是不合法的，这命中了我们的第一条规则，因此会在 void 前插入分号。 举例二 123456789var a = 1, b = 1, c = 1;a++b++cconsole.log(a); // 结果输出为1console.log(b); // 结果输出为2console.log(c); // 结果输出为2 第二行的 a 之后，有换行符，后面遇到了 ++ 运算符，a 后面跟 ++ 是合法的语法，但是我们看看 JavaScript 标准定义中，有[no LineTerminator here]规则中一项：后自增，后自减运算符前不能插入换行，这是一个语法定义中的规则，下面有说道关于[no LineTerminator here]规则；所以再根据自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号；于是，这里 a 的后面就要插入一个分号了。所以这段代码最终的结果，b 和 c 都变成了 2，而 a 还是 1。 举例三 123456(function(a){ console.log(a);})()(function(a){ console.log(a);})() 这两个function函数被叫做 立即执行函数表达式，看第三行结束的位置，JavaScript引擎会认为函数返回的也有可能是一个函数，比如：1234(function(a){ return function () {} // 某函数})()(function(a){})()// 那么后面如果解析到还有括号，会被认为是函数的调用，姑后面有括号 会被认为是合理的 所以后面在跟括号形成函数的调用也是合理的，因此这里不会自动插入分号，所以该代码运行起来 就会报错：(intermediate value)(…) is not a function 这也是一些鼓励不写分号的编码风格会要求大家写 IIFE 时必须在行首加分号的原因，如下所示：123456(function(a){ console.log(a);})();(function(a){ console.log(a);})() 举例四 123456function f() { return/* This is a return value. */1;}f() 在这个例子中，根据自动插入分号规则，带换行符的注释也被认为是有换行符，恰好 return 也有[no LineTerminator here]规则的要求，所以这里也会插入分号，所以函数返回值为 undefined。 接下来说说 no LineTerminator here 规则，no LineTerminator here 规则表示它所在的结构中的这一位置不能插入换行符， 自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟 no LineTerminator here 规则强相关，那么我们就找出 JavaScript 语法定义中的这些规则。 [no LineTerminator here] 规则 ： 带标签的continue语句，不能在continue后插入换行 带标签的break语句，不能在break后插入换行 return后不能插入换行 后自增，后自减运算符前不能插入换行 throw 和 Exception 之间不能插入换行 凡是async关键字，后面不能插入换行 剪头函数的箭头前，不能插入换行 yield之后，不能插入换行 不写分号需要注意的情况最后梳理一些不写分号容易报错的情况 以括号开头的语句，比如上文中提到的自执行表达式 123456(function(a){ console.log(a);})() /*这里不会被自动插入分号，后面跟着的括号会被理解为传参，导致抛出错误。*/(function(a){ console.log(a);})() 以数组开头的语句 12var a = [[]]/*这里没有被自动插入分号*/[3, 2, 1, 0].forEach(e =&gt; console.log(e)) [] 后面 还有[]，被理解为下标运算符和逗号表达式，上面的例子甚至不会报错，代码排查起来非常恶心啊，为了展示报错，可以尝试12var a = []/*这里没有被自动插入分号*/[3, 2, 1, 0].forEach(e =&gt; console.log(e)) 这里就会因为解析的问题报错：Cannot read property ‘forEach’ of undefined，一个空数组后面跟上[]，如果被理解为下标远算符，肯定是undefined 以正则表达式开头的语句123var x = 1, g = {test:()=&gt;0}, b = 1/*这里没有被自动插入分号*//(a)/g.test(\"abc\") /*测试一个字符串中是否含有字母 a*/console.log(RegExp.$1) 这里正则的第一个斜杠如果被理解为除号，后面的意思就变了，直接报错：a is not defined 以 Template 开头的语句123var a = 'nihao' /*这里没有被自动插入分号*/`Template`.match(/(a)/)console.log(RegExp.$1) 这里 ‘nihao’ 会被认为跟 Template 一体的，进而被莫名其妙地执行了一次，报错为：”nihao” is not a function。 总结一句话，看到代码开头为 括号，方括号，斜杠，加号，减号都结合上下行多注意一下。 参考 winter 老师的javascript语法的讲解，受益匪浅！","link":"/2019/11/18/about-semicolon/"},{"title":"Babel学习之旅(二)","text":"记录有关babel的学习旅程 写在前面上篇 babel学习之旅(一) 我们介绍了 What is Babel 以及 简单的配置，这篇文章 我们现在整体看一下babel是如何工作的 Babel是如何工作的Babel 会将源码转换 AST 之后，通过便利AST树，对树做一些修改，然后再将AST转成code，即成源码 图片来源 alloyteam 如上图所示，babel的编译过程和大多数其他语言的编译器大致相同，可以分为三个阶段: 解析(PARSE)：将代码字符串解析成 AST (抽象语法树)。 转换(TRANSFORM)：对 AST (抽象语法树)进行转换操作。 生成(GENERATE): 根据变换后的 AST (抽象语法树)再生成代码字符串。 解析Babel的解析引擎是 Babylon, babylon 是一个解析器，它可以将 JavaScript 字符串转换为对计算机来说更加友好的表现形式，称之为抽象语法树 AST（Abstract Syntax Tree）, babylon并非由babel团队自己开发的，而是fork的acorn项目，为了是做一些代码的转换，是很不错的一款引擎， 不过acorn引擎只提供基本的解析 AST 的能力，遍历还需要配套的acorn-travesal, 替换节点需要使用acorn-，而这些开发，在Babel的插件体系开发下，变得一体化了。 解析的过程分为两步： 分词： 将整个代码字符串分割成 语法单元数组 语义分析：在分词结果的基础之上分析 语法单元之间的关系 什么是分词和语义分析，请查阅这里 babel转AST的解析过程在Babylon中完成, 解析成AST树使的是babylon.parse方法 转换比如我们在 .babelrc 里配置的 presets 和 plugins (下面将介绍babel的配置)是在第二步 转换中 进行的。 babel-traverse 模块允许你浏览、分析和修改抽象语法树（AST） 生成babel-generator 模块用来将转换后的抽象语法树（AST）转换为 JavaScript 字符串。","link":"/2019/05/01/babel2/"},{"title":"浏览器兼容性","text":"浏览器兼容性(必须要总结一下这个了) 获取document对象的文本内容：大部分浏览器都支持：innerhtmlIE支持：innerhtml和innerTextfirefox支持：innerhtml和textContent 事件event对象相关兼容性问题：1&gt;获取event事件对象chrome，firefox，safari等直接直接通过event获取，但IE采用了一种非标准的方式，将事件作为window对象的event属性；IE是把event事件对象作为全局对象window的一个属性；可以使用event或window.event来访问；FireFox和Chrome等主流浏览器是通过把【事件对象】作为【事件响应函数】的【参数】进入传入的；jquery的event一般不用考虑兼容性了1234//原生js获取事件对象兼容性写法:function foo(event){ var evt = event || window.event;} 2&gt;获取事件源对象的方式也不一样：在IE中：window.event.srcElement；在firefox中：window.event.target；3&gt;event.x和event.y的兼容性x，y事件发生的位置的 x 坐标和 y 坐标offsetX,offsetY发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标pageX,pageY返回鼠标指针的位置，相对于文档的左边缘IE取鼠标点击绝对位置使用event.x,event.y;IE取鼠标点击相对位置使用event.offsetX,event.offsetYfirefox取鼠标指针位置使用event.pageX,event.pageY const兼容问题const是es6新增的用来定义常量的关键字，IE9一下不支持解决方法：通过npm下载babel来兼容，123456//引入babel文件 &lt;script src=&quot;browser.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; const Name = &apos;niwei&apos;;//使用新增的关键字：const声明常量 console.log(Name); &lt;/script&gt;","link":"/2016/08/20/brower-compatibility/"},{"title":"Babel学习之旅(一)","text":"记录有关babel的学习旅程 What is Babel? Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments 这是来自babel官网的介绍 翻译理解：Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中，即：ES6/ES7/ES8 =&gt; Babel =&gt; ES5。 举个栗子：123456789// 转码前input.map(item =&gt; item + 1)// 转码后input.map(function (item) { return item + 1})// 箭头函数这个特性，不是所有浏览器都支持，通过babel可以转码为普通函数，这样就不用担心浏览器厂商是否支持了 更多了解请移步这里： babel 中文文档 babel 英文文档 配置 BabelBabel 也同ESLint (.eslintrc)、Prettier (.prettierrc)等一样，是有配置文件的. 所有 Babel API 参数 都可以被配置 目前为止通过运行 Babel 自己我们并没能“翻译”代码，而仅仅是把代码从一处拷贝到了另一处。原因就是从Babel 6以后, 默认的插件被移除, 如果没有指定一个插件，Babel将会原样输出, 不会进行编译。 你可以通过安装插件（plugins）或预设（presets，也就是一组插件）来指示 Babel 去做什么事情。 插件只是单一的功能： es2015-arrow-functions es2015-classes es2015-for-of es2015-spread 如果我们每个都要引人功能单一的插件的话特别麻烦，通常我们用的更多的是预设，插件和预设通常写入到配置文件中 配置文件的类型：Babel有两种并行的配置文件格式，可以一起使用，也可以单独使用。 Project-wide configuration File-relative configuration .babelrc (and .babelrc.js) files package.json files with a “babel” key 配置文件的选择: 你是否希望以编程的方式创建配置文件？ 你是否希望编译 node_modules 目录下的模块？ babel.config.js 文件可以满足你的的需求！ 你是否只是需要一个简单的并且只用于单个软件包的配置？ .babelrc 文件适合你！ The Guy Fieri is your hero? 官网建议使用 babel.config.js 格式的配置文件。Babel 本身使用的就是这种。 babel.config.js在项目的根目录（package.json 文件所在目录）下创建一个名为 babel.config.js 的文件，如下所示：1234567891011module.exports = function (api) { api.cache(true); const presets = []; const plugins = []; return { presets, plugins };} 请参阅 babel.config.js 文档 以了解更多关于配置参数的信息 .babelrc在你的项目中创建名为 .babelrc 的文件，并输入以下内容:123456{ // presets字段设定转码规则 \"presets\": [], // plugins字段可以设置需要的插件 \"plugins\": []} presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装: 1234567891011# ES2015转码规则$ npm install --save-dev babel-preset-es2015# react转码规则$ npm install --save-dev babel-preset-react# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 然后，将这些规则加入.babelrc 12345678{ \"presets\": [ \"es2015\", \"react\", \"stage-2\" ], \"plugins\": []} 请参阅 .babelrc 文档 以了解更多关于配置参数的信息。 package.json或者，还可以选择将 .babelrc 中的配置信息作为 babel 键（key）的值添加到 package.json 文件中，如下所示：12345678{ \"name\": \"my-package\", \"version\": \"1.0.0\", \"babel\": { \"presets\": [], \"plugins\": [] }} .babelrc.js与 .babelrc 的配置相同，但你可以使用 JavaScript 编写1.8123456789const presets = [];const plugins = [];// 你还可以调用 Node.js 的任何 API，例如基于进程环境进行动态配置if (process.env[\"ENV\"] === \"prod\") { plugins.push(...);}module.exports = { presets, plugins };","link":"/2019/04/30/babel1/"},{"title":"有关Charles抓包","text":"Charles抓包工具的破解和 Https 配置 写在前面由于之前查了好多无良的帖子，看了那么多字，发现好几篇都是一样的，有的复制的还不是很全，真的很坑，emmmm….. Charles 软件破解方式 去官网 下载适合自己系统的版本并安装 去破解网站根据自己Charles的版本下载对应的jar包 简单的替换方法：mac版本在Applications(应用程序)里找到Charles.app然后右击，选择show package content(显示包内容)，找到Contents/Java的路径，如图：将刚才下载的charles.jar包替换Contents/Java中的charles.jar，很简单的操作了吧 Windows版本替换方式同mac，只是路径为: C:\\Program Files\\Charles\\lib\\charles.jar这时候你就能够美美的使用破解版了，不用每过30分钟就提示你退出了 Charles https 抓包1. pc 浏览器 https 抓包,打开Charles 软件，下载Charles Root Certificate，勾选macOS Proxy会弹出到钥匙串这里，如果证书没有被信任，双击Charles证书，设置Always Trust(始终信任) 2. 手机端 https抓包下载移动端的证书，去掉macOS Proxy的选择会弹出这个提示，让你用手机浏览器访问”chls.pro/ssl”，会下载一个证书安装就行了 拦截指定地址的数据包选择proxy的Recording Setting 设置，找到include的tab,添加你想拦截的地址 注意事项 使用Charles的时候，尽量不要开小飞机翻墙 Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容 12342.1. 访问: chrome://settings/2.2. 然后下拉到最后的高级，下来在 “系统”（倒数第二个）的条目下找到“打开代理设置”2.3. 然后双击打开之后，打开之后找到代理的 tab 点开，点开之后可以看到请选择一个协议进行配置，这个时候找到“网页代理(http)” 和“安全网页代理 (https)”，进行相应的配置就可以了，2.4. 一般来说自己不做其他处理，直接配置代理服务器为“127.0.0.1”，端口(就是冒号:) 后是“8888”。 有的提示这里也要注意，这个地方你开小飞机，就自动勾选，不开就不会勾选，所以用Charles的时候，尽量不要用小飞机翻墙了","link":"/2019/02/22/charles/"},{"title":"浏览器加载解析过程","text":"浏览器加载解析过程 在面试的时候，有的面试官会问到js加载是不是会阻塞DOM树的解析和渲染，css会不会，或者问到相关问题，就想总结一下，首先有几个问题，自己在查询资料的时候，答案众说纷纭，通过自己学习，总结如下，也欢迎纠正1.css会不会阻塞DOM树的解析和渲染?css是不会阻塞DOM树的解析；因为当浏览器解析到link的href去加载外部css文件的时候，浏览器还是会继续加载dom结构，为了效率，它会把该完成的都解析完，生成相应的dom树，但是会阻塞dom的渲染，它要等外部的css文件加载解析完，才会解析style标签里的样式，这时候才是根据样式的顺序也好，权重也好去渲染dom。12345678910111213141516//小demo://demo.css文件：.demo { background-color: yellow !important; //1}//.html文件&lt;link ref=&quot;stylesheet&quot; href=&quot;./demo.css&quot;&gt;//style: .demo { width: 200px; height: 200px; background-color: red !important; //2 }//body: &lt;div class=&quot;demo&quot; style=&quot;background-color: blue&quot;&gt;你好&lt;/div&gt; //3 显示的你好是什么颜色? 2.js会不会阻塞DOM树的解析和渲染?js的加载会阻塞DOM树的解析和渲染，还有后面一些资源的下载，js的加载和执行有以下特点：1&gt;载入js后浏览器会立即执行2&gt;执行时会阻塞后面内容的构建，渲染及以下资源的下载，因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。1234567//运行个demo，自己可以测试一下：//把脚本放在头部和放在底部，在js里面去获取dom元素，看看能不能获取到，或者写个死循环，让脚本一直运行，看dom能显示出来不 &lt;script&gt; while(true){ console.log(1); }&lt;/script&gt;","link":"/2016/08/20/brower-render/"},{"title":"有关跨域知识总结","text":"有关跨域知识总结 有关跨域知识总结什么是跨域，为什么会发生跨域跨域是浏览器行为，是浏览器为安全性考虑实施的安全策略，是对js施加的安全限制，由于浏览器的同源策略，一般网站的协议protocol、主机host、端口号port这三个中的任意一个不同，网站间的数据请求与传输边构成了跨域调用。由于ajax的实现原理是由XMLHttpRequest对象实现的，而浏览器对XMLHttpRequest对象有跨域限制，当通过ajax请求不同域下的资源的时候，请求会发送给服务器，只是服务器返回响应信息给浏览器时，被浏览器拦截了 举例说明举例之前，先以http://www.baidu.com为例，普及一些概念：1231&gt; 在这里http就是一种协议，www.baidu.com是域名，浏览器默认http端口是80端口,https的端口号是443;2&gt; 在www.baidu.com中，.com是顶级域名；baidu.com是一级域名；www.baidu.com二级域名，类似的bbs.baidu.com和tieba.baidu.com都是二级域名。3&gt; 列举能发生跨域的url(也许地址不存在，仅是为了能够更加具体，举得例子)： 12345http://www.baidu.com和https://www.baidu.com：会发生跨域，由于协议不一样；http://www.taobao.com和http:www.google.com：会发生跨域，域名不一样；http://www.baidu.com/index.html和http://www.baidu.com:4000/index.html：会发生跨域，端口号不一样；http://www.baidu.com/index.html和http://tieba.baidu.com/index.html：会发生跨域，域名不一样；http://www.baidu.com/index.html和http://www.baidu.com/src/demo.html 不会发生跨域行为，只是所在的目录不一样. 跨域解决方案1&gt; 在顶级域名相同的情况下，可以通过domain.name来解决，同时设置domain.name=”设置的域名”；2&gt; jsonp跨域原理是由于浏览器对script，link等标签的src属性没有跨域限制，所以jsonp原理就是通过动态创建一个script的标签，添加到head中，添加回调函数，将格式化的数据拼接到url上，设置超时时间，实现监听状态，指定script的src属性，通过src发送请求实现的跨域，使用后清除script标签和回调函数；由于是通过拼接url实现的跨域，所以只支持get请求方式。使用 jQuery 集成的 $.ajax 实现 JSONP 跨域调用:jquery的ajax调用：123456789101112131415$.ajax({ url: &apos;&apos;, data:data, cache: false, timeout: 5000, jsonp: &apos;callback&apos;,//jsonp字段的含义为服务器通过什么字段获取回调函数的名称 jsonpCallback:&apos;jsonpCallback&apos;, success: function (data){ console.log(&apos;ajax success callback&apos;); }, error: function(jqXHR,textStatus,errorThrown){ console.log(textStatu+&apos;&apos;+errorThrown); } }) //利用 JSONP 格式返回的值一段要立即执行的 JavaScript 代码，所以不会像 ajax 的 XmlHttpRequest 那样可以监听不同事件对数据进行不同处理 3&gt;cors方法，参考阮一峰：http://www.ruanyifeng.com/blog/2016/04/cors.html","link":"/2016/06/06/cross-domain/"},{"title":"Canvas学习笔记","text":"关于Canvas的学习笔记 canvas简介 概念：H5 提供的一个新的标签元素 Canvas是指可以在其上面通过脚本语言（通常为js） 绘制图形、图像以及制作动画的标签 Canvas本身不具备绘制能力，只是负责展示 在浏览器不支持Canvas时，会将其当做div标签来解析 在IE中，会将其当做文本节点来解析 检查支持性 1234567var canvas = document.getElementById('tutorial');if (canvas.getContext){ var ctx = canvas.getContext('2d'); // drawing code here} else { // canvas-unsupported code here} 基本使用 创建一个画布 1&lt;canvas&gt;在浏览器不支持canvas时，会显示这段文本。&lt;/canvas&gt; 在创建一canvas标签时，如果没有指定宽和高，默认为 300 * 150 （px） 要用canvas的相关属性设置其宽和高；否则，用其他方式指定canvas的宽和高，会在默认值的基础上进行缩放。而在缩放时，并没有增加canvas内部的像素点的个数。 获取绘制工具 1234// 第1步：获取相应画布var canvas = document.getElementById('canvasId');// 第2步：获取该画布的绘制工具var ctx = canvas.getContext('2d|WebGL'); getContext方法：参数为 ‘2d’ or ‘WebGL’ 2d: 获取绘制平面图形的工具 WebGL：获取绘制立体图形的工具 在课程内，只学习绘制 2d 图形 绘制工具是由归属的。只有画布自己的绘制工具 可以在本身上绘制图形、图像。 canvas检查支持性如果需要在UI上体现，我们可以在 canvas 标签内部放置元素，如果浏览器不支持 canvas 标签，那么内部的元素就会被浏览器解析，而显示出来。123&lt;canvas id=\"stockGraph\" width=\"150\" height=\"150\"&gt; &lt;p&gt;Canvas not be support.&lt;/p&gt;&lt;/canvas&gt; 除此之外，我们也可以用js的方式来检查。12345var canvas = document.getElementById('c1');//如果canvas元素没有getContext方法，那么就证明浏览器不支持canvas。if(!canvas.getContext){ console.log('Canvas not be support.')} 坐标系 原点 在canvas的左上角 X轴：在原点的水平方向 Y轴：在原点的垂直方向 基本绘制工具 移动笔触moveTo(x, y) x 确定点的 横坐标；y 确定点的 纵坐标。 画线lineTo(x, y): 从当前笔触所在点 连线 到 指定点。 绘制直线步骤 移动笔触moveTo 画线lineTo 描边stroke 或 填充fill 绘制矩形不同于 svg，canvas 只支持两种形式的图形绘制：矩形和路径（由一系列点连成的线段），所有其他类型的图形都是通过一条或者多条路径组合而成的，不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。 首先，我们回到矩形的绘制中，canvas提供了三种方法绘制矩形： 绘制一个填充的矩形: fillRect(x, y, width, height) 绘制一个矩形的边框: strokeRect(x, y, width, height) 清除指定矩形区域，让清除部分完全透明: clearRect(x, y, width, height) 12345678910111213// 第1步：获取相应画布var canvas = document.getElementById('canvasId');if (canvas.getContext) { // 第2步：获取该画布的绘制工具 var ctx = canvas.getContext('2d'); // 绘制一个填充的矩形: fillRect(x, y, width, height) // ctx.fillRect(25, 25, 100, 100) // 清除指定矩形区域，让清除部分完全透明: clearRect(x, y, width, height) // ctx.clearRect(25, 25, 100, 100) // ctx.clearRect(45, 45, 60, 60) // 绘制一个矩形的边框: strokeRect(x, y, width, height) ctx.strokeRect(50, 50, 50, 50)} 绘制路径 绘制路径步骤： 首先，你需要创建路径起始点。 然后你使用画图命令去画出路径。 之后闭合路径closePath(),不是必需的。 一旦路径生成，你就能通过描边或填充路径区域来渲染图形。 路径API: beginPath(): 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。 closePath(): 闭合路径之后图形绘制命令又重新指向到上下文中。 stroke(): 通过线条来绘制图形轮廓。 fill(): 通过填充路径的内容区域生成实心的图形。 注意 closePath()这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。 绘制三角形1234567891011121314151617var canvas = document.getElementById('canvasId')if (canvas.getContext) { var ctx = canvas.getContext('2d') // 填充三角形 // ctx.beginPath() // ctx.moveTo(75, 50) // ctx.lineTo(100, 75) // ctx.lineTo(100, 25) // ctx.fill() // 描边三角形 ctx.beginPath(); ctx.moveTo(125, 125); ctx.lineTo(125, 45); ctx.lineTo(45, 125); ctx.closePath(); ctx.stroke();} 绘制梯形1234567891011var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.beginPath(); ctx.moveTo(35, 25); ctx.lineTo(125, 25); ctx.lineTo(155, 75); ctx.lineTo(5, 75); ctx.lineTo(35, 25); ctx.stroke();} 绘制笑脸绘制圆弧或者圆的时候，我们可以使用如下方法： arc(x, y, radius, startAngle, endAngle, anticlockwise) 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。 arcTo(x1, y1, x2, y2, radius) 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。 anticlockwise为true则表示逆时针绘制。 注意 arc()函数中表示角的单位是弧度，不是角度。角度与弧度的js表达式: 弧度=(Math.PI/180)*角度。 12345678910111213var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.beginPath(); ctx.arc(75, 75, 50, 0, Math.PI * 2, true); // 绘制 ctx.moveTo(110, 75); ctx.arc(75, 75, 35, 0, Math.PI, false); // 口(顺时针) ctx.moveTo(65, 65); ctx.arc(60, 65, 5, 0, Math.PI * 2, true); // 左眼 ctx.moveTo(95, 65); ctx.arc(90, 65, 5, 0, Math.PI * 2, true); // 右眼 ctx.stroke();} 二次贝塞尔曲线及三次贝塞尔曲线下一个十分有用的路径类型就是贝塞尔曲线。二次及三次贝塞尔曲线都十分有用，一般用来绘制复杂有规律的图形 quadraticCurveTo(cp1x, cp1y, x, y) 绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) 绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。 下面的图示能够很好的描述两者的关系，二次贝塞尔曲线有一个开始点（蓝色）、一个结束点（蓝色）以及一个控制点（红色），而三次贝塞尔曲线有两个控制点 1234567891011121314151617181920212223242526var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') // 绘制二次贝塞尔曲线 渲染对话气泡 ctx.beginPath() ctx.moveTo(75, 25) ctx.quadraticCurveTo(25, 25, 25, 75) ctx.quadraticCurveTo(25, 125, 75, 125) ctx.quadraticCurveTo(50, 140, 40, 135) ctx.quadraticCurveTo(60, 140, 90, 125) ctx.quadraticCurveTo(90, 125, 170, 125) ctx.quadraticCurveTo(220, 125, 220, 75) ctx.quadraticCurveTo(220, 25, 170, 25) ctx.quadraticCurveTo(170, 25, 75, 25) ctx.stroke() // 绘制二次贝塞尔曲线 渲染对话气泡 // ctx.beginPath(); // ctx.moveTo(75, 25); // ctx.quadraticCurveTo(25, 25, 25, 62.5); // ctx.quadraticCurveTo(25, 100, 50, 100); // ctx.quadraticCurveTo(50, 120, 30, 125); // ctx.quadraticCurveTo(60, 120, 65, 100); // ctx.quadraticCurveTo(125, 100, 125, 62.5); // ctx.quadraticCurveTo(125, 25, 75, 25); // ctx.stroke();} 线性相关的属性 lineWidth：设置线宽 strokeStyle：设置线条颜色，值可以为 16进制、颜色字符串、rgb、rgba、渐变色 fillStyle：设置填充颜色 lineCap：设置线段两端的样式 butt：默认 round：设置线段两端为突出的圆角图形 square：设置线段两端为突出的方形图形 lineJoin：设置线段相交点的样式 round：圆角样式 bevel：平角样式 miter：尖角样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 绘制颜色 var canvas = document.getElementById('canvasId'); if (canvas.getContext) { var ctx = canvas.getContext('2d') // fillStyle: 绘制颜色 // ctx.fillStyle = '#FD0'; // ctx.fillRect(0,0,75,75); // ctx.fillStyle = '#6C0'; // ctx.fillRect(75,0,75,75); // ctx.fillStyle = '#09F'; // ctx.fillRect(0,75,75,75); // ctx.fillStyle = '#F30'; // ctx.fillRect(75,75,75,75); // ctx.fillStyle = '#FFF'; // 设置透明度值 // ctx.globalAlpha = 0.2; // 画半透明圆 // for (var i=0;i&lt;7;i++){ // ctx.beginPath(); // ctx.arc(75,75,10+10*i,0,Math.PI*2,true); // ctx.fill(); // } // lineJoin: 线两端设置样式 ctx.lineWidth = 15; ctx.lineJoin = 'miter'; ctx.beginPath(); ctx.moveTo(20,20); ctx.lineTo(100,50); ctx.lineTo(20,100); ctx.stroke(); }// 绘制破浪 var canvas = document.getElementById('canvasId'); if (canvas.getContext) { var ctx = canvas.getContext('2d') var lineJoin = ['round', 'bevel', 'miter']; ctx.lineWidth = 10; for (var i = 0; i &lt; lineJoin.length; i++) { ctx.lineJoin = lineJoin[i]; ctx.beginPath(); ctx.moveTo(-5, 5 + i * 40); ctx.lineTo(35, 45 + i * 40); ctx.lineTo(75, 5 + i * 40); ctx.lineTo(115, 45 + i * 40); ctx.lineTo(155, 5 + i * 40); ctx.stroke(); } } 绘制阴影效果属性： shadowOffsetX: 设置阴影在 X 延伸距离，不受变换矩阵所影响，负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，默认 0 shadowOffsetY: 设置阴影在 Y 轴的延伸距离，不受变换矩阵所影响，负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，默认 0 shadowBlur: 设置阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0 shadowColor: 标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色 12345678910111213var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.shadowColor = \"#545454\"; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 5; ctx.shadowBlur = 2; ctx.beginPath(); ctx.moveTo(20,20); ctx.lineTo(100,50); ctx.lineTo(20,100); ctx.stroke();} 绘制立体圆圈12345678910111213141516var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.fillStyle = \"#FFF\"; ctx.fillRect(0,0,400,300); ctx.shadowColor = \"#545454\"; ctx.shadowOffsetX = 5; ctx.shadowOffsetY = 5; ctx.shadowBlur = 2; ctx.arc(200, 150, 200, 0, Math.PI * 2 ,false); ctx.arc(200, 150, 115, 0, Math.PI * 2 ,true); ctx.fillStyle = \"#00AAAA\"; ctx.fill();} 绘制文本canvas 提供了两种方法来渲染文本: fillText(text, x, y [, maxWidth]) 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的. strokeText(text, x, y [, maxWidth]) 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的. 12345678var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.font = \"48px serif\"; ctx.textAlign = 'center'; // ctx.fillText(\"Hello world\", 10, 50); ctx.strokeText(\"Hello world\", 10, 50);} 有样式的文本: font = value 当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。 textAlign = value 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。 textBaseline = value 基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。 direction = value 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。 12345678910var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.font = \"40px sans-serif\"; ctx.textAlign = 'left' ctx.textBaseline = \"hanging\"; ctx.direction = 'inherit'; // ctx.fillText(\"Hello world\", 10, 50); ctx.strokeText(\"Hello world\", 10, 50);} 当你需要获得更多的文本细节时，下面的方法可以给你测量文本的方法。 measureText() 将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。 123456789var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.font = \"40px sans-serif\"; // ctx.fillText(\"Hello world\", 10, 50); ctx.strokeText(\"Hello world\", 10, 50); var text = ctx.measureText(\"foo\"); // TextMetrics object console.log(text.width) // 16;} 渐变我们用下面的方法新建一个 canvasGradient 对象，并且赋给图形的 fillStyle 或 strokeStyle 属性 createLinearGradient(x1, y1, x2, y2): createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。 createRadialGradient(x1, y1, r1, x2, y2, r2): createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。 创建出 canvasGradient 对象后，我们就可以用 addColorStop 方法给它上色了 gradient.addColorStop(position, color): 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等） 123456var radgrad = ctx.createRadialGradient(45,45,10,52,50,30); radgrad.addColorStop(0, '#A7D30C'); radgrad.addColorStop(0.9, '#019F62'); radgrad.addColorStop(1, 'rgba(1,159,98,0)'); ctx.fillStyle = radgrad; ctx.fillRect(0,0,150,150); 使用图片引入图像到canvas里需要以下两步基本操作： 获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片 使用drawImage()函数将图片绘制到画布上 canvas的API可以使用下面这些类型中的一种作为图片的源： HTMLImageElement 这些图片是由Image()函数构造出来的，或者任何的&lt;img&gt;元素。 HTMLVideoElement 用一个HTML的 &lt;video&gt;元素作为你的图片源，可以从视频中抓取当前帧作为一个图像。 HTMLCanvasElement 可以使用另一个 &lt;canvas&gt; 元素作为你的图片源。 ImageBitmap 这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。 这些源统一由 CanvasImageSource 类型来引用。 第一步：获得需要绘制的图片方法-&gt; 我们可以通过下列方法的一种来获得与canvas相同页面内的图片的引用： document.images集合 document.getElementsByTagName()方法如果你知道你想使用的指定图片的ID，你可以用document.getElementById()获得这个图片 使用其它域名下的图片: 在 HTMLImageElement 上使用crossOrigin属性，你可以请求加载其它域名上的图片。如果图片的服务器允许跨域访问这个图片，那么你可以使用这个图片而不污染canvas，否则，使用这个图片将会污染canvas 使用其它 canvas 元素: 和引用页面内的图片类似地，用 document.getElementsByTagName 或 document.getElementById 方法来获取其它 canvas 元素。但你引入的应该是已经准备好的 canvas。 由零开始创建图像: 或者我们可以用脚本创建一个新的 HTMLImageElement 对象。要实现这个方法，我们可以使用很方便的Image()构造函数。12var img = new Image(); // 创建一个&lt;img&gt;元素img.src = 'myImage.png'; // 设置图片源地址 当脚本执行后，图片开始装载。若调用 drawImage 时，图片没装载完，那什么都不会发生（在一些旧的浏览器中可能会抛出异常）。因此你应该用load事件来保证不会在加载完毕之前使用这个图片：123456var img = new Image(); // 创建img元素img.onload = function(){ // 执行drawImage语句}img.src = 'myImage.png'; // 设置图片源地址// 如果你只用到一张图片的话，这已经够了 通过 data: url 方式嵌入图像 1img.src = 'data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw=='; 使用视频帧: 你还可以使用 中的视频帧（即便视频是不可见的）。例如，如果你有一个ID为“myvideo”的 元素，你可以这样做： 123456789function getMyVideo() { var canvas = document.getElementById('canvas'); if (canvas.getContext) { var ctx = canvas.getContext('2d'); return document.getElementById('myvideo'); }}// 它将为这个视频返回HTMLVideoElement对象，正如我们前面提到的，它可以作为我们的Canvas图片源 第二步：绘制图片-&gt;一旦获得了源图对象，我们就可以使用 drawImage 方法将它渲染到 canvas 里。drawImage 方法有三种形态，下面是最基础的一种。 drawImage(image, x, y)其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。 drawImage(image, x, y, width, height)这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小 drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)参数参照下面的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。 利用drawImage的切片功能123456789101112var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') var img = new Image(); img.onload = () =&gt; { // 绘制的原图片 切片前 ctx.drawImage(img,0,0); // 绘制切片后 ctx.drawImage(img,33,71,104,124,300,80,100,104); }; img.src = 'https://mdn.mozillademos.org/files/5397/rhino.jpg';} 效果如下： 平铺图像123456789101112131415var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') // 第一步：由零开始创建图像 var img = new Image(); img.onload = () =&gt; { for (var i=0;i&lt;4;i++){ for (var j=0;j&lt;3;j++){ // 第二步：获取到图片源img，drawImage 绘制图片 ctx.drawImage(img,j*50,i*38,50,38); } } }; img.src = 'https://mdn.mozillademos.org/files/5397/rhino.jpg';} 平铺3行4列效果如下： 控制图像的缩放行为Gecko 1.9.2 引入了 mozImageSmoothingEnabled 属性，值为 false 时，图像不会平滑地缩放。默认是 true 。1cx.mozImageSmoothingEnabled = false; canvas变形状态的保存和恢复在下面学习变形之前，先介绍两个在开始绘制复杂图形时必不可少的方法: save() 保存画布(canvas)的所有状态 restore() save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。 Canvas状态存储在栈中，每当 save() 方法被调用后，当前的状态就被推送到栈中保存你可以调用任意多次 save 方法。每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。 连续矩形绘制1234567891011121314151617181920var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.fillRect(0,0,150,150); // 使用默认设置绘制一个矩形 ctx.save(); // 保存默认颜色状态1 ctx.fillStyle = '#09F' // 在原有配置基础上对颜色做改变 ctx.fillRect(15,15,120,120); // 使用新的设置绘制一个矩形 ctx.save(); // 保存当前颜色状态2 ctx.fillStyle = '#FFF' // 再次改变颜色配置 ctx.globalAlpha = 0.5; ctx.fillRect(30,30,90,90); // 使用新的配置绘制一个矩形 ctx.restore(); // 重新加载之前的颜色状态2 ctx.fillRect(45,45,60,60); // 使用上一次的配置绘制一个矩形 ctx.restore(); // 重新加载默认颜色状态1 ctx.fillRect(60,60,30,30); // 使用加载的配置绘制一个矩形} 移动 Translating translate(x, y): 它用来移动 canvas 和它的原点到一个不同的位置; x 是左右偏移量，y 是上下偏移量，如下图所示。 这个例子显示了一些移动 canvas 原点的好处。如果不使用 translate 方法，那么所有矩形都将被绘制在相同的位置（0,0）。translate 方法同时让我们可以任意放置这些图案，而不需要在 fillRect() 方法中手工调整坐标值，既好理解也方便使用。 我在 draw 方法中调用 fillRect() 方法 9 次，用了 2 层循环。每一次循环，先移动 canvas ，画螺旋图案，然后恢复到原始状态 1234567891011121314var canvas = document.getElementById('canvasId'); if (canvas.getContext) { var ctx = canvas.getContext('2d') for (var i = 0; i &lt; 3; i++) { for (var j = 0; j &lt; 3; j++) { // 在做变形之前先保存状态是一个良好的习惯 ctx.save(); ctx.fillStyle = 'rgb(' + (51 * i) + ', ' + (255 - 51 * i) + ', 255)'; ctx.translate(10 + j * 50, 10 + i * 50); ctx.fillRect(0, 0, 25, 25); ctx.restore(); } }} 旋转 Rotating第二个介绍 rotate 方法，它用于以原点为中心旋转 canvas。 rotate(angle) 这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。 通过例子了解一下：这里我们又用到了两层循环。第一层循环决定环的数量，第二层循环决定每环有多少个点。每环开始之前，我都保存一下 canvas 的状态，这样恢复起来方便。每次画圆点，我都以一定夹角来旋转 canvas，而这个夹角则是由环上的圆点数目的决定的。最里层的环有 6 个圆点，这样，每次旋转的夹角就是 360/6 = 60 度。往外每一环的圆点数目是里面一环的 2 倍，那么每次旋转的夹角随之减半1234567891011121314151617var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.translate(75,75); for (var i=1;i&lt;6;i++){ // Loop through rings (from inside to out) ctx.save(); ctx.fillStyle = 'rgb('+(51*i)+','+(255-51*i)+',255)'; for (var j=0;j&lt;i*6;j++){ // draw individual dots ctx.rotate(Math.PI*2/(i*6)); ctx.beginPath(); ctx.arc(0,i*12.5,5,0,Math.PI*2,true); ctx.fill(); } ctx.restore(); }} 缩放 Scaling接着是缩放。我们用它来增uni-app减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。 scale(x, y) 可以缩放画布的水平和垂直的单位。两个参数都是实数，可以为负数，x 为水平缩放因子，y 为垂直缩放因子，如果比1小，会比缩放图形， 如果比1大会放大图形。默认值为1， 为实际大小。 画布初始情况下， 是以左上角坐标为原点的第一象限。如果参数为负实数， 相当于以x 或 y轴作为对称轴镜像反转（例如， 使用translate(0,canvas.height); scale(1,-1); 以y轴作为对称轴镜像反转， 就可得到著名的笛卡尔坐标系，左下角为原点）。 默认情况下，canvas 的 1 个单位为 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍 12345678910111213var canvas = document.getElementById('canvasId');if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.save(); ctx.scale(10, 3); ctx.fillRect(5, 10, 10, 10); ctx.restore(); // mirror horizontally ctx.scale(-1, 1); ctx.font = '48px serif'; ctx.fillText('QILANBEI', -180, 120);} 变形 Transforms状态的保存和恢复在下面学习变形之前，先介绍两个在开始绘制复杂图形时必不可少的方法:• save() 保存画布(canvas)的所有状态• restore() save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。•Canvas状态存储在栈中，每当 save() 方法被调用后，当前的状态就被推送到栈中保存你可以调用任意多次 save 方法。每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。 连续矩形绘制：1234567891011121314151617181920var canvas = document.getElementById('canvasId'); if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.fillRect(0,0,150,150); // 使用默认设置绘制一个矩形 ctx.save(); // 保存默认颜色状态1 ctx.fillStyle = '#09F' // 在原有配置基础上对颜色做改变 ctx.fillRect(15,15,120,120); // 使用新的设置绘制一个矩形 ctx.save(); // 保存当前颜色状态2 ctx.fillStyle = '#FFF' // 再次改变颜色配置 ctx.globalAlpha = 0.5; ctx.fillRect(30,30,90,90); // 使用新的配置绘制一个矩形 ctx.restore(); // 重新加载之前的颜色状态2 ctx.fillRect(45,45,60,60); // 使用上一次的配置绘制一个矩形 ctx.restore(); // 重新加载默认颜色状态1 ctx.fillRect(60,60,30,30); // 使用加载的配置绘制一个矩形} 如图所示： 移动 Translatingtranslate(x, y): 它用来移动 canvas 和它的原点到一个不同的位置; x 是左右偏移量，y 是上下偏移量，如下图所示: 通过例子来了解一下：用draw 方法中调用 fillRect() 方法 9 次，用了 2 层循环。每一次循环，先移动 canvas ，画螺旋图案，然后恢复到原始状态 123456789101112function draw() { var ctx = document.getElementById('canvas').getContext('2d'); for (var i = 0; i &lt; 3; i++) { for (var j = 0; j &lt; 3; j++) { ctx.save(); ctx.fillStyle = 'rgb(' + (51 * i) + ', ' + (255 - 51 * i) + ', 255)'; ctx.translate(10 + j * 50, 10 + i * 50); ctx.fillRect(0, 0, 25, 25); ctx.restore(); } }} 旋转 Rotating第二个介绍 rotate 方法，它用于以原点为中心旋转 canvas。 rotate(angle) 这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。 通过例子了解一下：这里我们又用到了两层循环。第一层循环决定环的数量，第二层循环决定每环有多少个点。每环开始之前，我都保存一下 canvas 的状态，这样恢复起来方便。每次画圆点，我都以一定夹角来旋转 canvas，而这个夹角则是由环上的圆点数目的决定的。最里层的环有 6 个圆点，这样，每次旋转的夹角就是 360/6 = 60 度。往外每一环的圆点数目是里面一环的 2 倍，那么每次旋转的夹角随之减半 1234567891011121314151617var canvas = document.getElementById('canvasId'); if (canvas.getContext) { var ctx = canvas.getContext('2d') ctx.translate(75,75); for (var i=1;i&lt;6;i++){ // Loop through rings (from inside to out) ctx.save(); ctx.fillStyle = 'rgb('+(51*i)+','+(255-51*i)+',255)'; for (var j=0;j&lt;i*6;j++){ // draw individual dots ctx.rotate(Math.PI*2/(i*6)); ctx.beginPath(); ctx.arc(0,i*12.5,5,0,Math.PI*2,true); ctx.fill(); } ctx.restore(); } } 非零环绕原则 目的：确定某一区域是否需要填充。 描述：定义计数默认为0，从当前区域选取任意点，然后从该点到整个图形外部绘制一条射线。 观察和这条射线相交的所有线段。 如果该相交的线段是顺时针穿过这条射线，那么 计数 + 1；如果是逆时针穿过，那么计数就 - 1； 如果计数为 0，那么就不填充该区域； 如果计数非 0 ，那么就填充该区域。 练习：绘制空心矩形 总结：从左到右穿出 或 从上至下 穿出，那么就是顺时针。计数 + 1；否则， 计数 - 1； 奇-偶原则 目的：同上 描述：就看相交线的个数，如果为奇数，就填充；否则就不填充。 纵向的颜色渐变绘制坐标系折线图中点的描绘用小矩形来描绘点","link":"/2015/10/26/canvas/"},{"title":"core-js@3","text":"core-js@3升级之旅 core-js 是什么，有什么作用 core-js是一个用于JavaScript的模块化标准库 它支持最新的ECMAScript标准，包含截至2019年ECMAScript的polyfill：promises，符号，集合，迭代器，类型化数组等许多其他功能 ECMAScript 标准库提案 一些 WHATGW / W3C 标准（跨平台或者 ECMAScript 相关） 最大程度模块化：可以轻松地选择仅加载将要使用的功能 使用它而不会导致全局命名空间污染 它与babel紧密集成：这允许对core-js导入进行许多优化 来自作者官方阐述，它是最普遍、最流行给 JavaScript 标准库打补丁的方式，但是有很大一部分开发者并不知道他们间接的使用了core-js，比如你使用了 babel-runtime、babel-plugin-transform-runtime 或者 babel-polyfill，你就已经间接的引入了 core-js 标准库。 core-js@3 有哪些变化参考：https://juejin.im/post/6844904055005773831 babel重遇到core-js版本问题的处理参考：https://segmentfault.com/a/1190000020237817 升级core-js@3动机参考：https://www.cnblogs.com/sefaultment/p/11631314.html core-js@3升级之旅参考：https://segmentfault.com/a/1190000020237817","link":"/2020/08/18/core-js/"},{"title":"CSS相关总结","text":"CSS相关及一些兼容性问题 1.cursor:hand VS cursor:pointerfirefox不支持hand，但ie支持pointer解决方法: 统一使用pointer2.innerText在IE中能正常工作，但在FireFox中却不行.需用textContent。解决方法:if(navigator.appName.indexOf(“Explorer”) &gt; -1){ document.getElementById(‘element’).innerText = “my text”;} else{ document.getElementById(‘element’).textContent = “my text”;}3.CSS透明IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。FF：opacity:0.6。4.css中的width和padding在IE7和FF中width宽度不包括padding，在Ie6中包括padding.5.FF和IEBOX模型解释不一致导致相差2pxbox.style{width:100px;border 1px;}ie理解为box.width = 100px;ff理解为box.width = 100px; + 1*2px = 102px //加上边框2px解决方法：div{margin:30px!important;margin:28px;}注意这两个margin的顺序一定不能写反， IE不能识别!important这个属性，但别的浏览器可以识别。所以在IE下其实解释成这样：div{maring:30px;margin:28px}重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important;6.IE5 和IE6的BOX解释不一致IE5下div{width:300px;margin:0 10px 0 10px;}div 的宽度会被解释为300px-10px(右填充)-10px(左填充)，最终div的宽度为280px，而在IE6和其他浏览器上宽度则是以 300px+10px(右填充)+10px(左填充)=320px来计算的。这时我们可以做如下修改 div{width:300px!important;width /**/:340px;margin:0 10px 0 10px}7.ul和ol列表缩进问题消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px;经验证，在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响；在 Firefox 中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list- style:none才能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、 padding:0px以及list-style:none三项才能达到最终效果。8.元素水平居中问题FF: margin:0 auto;IE: 父级{ text-align:center; }9.Div的垂直居中问题vertical-align:middle; 将行距增加到和整个DIV一样高：line-height:200px; 然后插入文字，就垂直居中了。缺点是要控制内容不要换行。10.margin加倍的问题设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。解决方案是在这个div里面加上display:inline;例如：1&lt;div id=”imfloat”&gt; 相应的css为1234#imfloat{ float:left; margin:5px;/*IE下理解为10px*/ display:inline;/*IE下再理解为5px*/} 11.IE与宽度和高度的问题IE不认得min-这个定义，但实际上它把正常的width和height当作有min的情况来使。这样问题就大了，如果只用宽度和高度，正常的浏览器里这两个值就不会变，如果只用min-width和min-height的话，IE下面根本等于没有设置宽度和高度。比如要设置背景图片，这个宽度是比较重要的。要解决这个问题，可以这样：12#box{ width: 80px; height: 35px;}html&gt;body #box{ width: auto; height: auto; min-width: 80px; min-height: 35px;} 12.页面的最小宽度如上一个问题，IE不识别min，要实现最小宽度，可用下面的方法：1#container{ min-width: 600px; width:expression(document.body.clientWidth＜ 600? &quot;600px&quot;: &quot;auto&quot; );} 第一个min-width是正常的；但第2行的width使用了Javascript，这只有IE才认得，这也会让你的HTML文档不太正规。它实际上通过Javascript的判断来实现最小宽度。13.DIV浮动IE文本产生3象素的bug左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有3px的间距.12345678#box{ float:left; width:800px;} #left{ float:left; width:50%;} #right{ width:50%;} *html #left{ margin-right:-3px; //这句是关键} &lt;div id=&quot;box&quot;&gt;&lt;div id=&quot;left&quot;&gt;＜/div&gt;&lt;div id=&quot;right&quot;&gt;＜/div&gt;&lt;/div&gt; 14.IE捉迷藏的问题当div应用复杂的时候每个栏中又有一些链接，DIV等这个时候容易发生捉迷藏的问题。有些内容显示不出来，当鼠标选择这个区域是发现内容确实在页面。解决办法：对#layout使用line-height属性或者给#layout使用固定高和宽。页面结构尽量简单。15.float的div闭合;清除浮动;自适应高度①例如：＜div id=”floatA”&gt;＜div id=”floatB”&gt;＜div id=”NOTfloatC”&gt;这里的NOTfloatC并不希望继续平移，而是希望往下排。(其中floatA、floatB的属性已经设置为float:left;)这段代码在IE中毫无问题，问题出在FF。原因是NOTfloatC并非float标签，必须将float标签闭合。在＜div class=”floatB”&gt;＜div class=”NOTfloatC”&gt;之间加上＜div class=”clear”&gt;这个div一定要注意位置，而且必须与两个具有float属性的div同级，之间不能存在嵌套关系，否则会产生异常。并且将clear这种样式定义为为如下即可：.clear{clear:both;}②作为外部 wrapper 的 div 不要定死高度,为了让高度能自适应，要在wrapper里面加上overflow:hidden; 当包含float的box的时候，高度自适应在IE下无效，这时候应该触发IE的layout私有属性(万恶的IE啊！)用zoom:1;可以做到，这样就达到了兼容。例如某一个wrapper如下定义：.colwrapper{overflow:hidden; zoom:1; margin:5px auto;}③对于排版,我们用得最多的css描述可能就是float:left.有的时候我们需要在n栏的float div后面做一个统一的背景,譬如: ＜/div&gt; ＜/div&gt; ＜/div&gt;比如我们要将page的背景设置成蓝色,以达到所有三栏的背景颜色是蓝色的目的,但是我们会发现随着left center right的向下拉长,而page居然保存高度不变,问题来了,原因在于page不是float属性,而我们的page由于要居中,不能设置成float,所以我们应该这样解决： ＜/div&gt; ＜/div&gt; ＜/div&gt;再嵌入一个float left而宽度是100%的DIV解决之。④万能float 闭合(非常重要!)关于 clear float 的原理可参见 [How To Clear Floats Without Structural Markup],将以下代码加入Global CSS 中,给需要闭合的div加上class=”clearfix” 即可,屡试不爽。1234567/* Clear Fix */ .clearfix:after { content:&quot;.&quot;; display:block; height:0; clear:both; visibility:hidden; } .clearfix { display:inline-block; } /* Hide from IE Mac */ .clearfix {display:block;} /* End hide from IE Mac */ /* end of clearfix */ 或者这样设置：.hackbox{ display:table; //将对象作为块元素级的表格显示}16.高度不适应高度不适应是当内层对象的高度发生变化时外层高度不能自动进行调节，特别是当内层对象使用margin 或padding时。例：12345#box {background-color:#eee; } #box p {margin-top: 20px;margin-bottom: 20px; text-align:center; } &lt;div id=&quot;box&quot;&gt;&lt;p&gt;p对象中的内容＜/p&gt;&lt;/div&gt; 解决技巧：在P对象上下各加2个空的div对象CSS代码{height:0px;overflow:hidden;}或者为DIV加上border属性。17.IE6下图片下有空隙产生解决这个BUG的技巧有很多,可以是改变html的排版,或者设置img为display:block或者设置vertical-align属性为vertical-align:top/bottom/middle/text-bottom 都可以解决.18.对齐文本与文本输入框加上vertical-align:middle;12345678910&lt;style type=&quot;text/css&quot;&gt;&lt;!--input { width:200px; height:30px; border:1px solid red; vertical-align:middle; } --&gt;&lt;/style&gt; 经验证，在IE下任一版本都不适用，而ff、opera、safari、chrome均OK！19.LI中内容超过长度后以省略号显示此技巧适用与IE、Opera、safari、chrom浏览器，FF暂不支持。1234567891011&lt;style type=&quot;text/css&quot;&gt;&lt;!--li { width:200px; white-space:nowrap; text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow: hidden; }--&gt;&lt;/style&gt; 20.为什么web标准中IE无法设置滚动条颜色了解决办法是将body换成html123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;!-- html { scrollbar-face-color:#f6f6f6; scrollbar-highlight-color:#fff; scrollbar-shadow-color:#eeeeee; scrollbar-3dlight-color:#eeeeee; scrollbar-arrow-color:#000; scrollbar-track-color:#fff; scrollbar-darkshadow-color:#fff; } --&gt;＜/style&gt; 21.为什么无法定义1px左右高度的容器IE6下这个问题是因为默认的行高造成的,解决的技巧也有很多：例如:overflow:hidden zoom:0.08 line-height:1px16.怎么样才能让层显示在FLASH之上呢解决的办法是给FLASH设置透明 22.链接(a标签)的边框与背景a链接加边框和背景色，需设置 display: block, 同时设置 float: left 保证不换行。参照menubar, 给 a 和menubar设置高度是为了避免底边显示错位, 若不设 height, 可以在menubar中插入一个空格。23.超链接访问过后hover样式就不出现的问题被点击访问过的超链接样式不在具有hover和active了,很多人应该都遇到过这个问题,解决技巧是改变CSS属性的排列顺序: L-V-H-ACode:12345678&lt;style type=&quot;text/css&quot;&gt;&lt;!--a:link {} a:visited {} a:hover {} a:active {} --&gt;&lt;/style&gt; 24.FORM标签这个标签在IE中,将会自动margin一些边距,而在FF中margin则是0,因此,如果想显示一致,所以最好在css中指定margin和 padding,针对上面两个问题,我的css中一般首先都使用这样的样式ul,form{margin:0;padding:0;}。25.属性选择器(这个不能算是兼容,是隐藏css的一个bug)p[id]{}div[id]{}这个对于IE6.0和IE6.0以下的版本都隐藏,FF和OPera作用.属性选择器和子选择器还是有区别的,子选择器的范围从形式来说缩小了,属性选择器的范围比较大,如p[id]中,所有p标签中有id的都是同样式的.26.为什么FF下文本无法撑开容器的高度标准浏览器中固定高度值的容器是不会象IE6里那样被撑开的,那我又想固定高度,又想能被撑开需要怎样设置呢？办法就是去掉height设置min-height:200px; 这里为了照顾不认识min-height的IE6 可以这样定义:12345{ height:auto!important; height:200px; min-height:200px; } 27.什么是css包含块答：包含块（Containing Block）：作用是为它里面包含的元素提供一个参考，元素的尺寸和位置的计算往往是由该元素所在的包含块决定的，包含块简单说就是定位参考框，或者定位坐标参考系，元素一旦定义了定位显示（相对、绝对、固定）都具有包含块性质，它所包含的定位元素都将以该包含块为坐标系进行定位和调整。★★ 一个元素的 containing block 按以下方式定义：(1)用户代理（比如浏览器）选择根元素作为 containing block（称之为初始 containing block：IBC）。★ 在(X)HTML中，根元素是html元素（尽管有的浏览器会不正确地使用body元素）。★ 而初始包含块的direction属性与根元素相同。(direction属性指定了块的基本书写方向，它还规定了表格列布局的方向、水平溢出的方向等。)★ 对于连续媒体（如电脑浏览器），初始包含块是视口大小的一个矩形。(2)对于其它元素，如果该元素的定位（position）为“relative（相对）”或者“static（静态）”，包含框 由最近的块级祖先元素盒子，或者是单元格（table cell）或者是行内块(inline-block)祖先元素的内容边界组成。(3)如果元素有属性 ‘position:fixed’，containing block 由视口建立。(4)如果元素有属性 ‘position:absolute’，containing block 由最近的 position 不是 static 的祖先建立，按下面的步骤：a) 如果祖先是块级元素，containing block 由祖先的 padding edge 形成。b) 如果祖先是内联元素，containing block 取决于祖先的 direction 属性。(i)如果 direction 是 ltr（左到右），祖先产生的第一个盒子的上、左内容边界是 containing block 的上方和左方，祖先的最后一个盒子的下、右内容边界是 containing block 的下方和右方。(ii)如果 direction 是 rtl（右到左），祖先产生的第一个盒子的上、右内容边界是 containing block 的上方和右方，祖先的最后一个盒子的下、左内容边界是 containing block 的下方和左方。c) 如果没有祖先，根元素盒子的内容边界确定为 containing block","link":"/2016/04/26/css-study/"},{"title":"你应该知道的css细节及技巧","text":"你应该知道的css细节及技巧 1. 关于line-height1234CSS中的 line-hight 属性是用来控制文本行之间的空隙的，line-height有单位时，子元素是继承父元素的line-height的，无单位时，其line-height等于无单位的数值乘以子元素本身的字体大小。显然为了不出现意外，还是建议首选无单位的。 2. 文字溢出了不美观, 添加末尾省略号1234567891011121314&lt;!--添加固定高度--&gt;width: 100px;&lt;!--段落中的文本不进行换行 默认值normal--&gt;white-space: nowrap;&lt;!--超出部分截掉--&gt;overflow: hidden;&lt;!--当文本溢出包含元素时发生的事情 参数如下：--&gt;&lt;!--clip(默认值) 修剪文本--&gt;&lt;!--ellipsis 显示省略符号来代表被修剪的文本--&gt;&lt;!--string 使用给定的字符串来代表被修剪的文本--&gt;text-overflow: ellipsis; 3. 块元素垂直居中1234567&lt;!--父元素--&gt;display: table&lt;!--子元素--&gt;display: table-cell;vertical-align: middle; 4. 移动端滚动流畅效果-webkit-overflow-scrolling属性是来控制元素在移动设备上是否有回弹的效果 在移动端上，在你用overflow-y:scorll属性的时候，你会发现滚动的效果很木，很慢，这时候可以使用-webkit-overflow-scrolling:touch这个属性，让滚动条产生滚动回弹的效果，就像ios原生的滚动条一样流畅 参数: auto 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。 touch 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。 兼容性写法：12verflow:auto;/* winphone8和android4+ */-webkit-overflow-scrolling: touch; /* ios5+ */ bug注意 当你给一个元素设置过position:absolute;或者position:relative;后再增加-webkit-overflow-scrolling: touch;属性后，你会发现，滑动几次后可滚动区域会卡主，不能在滑动，这时给元素增加个z-index值就可以了 -webkit-overflow-scrolling的更多查看","link":"/2016/04/26/css-skill/"},{"title":"最近遇到的问题整理","text":"最近遇到的问题整理 问题：jquery animation 方法 overflow:hidden 页面闪烁的问题解决：相应dom上设置overflow:visiable !important 问题：element-ui 的 table组件 在 safari 浏览器上 列宽样式 错乱问题解决：因为table没有设置width: 100% !important 导致的精度问题） 网页加载图片加载不出来 12&lt;meta name=&quot;referrer&quot; content=&quot;same-origin&quot;&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt; 高德地图的问题 12345//使用loadUI AMapUI.loadUI([&apos;overlay/SimpleMarker&apos;], function(SimpleMarker){ ... }); //如果使用load，路径要前缀补上&apos;ui/&apos;： AMapUI.load([&apos;ui/overlay/SimpleMarker&apos;], function(SimpleMarker){ ... });","link":"/2019/07/01/current-issues/"},{"title":"Echarts 图表tooltip的自动播放","text":"Echarts 图表tooltip的自动播放 123456789101112131415161718192021222324252627282930313233// 写一个函数，参数为chart图表的ref参数， 自动播放的间隔时间time// 注意chart的option配置项series 要写成数据的形式，如果为对象 修改函数里面series的判断autoPlayToopTip (chartRef, time = 1500) { let dataIndex = -1 let dataLen = 0 if (typeof chartRef !== &apos;undefined&apos; &amp;&amp; typeof chartRef.options.series !== &apos;undefined&apos;) { if (chartRef.options.series.length &gt; 0 &amp;&amp; typeof chartRef.options.series[0].data !== &apos;undefined&apos;) { dataLen = chartRef.options.series[0].data.length } setInterval(() =&gt; { chartRef.dispatchAction({ type: &apos;downplay&apos;, playState: true, seriesIndex: 0, dataIndex }) dataIndex = (dataIndex + 1) % dataLen chartRef.dispatchAction({ type: &apos;highlight&apos;, playState: true, seriesIndex: 0, dataIndex }) // 显示 tooltip chartRef.dispatchAction({ type: &apos;showTip&apos;, seriesIndex: 0, playState: true, dataIndex }) }, time) } },","link":"/2018/07/22/echart-tooltipAuto/"},{"title":"D3.js学习","text":"D3.js学习笔记 官方网站：https://d3js.org/ 什么是D3.jsD3 的全称是（Data-Driven Documents）,是一个用动态图形显示数据的JavaScript库，一个数据可视化的工具。兼容W3C标准，并且利用广泛实现的SVG，JavaScript，和CSS标准。它是早期的Protovis框架的继承者。与其他的类库相比，D3对视图结果有很大的可控性。 D3 API总结核心 - 包括选择器，过渡，数据处理，本地化，颜色等。地理 - 球面坐标，经纬度运算。几何 - 提供绘制2D几何图形的实用工具。布局 - 推导定位元素的辅助数据。比例尺 - 数据编码和视觉编码之间转换。可缩放矢量图形 - 提供用于创建可伸缩矢量图形的实用工具。时间 - 解析或格式化时间，计算日历的时间间隔等。行为 - 可重用交互行为 各API解析3.1 核心模块★ 选择器：D3提供了两种高级方法来选择元素：select和selectAll。这些方法接收选择器字符串。前者只返回第一个匹配的元素，后者选择在文档遍历次序中所有匹配的元素。这个方法也可以接受节点，这可以用来和第三方库例如JQuery或者开发工具($0)整合。★ 编辑内容1# selection.attr(name[, value]) 如果指定了value参数，将为所有选中的元素通过指定的name为指定的value设置属性。如果value是一个常数，那么所有的元素都将设置为相同的属性值；如果value是一个函数，那么这个函数会为每个选中的元素（按顺序）计算。入参是当前数据元素d和当前索引i，以及代表当前DOM元素的this上下文。这个函数的返回值接下来用来设置每个元素的属性。null值将移除指定的属性。如果value参数没有指定，就会返回为选择中第一个非空（null）元素所指定的属性值。一般来说，只有当你知道选择中恰好包含一个元素时才有用。1# selection.classed(name[, value]) 这个操作能识别class属性是一个按照空格分隔的标记集合。这样它就能使用classList（如果有的话）来方便地添加、移除和切换CSS类。和attr()大致相同，如果value属性被指定，不论是否指定类都会与选定元素相结合。如果value是一个常量且其值为真，那么所有的元素都会被分配指定的类（还没分配的话）。如果其值为假，那么就会移除选中元素的class（已经分配过）。如果value是一个函数，那么这个函数会为每个选中的元素（按顺序）计算。入参是当前数据元素d和当前索引i，以及代表当前DOM元素的this上下文。这个函数的返回值接下来用来分配或者不分配每个元素的class。如果你想一次设置多个class可以使用一个对象，文字如同：selection.classed({‘foo’: true, ‘bar’: false})，或者使用以空格分隔的class列表形如：selection.classed(‘foo bar’, true)。如果value没有被指定，当且仅当选择中首个非空值有指定的class就会返回true。一般来说，只有当你知道选择中恰好包含一个元素时才有用。1# selection.style(name[, value[, priority]]) 和attr()大致相同，如果value参数被指定，通过指定名称和指定的值为所有选中的元素设置CSS样式属性。如果value是一个常数，那么所有的元素都设置相同的样式值；否则，如果值是一个函数，则该函数为每个选定的元件（按顺序）计算，入参是当前数据元素d和当前索引i，以及代表当前DOM元素的this上下文。该函数的返回值被用来设置每个元素的样式属性。 null值将删除样式属性。可选参数priority也可以指定，无论是null空或字符串“important”（不带感叹号）。12// 如果你想一次设置多个样式属性，使用对象文本，如下所示：selection.style({&apos;stroke&apos;: &apos;black&apos;, &apos;stroke-width&apos;: 2}) 1# selection.property(name[, value]) 一些HTML元素具有特殊的属性使用标准的属性或样式是不可寻址的。例如，表单文本（text）字段有一个value字符串属性，复选框（checkboxes）有一个checked布尔型属性。可以使用property操作符来获取或设置这些属性，或任何其他基本元素的可寻址字段，例如className。value参数的介绍和attr()大致相同；12//如果你想一次设置多个属性，可以使用对象文本，如下所示：.property({&apos;checked&apos;:true,&apos;disabled&apos;: false});。 如果未指定值，则返回在选择中第一个非空元素指定属性的值。只有当你知道选择只包含一个元素这通常是很有用的。1# selection.text([value]) 文本操作符是基于textContent属性；设置文本内容将取代任何现有的子元素。value参数的介绍和attr()大致相同；1# selection.html([value]) html的操作基于innerHTML属性；设置内部HTML内容将取代任何现有的子元素。此外，您可能更愿意使用数据驱动的方式append或insert操作创建HTML内容;该操作符的目的是，适用于你想用少量但有丰富格式的HTML。value参数的介绍和attr()大致相同；1# selection.append(name) 在当前选择的每个元素最后追加具有指定名称的新元素，返回包含追加元素的新选择。每个新的元素继承当前元素的数据（如果有的话）和select相同的方式使用子选择。这个name可以被指定为一个常量字符串或一个函数，返回追加的DOM元素。当name被指定为一个字符串，它可能有以下形式的命名空间前缀“namespace:tag”。例如，“svg:text”将在svg命名空间创建“text”元素。默认情况下，D3支持svg，xhtml，xlink的，xml和xmlns命名空间。其他的命名空间可以通过添加到d3.ns.prefix注册。如果没有指定命名空间，那么命名空间会从封闭的元素继承；或者，如果该名称是已知的前缀之一，相应的命名空间将被使用（例如，“svg”表示“svg:svg”）。1# selection.insert(name[, before]) 在当前选择与指定before选择器匹配的每个元素之前插入具有指定name的新元素，返回包含插入的元素的一个新的选择。如果before选择器不匹配任何元素，那么新元素将用append追加为最后一个子元素。每一个新元素继承当前元素（如果有的话）的数据，子选择（subselections）和select以同样的方式。同样地，before选择器可以被指定为一个选择器字符串或一个函数，它返回一个DOM元素。例如，insert(“div”, “:first-child”)将在当前选择前面加上div子节点。对于enter选择器，before选择器在这种情况下也可以省略：输入的元素将被立即插入到更新选择紧随的兄弟元素前（如果有的话）。这使您可以插入DOM的元素与绑定的数据是一致的顺序。但是请注意，如果更新元素修改了顺序，selection.order可能仍然需要。1# selection.remove() 删除从当前文档当前选择中的元素。返回“屏幕外（off-screen）”的当前选择（除去了相同的元素），从DOM分离。需要注意的是目前还没有一个专门的API来重新添加删除的元素到文档；然而，你可以通过一个函数来selection.append或selection.insert重新添加元素。★ 操作数据：1# selection.data([values[, key]]) 连接指定的一组数据的和当前选择。指定的values是一组数据值（例如，数字或对象）或一个函数返回一组值。如果没有指定key函数，则values的第一数据被分配到当前选择中第一元素，第二数据分配给当前选择的第二个元素，依此类推。当数据被分配给一个元素，它被存储在属性data中，从而使数据“沾粘”，从而使数据可以再选择。","link":"/2016/08/20/d3-init/"},{"title":"判断数据类型的几种方法","text":"关于数据类型的几种方法 JS中数据类型检测的四种方式： tyepof [value] ：检测数据类型的运算符 [example] instanceof [class]：检测某一个实例是否属于这个类 [example].constructor===[class]：检测实例和类关系的，从而检测数据类型 Object.prototype.toString.call([value])：检测数据类型 一、typeof 判断基本数据类型功能： 用来检测数据类型的运算符 举例： 123456typeof 1 // \"number\"typeof '1' // \"string\"typeof undefined // \"undefined\"typeof true // \"boolean\"typeof null // \"object\"typeof Symbol() // \"symbol\" 但对于引用数据类型，除了函数之外，都会显示”object”:123typeof [] // \"object\"typeof {} // \"object\"typeof console.log // \"function\" 原理：不同的对象在底层都表示为二进制，在Javascript中二进制前（低）三位存储其类型信息： 000: Object对象类型010: 浮点数100：字符串110：布尔1：整数 所以typeof null 为”object”, 就是因为在Javascript中二进制前（低）三位都为0的话会被判断为Object类型，而null的二进制表示全为0，自然前三位也是0，所以执行typeof时会返回”object” 缺点： NaN / Infinity 都是数字类型的，检测结果都是 “number” typeof null 的结果是”object” typeof 普通对象/数组对象/正则对象， 结果都是”object” 二、instanceof 判断类型功能：用来判断某个构造函数的 prototype 属性所指向的对象是否存在于要检测的实例的原型链上，简单说就是判断当前类的原型是否出现在实例的原型链上，注意，instanceof运算符只能用于对象，不适用原始类型的值 举例： 123456let arr = [10, 20];console.log(typeof arr); //=&gt;\"object\"console.log(arr instanceof Array); //=&gt;trueconsole.log(arr instanceof RegExp); //=&gt;falseconsole.log(arr instanceof Object); //=&gt;true 原理：原理就是js的原型继承机制： 每个构造函数都有一个[prototype]属性，这个属性是一个指针，指向一个对象，即：Object.prototype 每个实例对象（object ）都有一个私有属性 proto，指向它的原型对象的prototype 小tip： js 获取原型的四种方式： 1234Object.getPrototypeOf(obj) // 官方推荐obj.__proto__ // 不标准写法obj.constructor.__proto__ // 间接方式获取obj.prototype // 不标准写法 1234var obj = {}console.log(obj._proto_) // 原型对象的prototypeconsole.log(Object.prototype) // 查看一个构造函数的原型对象 输出打印结果如下，所以 obj instanceof Object 是true 原型链图解如下： 缺点： 要求检测的实例必须是对象数据类型的 基本数据类型的实例是无法基于它检测出来的构造函数创建的就可以检测字面量方式创建的不能检测 数组/对象/正则对象，都是 Object 的实例，检测结果都是 TRUE ，所以无法基于这个结果判断是否为普通对象 三、constructor功能：判断当前的实例的 constructor的属性值是不是预估的类 举例：1234567let arr = [], obj = {}, num = 10;console.log(arr.constructor === Array); //=&gt;trueconsole.log(arr.constructor === Object); //=&gt;falseconsole.log(obj.constructor === Object); //=&gt;trueconsole.log(num.constructor === Number); //=&gt;true 原理：实例.constructor 一般都等于类.prototype.constructor 也就是当前类本身 缺点：非常容易被修改，因为JS 中的 constructor 是不被保护的（用户可以自己随便改） 四、Object.prototype.toString.call()功能：找到 Object.prototype 上的 toString 方法，让 toString 方法执行，并且基于 call 让方法中的 this 指向检测的数据值，这样就可以实现数据类型检测了 原理： Object.prototype 用来返回当前实例所属类的信息； 每一种数据类型的构造函数的原型上都有toString 方法； 举例： 123456Object.prototype.toString.call() // 输出\"[object Undefined]\"Object.prototype.toString.call(1) // 输出\"[object Number]\"Object.prototype.toString.call('') // 输出\"[object String]\"Object.prototype.toString.call({}) // 输出\"[object Object]\"Object.prototype.toString.call(new Date()) // 输出\"[object Date]\"Object.prototype.toString.call(/a/) // 输出\"[object RegExp]\" 缺点：只能检测内置类，不能检测自定义类（因为只要是自定义类返回的都是‘[Object Object]’） 比如自定义一个时间类： 12345678910class TimeClass { constructor (date) { if (!date || typeof (date) === 'string') { date = new Date() } this.date = date }}let a = new TimeClass()console.log(Object.prototype.toString.call(a)) // 输出 \"[object Object]\"","link":"/2019/12/10/data-type-detection/"},{"title":"es6的扩展运算符","text":"es6的扩展运算符 … 你了解多少呢 写在前面之前学习react 过程中，遇到… 知道的不是很清楚，只是知道例如下面这样…arr1 相当于2, 4, 5, 6123let arr1 = [2, 4, 5, 6]let arr2 = [...arr1]arr2 输出为 [2, 4, 5, 6] 程序员一定要一直保持学习的状态，反正我就是秉着这样的心态在前端这个领域一直摸索，以至于我的颈椎、前脑门、曾经一抓一大把的头发。。。你们懂得言归正传，我查了好多资料，现在整理一下我对这个…得认知：人家有个专业名词，叫做es6的扩展运算符，是一种展开语法，有什么用处呢，我们来看看 在MDN上面的介绍比较详细了: 展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。(译者注: 字面量一般指 [1, 2, 3] 或者 {name: “mdn”} 这种简洁的构造方式)可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开 什么意思呢？就想我开篇写的那样 …arr1 就相当于2, 4, 5, 6let arr2 = […arr1] 就相当于let arr2 = [2, 4, 5, 6]，…起到的作用将一个数组转为用逗号分隔的参数序列 具体用处简单总结如下： 合并数组 123456// ES5 的写法let arr1 = [1, 2, 3]let arr2 = [4, 5, 6]Array.prototype.push.apply(arr1, arr2) ==&gt; [1, 2, 3, 4, 5, 6]// ES6 的写法arr1.push(...arr2) 数组最大元素 123456var args = [1, 3, 5];// ES5 的写法Math.max.apply(null, args) ==&gt;5// ES6 的写法Math.max(...args) ==&gt;5// 是不是简单了许多 可以解构赋值结合, 用于生成数组，就是把剩余的东西放到一个array里面赋值给它。一般只针对array的解构 12345678let arr = [1, 2, 3, 4]let first = arr[0]let rest = arr.slice(1) console.log(item) ==&gt;[2, 3, 4]// 使用扩展运算符[first, ...rest] = arrconsole.log(item) ==&gt;[2, 3, 4]* 需要注意的是：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错 在对象的使用 12345678let obj1 = {a: 1,b: 2}let obj2 = {c: 3,...obj1} 扩展运算符还可以将字符串转为数组 1[...&apos;strToArr&apos;] ==&gt; [&apos;s&apos;, &apos;t&apos;, &apos;r&apos;, &apos;T&apos;, &apos;o&apos;, &apos;A&apos;, &apos;r&apos;, &apos;r&apos;] 好多获取dom的方法，例如querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。可以扩展运算符可以将其转为真正的数组 1let domArr =[...document.querySelectorAll(&apos;.list&apos;)] 扩展运算符内部调用的是数据结构的 Iterator 接口(遍历器)，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构 123456let map = new Map([[1, &apos;one&apos;],[2, &apos;two&apos;],[3, &apos;three&apos;],]);let arr = [...map.keys()]; // [1, 2, 3] 今天肩膀有点痛哦，加油吧，小伙伴们 !!! 对了，补充一下，如果在vue项目中用到…报错，需要安装一个插件： npm install –save-dev babel-plugin-transform-object-rest-spread在.babelrc文件中配置： {“plugins”:[“transform-object-rest-spread”]}","link":"/2018/08/22/es6-extendedOperator/"},{"title":"函数的调用","text":"函数的四种调用模式 1. 普通函数执行12this -&gt; window声明一个函数后，就直接调用 2. 方法调用模式12this —&gt; 该方法的调用者通过一个对象来调用方法 3. 构造函数模式12this -&gt; 当前创建出来的对象配合new操作符 来 调用函数 4. call/apply(上下文)模式123456this -&gt; 用户动态指定的指定call or apply 方法的第一个参数区别：.call(thisObj, arg1, arg2, …,argN)：thisObj为 this的指向。之后为形参列表，就是fn在执行时的实参列表.apply(thisObj, [实参]): thisObj 为 this的指向，数组参数为 fn在执行时的实参注意：在非严格模式下，如果thisObj 赋值为 null 或者不传实参，此时this -&gt; window 对象，就相当于 普通函数执行模式。 5. 上下文模式的应用12345678910111213141516171819201. 数组的合并Array.prototype.push.apply(arr1, arr2);2. 借调方法（函数2.1 借用构造函数function parent(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } function child(name, age, gender, address) { parent.call(this, name, age, gender); this.address = address; } 2.2 借用原生方法求数组中的最大值获取内置对象类型将伪数组变成真数组 6. 数组去重实现思路：声明一个函数实现数组去重，取名为unique；判断浏览器是否支持数组的indexOf方法如果不支持，就自己实现数组的indexOf方法，并且将其扩展到数组的原型对象上。遍历数组，首先判断结果数组ret中是否含有当前遍历到的元素，如果没有，就将当前元素添加到ret中。循环结束，将ret返回。 7. 面试题1234567891011121314151617function Foo(){ getName = function(){ alert(1); }; return this;}Foo.getName = function(){ alert(2); };Foo.prototype.getName = function(){ alert(3); };var getName = function(){ alert(4); };function getName(){ alert(5); }Foo.getName(); // ?getName(); // ?Foo().getName(); // ?getName(); // ?new Foo.getName(); // ?new Foo().getName(); // ?new new Foo().getName(); // ?","link":"/2015/10/26/function-call/"},{"title":"vue项目中添加eslint","text":"vue项目中eslint的使用 写在前面之前做项目一直不是很重视eslint的作用，后来随着项目的积累，觉得 eslint 是团队开发必备的工具，它能很好地减少代码错误、节约调试时间、维持团队成员之间代码风格的统一 关于eslinteslint英文文档 https://eslint.org/eslint中文文档 http://eslint.cn/ ESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具。 ESLint v5.0.0-alpha.0 released 2018-03-30 这篇文章This is a summary of the standard JavaScript rules有详细介绍eslint的rules的使用和参数解释 这里也有rules参数以及示例介绍 learn more 安装1npm install eslint 配置详细配置介绍查看官网 configuring 在文件webpack.base.conf.js 的 rules 配置： 12345678910{&lt;!--使用eslint-loader处理vue和js文件--&gt; test: /\\.(js|vue)$/, loader: &apos;eslint-loader&apos;, enforce: &apos;pre&apos;, include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)], options: { formatter: require(&apos;eslint-friendly-formatter&apos;) }} 可以通过以下三种方式配置 ESLint: 在 package.json 中添加 eslintConfig 配置块 直接在代码文件中定义, 代码文件内以注释配置的规则会覆盖配置文件里的规则，即优先级要更高 使用 .eslintrc 文件（支持 JSON 和 YAML 两种语法） package.json文件配置了lint 1&quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot; 可以通过npm run lint 进行eslint的检测 eslint 报错 问题定位：12345678910111213141516171819202122232425262728293031323334353637381. 问题：Parsing error: Unexpected token ...原因：是使用了es6的扩展运算符...报错解决：.eslintrc.js文件设置如下：&quot;ecmaFeatures&quot;: { &quot;experimentalObjectRestSpread&quot;: true }.eslintrc.yml文件设置如下：ecmaFeatures: experimentalObjectRestSpread: true 2. 问题：Missing semicolon 原因：查看semi分号设置，设置了always 丢失分号就会报错解决：根据提示位置，加上分号，如果不想在文末添加分号 就这样设置rules的semi：&quot;semi&quot;: [2, &quot;never&quot;]3. 问题: Expected indentation of 16 spaces but found 原因：都是缩进的问题 解决：查看indent 缩进风格配置&quot;indent&quot;: [2, 4]4. 问题: &lt;template&gt; Unexpected token &lt;原因：The most rules of eslint-plugin-vue require vue-eslint-parser to check &lt;template&gt; ASTs.解决：下载 npm i eslint-plugin-vue 在.eslitrc 设置：&quot;extends&quot;: [&quot;plugin:vue/base&quot;]根据报错提示定位相应问题，配置相应eslint的rule 以下是.eslintrc 文件示例: 默认情况下，ESLint 支持 ECMAScript 5 语法 12345{ &quot;env&quot;: {}, &quot;ecmaFeatures&quot;: {}, &quot;rules&quot;: {}} eslint 配置参数简述env - 指定脚本的运行环境。每种环境都有一组特定的预定义全局变量 常见配置项详情： 参数 描述 “browser”: true 浏览器环境中的全局变量 “node”: true Node.js 全局变量和 Node.js 作用域 “commonjs”: true CommonJS 全局变量和 CommonJS 作用域 (用于 Browserify/WebPack 打包的只在浏览器中运行的代码) 更多 env 配置请查阅这里 Globals - 脚本在执行期间访问的额外的全局变量ecmaVersion - 默认设置为3，5（默认）来指定你想要使用的 ECMAScript 版本sourceType - 设置为 “script” (默认) 或 “module”（如果你的代码是 ECMAScript 模块)ecmaFeatures - 这是个对象，表示你想使用的额外的语言特性 常见配置项详情： 参数 描述 “arrowFunctions”: true lambda表达式 “destructuring”: true 解构赋值 “classes”: true class “defaultParams”: true http://es6.ruanyifeng.com/#docs/function#函数参数的默认值 “blockBindings”: true 块级作用域，允许使用let const “modules”: true 允许使用模块，模块内默认严格模式 “objectLiteralComputedProperties”: true 启用计算对象文字属性名称 “objectLiteralShorthandMethods”: true 允许对象字面量方法名简写 “objectLiteralShorthandProperties”: true, 对象字面量属性名简写 var foo = ‘bar’; var baz = {foo}; baz // {foo: “bar”} // 等同于 var baz = {foo: foo}; “restParams”: true http://es6.ruanyifeng.com/#docs/function#rest参数 “spread”: true http://es6.ruanyifeng.com/#docs/function#扩展运算符 “forOf”: true http://es6.ruanyifeng.com/#docs/iterator#for---of循环 “generators”: true http://es6.ruanyifeng.com/#docs/generator “templateStrings”: true http://es6.ruanyifeng.com/#docs/string#模板字符串 “experimentalObjectRestSpread”: true 对象的扩展运算符… https://github.com/tc39/proposal-object-rest-spread (重要：这是一个实验性的功能,在未来可能会有明显改变。 建议你写的规则 不要 依赖该功能，除非当它发生改变时你愿意承担维护成本。) “superInFunctions”: true 构造函数内必须有super函数 rules - 你可以使用注释或配置文件修改你项目中要使用的规则 常见配置项详情： 参数 描述 no-console: 2 禁止使用console array-bracket-spacing: [2, “never”] 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 quotes: [1, “single”] 引号类型 “” ‘’ brace-style: [2, “1tbs”, { “allowSingleLine”: true }] if while function 后面的{必须与if在同一行，java风格 camelcase: 2 双峰驼命名格式 comma-dangle: [2, “never”] 要求或禁止末尾逗号 comma-spacing”: [2, { “before”: false, “after”: true }] 控制逗号前后的空格 comma-style: [2, “last”] 强制使用一致的逗号风格 computed-property-spacing: [2,”never”] 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always 更多 rules 配置请查阅这里 通过配置.eslintignore文件忽略掉不想被检查的文件其使用的是Glob路径书写方式，与「.gitignore」的使用方法相同 也可以在 package.json 文件中，通过 eslintIgnore 参数进行设置 可以通过在项目目录下建立.eslintignore文件，并在其中配置忽略掉对哪些文件的检查。需要注意的是，不管你有没有在.eslintignore中进行配置，eslint都会默认忽略掉对/node_modules/ 以及 /bower_components/文件的检查 123# Ignore built files except build/index.jsbuild/!build/index.js","link":"/2019/04/15/eslint/"},{"title":"git实用笔记","text":"git实用笔记 写在前面整理一下我记得住和记不住的实用git命令，更多学习了解请查看官网 gitTips整理的也很实用 安装通常，Mac OS 中都已经安装了Git。但是，Git的版本未必是最新的。所以建议你安装使用最新版本的Git。下面来检查一下你的Mac电脑上是否已经安装了Git 如图，如果git命令可以被系统识别，那么就表示你的电脑上已经安装了Git，系统会列出Git的一些使用方法 如果你发现你的系统上没有安装Git，那么你要到Git的网站下载并安装最新版本的Git 实用操作git 的配置 git config 命令用于获取并设置存储库或全局选项。这些变量可以控制 Git 的外观和操作的各个方面。 12# 获取帮助信息git help config 查看全局配置的信息 12345# --local：局部（当前目录）配置信息 （默认值）git config --local --list# --global：全局配置信息git config --global --list 设置自己的用户名和 email，这是非常重要的，因为每次 Git 提交都会使用该信息，它被永远的嵌入到了你的提交中在命令行输入： 1234567891011121314# 全局配置(所有项目)git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot;# 当前目录配置(当前项目)git config user.name &quot;your name&quot;git config user.email &quot;your email&quot;#示例git config --global user.name &quot;xiaoming&quot;git config --global user.email &quot;xiaoming@gmail.com&quot;git config user.name &quot;xiaoming&quot;git config user.email &quot;xiaoming@gmail.com&quot; 添加配置项 1234567891011# entry-name 为配置项名称# 当前目录git config --local –add &lt;entry-name&gt;# 全局环境git config --global –add &lt;entry-name&gt;# 系统git config --system –add &lt;entry-name&gt;# 示例：git config -–add site.name yiibai# * 注意 add 后面的 section 、 key、 value 一项都不能少，否则添加失败 删除配置项 1234567891011# 当前目录git config --local --unset &lt;entry-name&gt;# 全局环境git config --global--unset &lt;entry-name&gt;# 系统环境git config --system --unset &lt;entry-name&gt;# 示例：git config --local -–unset site.name 简化命令 12345# 将冗长的命令简化git config --global alias.&lt;handle&gt; &lt;command&gt;#示例：git status 改成 git st ，这样可以简化输入命令git config --global alias.st status 其他配置项 12345# 不再将文件的权限变化视作改动git config core.fileMode false# 设置大小写敏感git config core.ignorecase false 创建SSH密钥 这个密钥用来跟 github 通信，在本地终端里生成然后上传到 github 123ssh-keygen -t rsa -C &apos;wowohoo@qq.com&apos; # 生成密钥 ssh-keygen -t rsa -C &quot;wowohoo@qq.com&quot; -f ~/.ssh/ww_rsa # 指定生成目录文件名字ssh -T git@github.com # 测试是否成功 多账号ssh配置 1.生成指定名字的密钥 1ssh-keygen -t rsa -C &quot;邮箱地址&quot; -f ~/.ssh/jslite_rsa 会生成 jslite_rsa 和 jslite_rsa.pub 这两个文件 2.密钥复制到托管平台上 1vim ~/.ssh/jslite_rsa.pub 打开公钥文件 jslite_rsa.pub ，并把内容复制至代码托管平台上 3.修改config文件 12# 修改config文件，如果没有创建 configvim ~/.ssh/config 12345678910111213# config 配置Host jslite.github.com HostName github.com User git IdentityFile ~/.ssh/jslite_rsaHost work.github.com HostName github.com # Port 服务器open-ssh端口（默认：22,默认时一般不写此行） # PreferredAuthentications 配置登录时用什么权限认证 # publickey|password publickey|keyboard-interactive等 User git IdentityFile ~/.ssh/work_rsa Host 这里是个别名可以随便命名 HostName 一般是网站如：git@ss.github.com:username/repo.git 填写 github.com User 通常填写git IdentityFile 使用的公钥文件地址 4.测试 123ssh -T git@jslite.github.com # `@`后面跟上定义的Host ssh -T work.github.com # 通过别名测试ssh -i ~/公钥文件地址 Host别名 # 如 ssh -i ~/.ssh/work_rsa work.github.com 5.使用1git clone git@jslite.github.com:&lt;jslite的用户名&gt;/learngit.git 初始化版本仓库 1234567# 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件# 这些文件是 Git 仓库的骨干git init# 或者使用下面的命令，&lt;project-name&gt; 为新建代码库的名称git init &lt;project-name&gt; git 和目录绑定 在一个目录里可以通过 git init 命令把这个目录变成 Git 可以管理的仓库, 然后通过以下命令绑定提交的地址:1git remote add origin https://github.com/gitname.github.io 或者直接 git clone 地址 就会创建目录和地址绑定 列出每个远程库的简短名字 1git remote -v 添加远程仓库 123456# gitName：自定义名字，一般upstream指上游仓库的名字，origin 一般指自己仓库的名字# git@github.com:gitName.git：是你的仓库地址git remote add gitName git@github.com:gitName.git# 下一步，就可以把本地库的所有内容推送到远程库上git push gitName master git 分支修改名字 1git branch -m 原名 新名 本地修改暂时储藏 1234567git stash# 要将暂存的内容导出来，执行 pop 命令git stash pop# 要移除它，你可以运行 drop，加上你希望移除的储藏的名字git stash drop &lt;stashName&gt; git合并多个commit 12# 首先你要先通过log查看一下历史git log 12345# 推荐使用hash操作：# 如果你想合并 64ea73dd457c780 和 1163cb825e1fcb，一定注意下面的命令一定要定位到最后一个要合并的commit之前的一个# 也就是这个最后一个想要合并的 hash 值 1163cb825e1fcb 前面的一个 即：f4f6e1b3be5fc77a23git rebase -i f4f6e1b3be5fc77a23 rebase 命令执行后，会弹出一个界面： pick 是用commit; squash 是合并前一个 注意这时候是vim界面，如果需要修改键盘敲 i (insert) 进行输入 将 pick 修改为 squash 或者 s 然后 按esc 退出vim界面, 输入 :wq 保存退出会再弹出界面，这时候可以修改提交的描述，同样操作vim进行修改，:wq保存退出这时候再 git log 查看一下 证明我们已经合并了最后将我们的rebase修改push到我们的想要提交的库就行了 如果是团队合作：应该有两个远程 一个是 upstream 团队库的远程 一个是 origin 你fork的团队库 在本地提交的分支上 进行完rebase修改之后 在该分支上继续提交：可以 push -f 强制推送到我们的origin 1git push -f （默认是origin） 也可以1git push origin 当前分支名 如果我们团队开发，一定注意使用 -f 这些命令，force它代表强制执行，比较危险的命令，不要push到远程的upstream项目 回退到某一个版本 在 Git 中，用 HEAD 表示当前版本, 上一个版本就是 HEAD^, 上上一个版本就是 HEAD^^, 当然往上 100 个版本写 100 个 ^ 比较容易数不过来，所以写成 HEAD~100。 12345678# 回滚到上一个版本:git reset --hard HEAD^# 回滚到任意一个版本:git reset --hard &lt;hash&gt;# 示例：git reset --hard a3hd73r –hard代表丢弃工作区的修改，让工作区与版本代码一模一样，与之对应，–soft参数代表保留工作区的修改 如果 git 回滚到历史版本后, git log 只能看历史版本再以前的版本号, 不到未来的版本号怎么办? git 提供了一个命令 git reflog 用来记录你的每一次命令 利用 commit 关闭一个 issue 如果主管给我们开了一个任务issue，当我们完成并提交代码的时候 在描述中可以这样写： 123fix: &lt;issue的地址&gt;# 当我们的提交被合并的时候，相应的issue就会被关闭，可谓是相当的高效实用了 放弃工作区的修改 1234git checkout &lt;文件路径&gt;# 放弃所有修改：git checkout . 展示工作区和暂存区的不同 12345# 输出工作区和暂存区的 different (不同):git diff# 还可以展示本地仓库中任意两个 commit 之间的文件变动:git diff commit1 commit1 展示暂存区、工作区和最近版本的不同 12# 输出工作区、暂存区 和本地最近的版本 (commit) 的 different (不同):git diff HEAD 创建并切换到本分支 123456git checkout -b newBranch#相当于：git branch newBranch （新建分支）git checkout newBranch （切换到新分支） 快速切换到上一个分支 1git checkout - 可筛选的删除本地无用分支 12345git branch|grep &lt;需要删除分支名字或名称的一部分&gt;|xargs git branch -d# 例如：branch-25 这个分支已经提交合并了之后 就没有存在的必要了，删除这个分支# 下面这个执行后，就会检索所有名称里面所有包含25的分支 并进行删除git branch|grep 25|xargs git branch -d 回到远程仓库的状态 123# 抛弃本地所有的修改，回到远程仓库的状态:git fetch --allgit reset --hard origin/master 展示本地分支关联远程仓库的情况 1git branch -vv 列出所有远程分支 12# -r 参数相当于：remotegit branch -r 回退到某一个版本 通过 git log 查看历史记录 如果你想回退到 edit readme 复制这个commit的上一个commit的hash值 70aebb3912208 12345# 通过 reset 命令（将当前HEAD重置为指定状态）回退到该版本git reset --hard 70aebb3912208# 然后查看一下历史，已经撤销了之前的 commitgit log 这里介绍一下: git reset [] [] 此形式将当前分支头重置为；且可能根据更新索引（resetting it to the tree of ）和工作树。如果省略，则默认为—mixed。必须为这些选项之一：–mixed、–soft、–hard、–merge、–keep git reset [–hard|soft|mixed|merge|keep] 参数区别： 参数 描述 –mixed 默认(即不带任何参数的git reset),它回退到某个版本，只保留源码，回退commit和index信息 –soft 回退到某个版本,不修改索引文件和工作树 –hard 重置索引和工作树。丢弃自之后工作树中已跟踪文件的任何更改 –merge 重置索引并更新工作树中和HEAD之间不同的文件，但保留索引和工作树之间不同的文件（即没有添加更改的文件）。如果在和索引之间不同的文件有未暂存的修改，reset将会中止(换句话说，–merge 的行为类似于git read-tree -u -m，但是会携带未合并的索引条目) –keep 重置索引条目，并更新工作树中和HEAD之间不同的文件。如果文件有本地修改，reset将会中止 恢复 git reset -hard 的误操作， 可以通过 git reflog 查看hard记录 reflog命令：它会记录所有HEAD的历史，也就是说当你做 reset，checkout 等操作的时候，这些操作会被记录在reflog中 比如我们想恢复到 edit about, 复制这个操作的hash值 e14f255，然后执行以下操作： 123git reset --hard e14f255# `git log` 查看历史，发现我们已经恢复到 `edit about` 了 git log 加上 -g 参数也能看见reflog信息 注意：当通过reset等操作丢失一个提交的时候，可以把它找回来。除非你的操作已经被git当做垃圾处理掉了，一般是30天以后 撤销一个 还未 push 的 commit 通过 git log 查看提交的commit历史 如果我们想撤回hash值为 9a98bc022f8b53a08 的 commit: git reset","link":"/2018/10/27/git/"},{"title":"Git学习笔记","text":"关于git的学习笔记 1. 版本控制1.1 关于版本控制版本控制（Version Control Systems）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。这个系统可以自动帮我们备份文件的每一次更改，并且可以非常方便的恢复到任意的备份（版本）状态。2. Git工作原理2.1 为了更好的学习Git，我们们必须了解Git管理我们文件的3种状态，分别是已提交（committed）、已修改（modified）和已暂存（staged），由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。实现版本控制的软件有很多种类，大致可以分为本地版本控制系统、集中式版本控制系统、分布式版本控制系统。2.2 本地版本控制系统2.2.1 借助软件我们可以记录下文件的每一次修改，如下图所示，文件被修改后，记录下了3个版本，这样我们通过版本控制系统（软件）便可以非常方便的恢复到任意版本。缺点：这种类型的版本控制系统，功能比较单一，比如很难实现多人协同开发，所以现在几乎很少使用了。2.3 集中式版本控制系统2.3.1 实际开发环境，一个项目通常是由多人协作共同完成的，如何让在不同终端上的开发者协同工作成了亟待解决的问题，集中式版本控制系统便应运而生了。它通过单一的集中管理的服务器，保存所有文件的修订版本，协同工作的开发者都通过客户端连到这台服务器，取出最新的文件或者提交更新。其代表为SVN。缺点：这种方式很好解决了多人协同开发的问题，但是也有一个弊端，如果集中管理的服务器出现故障，将会导致数据（版本）丢失的风险，另外协同开发者从集中服务器中更新数据时，严重依赖网络，如果网络不佳，也给开发带来诸多不便。2.4分布式版本控制系统2.4.1 分布式版本控制系统，则不需要中央服务器，每个协同开发者都拥有一个完整的版本库，这么一来，任何协同开发者用的服务器发生故障，事后都可以用其它协同开发者本地仓库恢复。由于版本库在本地计算机，也便不再受网络影响了。如果要将本地的修改，推送给其它协同开发者，还需要一台共享服务器，所有开发者通过这台共享服务器同步和更新数据。分布式版本控制系统弥补了前面两种版本控制系统的缺陷，成为了版本控制的首选方案。其代表就是Git。3. Git3.1 Git工作原理3.1.1 为了更好的学习Git，我们们必须了解Git管理我们文件的3种状态，分别是已提交（committed）、已修改（modified）和已暂存（staged），由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。 Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。 这是Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”（Index），不过一般说法还是叫暂存区域。 3.1.2基本的Git工作流程如下 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交文件，找到暂存区域的文件，将快照永久性存储到Git仓库目录。 3.2 Git本地仓库Git本地仓库指的是开发者开发设备中的仓库。3.2.1 Git基础命令行方式：任意目录（建议开发目录）右键 &gt; Git Bash Here1. 配置用户:配置用户的意义在于记录开发者信息，以便在版本控制记录开发者的操作行为，如lion于2016-08-24解决了一个bug。12345 git config --global user.name &quot;自已的名字&quot;git config --global user.email &quot;自已的邮箱地址&quot;--global 配置当前用户所有仓库--system 配置当前计算机上所有用户的所有仓库注：配置用户只需要执行1次，可以重复使用。 2. 初始化仓库: 我们如果想要利用git进行版本控制，需要将现有项目初始化为一个仓库，或者将一个已有的使用git进行版本控制的仓库克隆到本地。12345a) git initgit init只是创建了一个名为.git的隐藏目录，这个目录就是存储我们历史版本的仓库，ls -al 可以查看。b) git clone 仓库地址假如公司已有项目用了Git，那我们就利用克隆.执行完这个命令，会在当前目录下生成一个Monment目录（默认和仓库名称相同），这个便是已有一个使用Git管理的项目。 3. 查看文件状态:初始化仓库后便可以进行开发了，进入到刚刚创建好并初始为仓库的目录，添加我们开发需要的文件。12345678使用 git status:NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: index.txt 4. 添加文件到暂存区: 放到暂存区的文件被标记成了绿色，等待提交。注：颜色是工具给添加的，目的是增加可读性并不是git统一的。123git add 文件名 “*”或-A代表所有NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git add --all 4.1 如果需要撤销更改4.1.1 再次git status可以再次查看仓库状态123456NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git statusChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: index.txt 说明index.html再次被修改了并被标记了红色。\\ 4.1.2 又经过一段时间后发现新开发的部分有Bug，想要回到之前状态，可以使用git checkout 文件名。从暂存区还原原到工作区:12NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git checkout index.txt 5. 提交文件：经过一个相对较长阶段开发或者一个功能开发完成了，就可以提交到本地仓库了，永久保存了。1234NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git commit -m &apos;编辑了index.txt&apos;[master d52e561] 编辑了index.txt 1 file changed, 1 insertion(+) 这时git status查看状态:1234NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git statusOn branch masternothing to commit, working tree clean 没有什么可提交的，变的很干净。 6. 查看提交历史:反反复复开发了很多的功能了，通过git log查看一下提交的历史12345678910111213NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git logcommit d52e561f4399593a236314c7266ca364c8968eacAuthor: NW &lt;1011269522@qq.com&gt;Date: Fri Oct 28 20:05:45 2016 +0800 编辑了index.txtcommit 7c7a324c760b99a05a51d6003cf41d4a9c1a8f68Author: NW &lt;1011269522@qq.com&gt;Date: Fri Oct 28 17:07:07 2016 +0800 添加了index.txt文件 我们可以查看到一次次提交记录:1commit 7c7a324c760b99a05a51d6003cf41d4a9c1a8f68 代表一次提交的唯一ID，一般称为SHA值。傻？注：按键盘q键退出。 7. 再次检测仓库文件状态:隔了好些天后，继续开发git status 查看状态:这时关掉所有目录甚至关机！ 8. 恢复上一次提交的状态通过SHA值可以回到之前某一次的提交（时光倒流）1234NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git reset --hard 7c7a324c760b99a05a51d6003cf41d4a9c1a8f68HEAD is now at 7c7a324 添加了index.txt文件 这样便回到了添加了index.txt文件功能的状态git log再次查看发现最后一次提交成功能1234567NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git logcommit 7c7a324c760b99a05a51d6003cf41d4a9c1a8f68Author: NW &lt;1011269522@qq.com&gt;Date: Fri Oct 28 17:07:07 2016 +0800 添加了index.txt文件 3.2.2 Git分支 在我们的现实开发中，需求往往是五花八门的，同时开发个需求的情况十分常见，比如当你正在专注开发一个功能时，突然有一个紧急的BUG需要你来修复，这个时候我们当然是希望在能够保存当前任务进度，再去修改这个BUG，等这个BUG修复完成后再继续我们的任务。如何实现呢？ 1. Git创建分支来解决实际开发中类似问题在Git的使用过程中一次提交称为历史记录（版本），并且会生成一个唯一的字符串123commit 7c7a324c760b99a05a51d6003cf41d4a9c1a8f68Author: NW &lt;1011269522@qq.com&gt;Date: Fri Oct 28 17:07:07 2016 +0800 这个串可以代表某一个历史版本（实际使用只取前面几位就可以），值得注意的是所有的提交（commit）实际上都是在分支（branch）的基础上进行的。当我们在初始化仓库的时候（实际上是产生第1次提交时），Git会默认帮我们创建了一个master的分支，并且有指针（HEAD）指到了末端。指针（HEAD）用来标明当前处于哪个分支的哪个版本，如上图指的处于master分支的最后1个版本。2. 我们也可以创建自已的分支2.1 创建分支:新的分支会在当前分支原有历史版本的结点上进行创建，我称其为子分支 , 新建的子分支会继承父分支的所有提交历史。1git branch hotfix 2.2 切换分支 123456NW@NW-PC MINGW64 ~/Desktop/gitStudy (master)$ git checkout hotfixSwitched to branch &apos;hotfix&apos;NW@NW-PC MINGW64 ~/Desktop/gitStudy (hotfix) 原来末端是master 切换分支后变成hotfix HEAD现在又指向了hotfix的末端。 2.3 再次提交操作 这次的提交历史版本就会记录在hotfix这个分支上了，并且HEAD伴随hotfix在移动。 2.4 回到master当我们再次切回到master时 , HEAD指向了master分支的末端，并且我们观察发现我们的文件内容还是原来的“模样”。 这个时候我们就在hotfix这个分支上修复了这个BUG，而我们原来在master分支上的操作并未受到影响。修改Bug后的文件暂存在hotfix分支的暂存区了。这时的master分支并没有包含有hotfix的修复。2.5 继续之前的开发 总结：当我们git checkout branchname时，HEAD会自动指向对应分支的末端，工作目录中的源码也会随之发生改变。 2.6 合并（融合）分支 这时master会有两个父结点了，master便包含了hotfix里的修复了 2.7 删除分支1git branch -d hotfix 这时用来修复BUG创建的hotfix分支已经没有用处了，我们可以将它删除。3. Git帮我们解决了什么问题 版本管理 git add-&gt;git commit =新版本（可以在将来恢复到某版本） 多任务开发 一个分支代表一个任务 分支之间不会影响git branch-&gt;git checkout-&gt;git add-&gt;git commit=&gt;新版本 协同开发 通过共享仓库实现(多人共同开发) Git共享：xxx.git -&gt;git init –bare(创建一个共享(裸)仓库)git push-&gt;xxx.gitgit pull -&gt;xx.git 4. ssh","link":"/2016/06/27/git-init/"},{"title":"Gulp学习笔记","text":"关于Gulp的学习笔记 1. Gulp概述gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用它，不仅可以很愉快的编写代码，而且大大提高我们的工作效率 gulp是基于Nodejs的自动任务运行器 她能自动化地完成javascript、coffee、sass、less、html/image、css 等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。 在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。 流的补充:简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向而gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作。这看起来有点像jQuery的方法，把动作串起来创建构建任务 2. Gulp安装2.1 安装步骤 首先确保你已经正确安装了node环境。然后以全局方式安装gulp：npm install -g gulp 全局安装gulp后，还需要在每个要使用gulp的项目中都单独安装一次。把目录切换到你的项目文件夹中，然后在命令行中执行：npm install gulp 如果想在安装的时候把gulp写进项目package.json文件的依赖中，则可以加上–save-dev：npm install –save-dev gulp这样就完成了gulp的安装，接下来就可以在项目中应用gulp了。 2.2 Gulp使用 本地安装gulp进入项目根目录执行npm install gulp –save-dev（添加–save-dev会在package.json记录依赖关系）。 任务清单在项目根目录中创建gulpfile.js（这是一个配置文件） 定义任务在gulpfile.js定义构建任务，如压缩、合并，Gulp自身并不执行任何任务，是通过调用具体插件来完成的。以编译LESS为例，安装npm install gulp-less，如下图定义任务 123456789//引入gulpvar gulp = require('gulp'),//引入编译less的插件less = require('gulp-less');gulp.task('less',function(){ return gulp.src('./public/less/*.less).pipe(less()).pipe(gulp.dest('./public/css'));}); 执行任务 输入命令 gulp less这样我们的LESS文件便会编译成CSS了。2.3 Gulp工作原理通过不同的插件实现构建任务，Gulp只是按着配置文件调用执行了这些插件。 3. Gulp API3.1 Gulp API简述Gulp是基于NodeJS的，通过require可以引入一个NodeJS的包（模块），其作用类似于浏览器中的script标签引入资源，被引入的包存放在node_modules目录下。引入gulp包（模块）后返回一个对象，习惯赋值给变量gulp，通过该对象提供的方法（API）完成任务的配置。 gulp.task() 定义各种不同的任务，如下图有两个参数123gulp.task('css',function(){ console.log('压缩css');}); //不同任务间存在依赖关系时，可以指定依赖，如下图: gulp.src() 需要构建资源的路径，字符串或数组（可以正则方式书写） 123gulp.task('css',function(){ gulp.src('./css/main.css')}); gulp.pipe() 管道，将需要构建的资源“输送”给插件。 12345678910gulp.task('css',function(){ gulp.src('./css/main.css') .pipe(cssmin()) .pipe(gulp.dest('./css/main.min.css')); // cssmin相当于angular里的过滤器 // pipe相当于angular里的管道符| // gulp是一个总指挥 不参与具体的事物 //通过调用gulp的插件（基于node.js）来实现 // 插件需要通过命令行安装}); gulp.watch() 3.2 常用Gulp插件 gulp-less 编译LESS文件 12//引入gulp-less插件var less = require('gulp-less'); gulp-autoprefixer 添加CSS私有前缀 12345678//引入gulp-autoprefixer插件var autoprefixer = require('gulp-autoprefixer');gulp.task('css', function () { gulp.src('./css/main.css') .pipe(autoprefixer({ // 浏览器往回倒2个版本 browsers:['last 2 versions']}); gulp-cssmin 压缩CSS 123456789//引入gulp-cssmin插件var cssmin = require('gulp-cssmin');gulp.task('css', function () { gulp.src('./css/main.css') // 通过pipe方法将上一次输入转成下一次输入 .pipe(cssmin()) // 通过dest方法存储 .pipe(gulp.dest('./css/main.min.css'));}); gulp-rname重命名 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 gulp-htmlmin 压缩HTML gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if`","link":"/2016/04/26/gulp/"},{"title":"使用Hexo踩过的坑","text":"整理在使用hexo建立个人博客过程中遇到的问题 在node14+版本下hexo部署失败终端输入node -v查看 node版本：v14.2.0 hexo 版本信息： 执行hexo d -g进行部署的时候，终端报错： google一查发现 hexo 貌似不支持node14+，切换成低版本的 node 来使用 Hexo 就可以了，也可以升级 hexo 版本为 hexo@4.2.1+ 因为精力有限，直接降低了node版本，有时间尝试升级 hexo@4.2.1+ 看下 然后重新执行 hexo clean &amp;&amp; hexo deploy 打包命令就好了","link":"/2019/10/16/hexo-node14/"},{"title":"混合App开发介绍","text":"混合App开发介绍 一、混合开发介绍1. App开发的三种方式WEB App（HTML5 APP 框架开发模式）基于Web的系统和应用，其作用是向广大的最终用户发布一组复杂的内容和功能。Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。Native App：该开发针对IOS、Android等不同的手机操作系统要采用不同的原生语言和框架进行开发。三种方式的比较： 介绍 Web App(网页应用) Hybrid App(混合应用) Native App(原生应用) 开发成本 低 中 高 维护更新 简单 简单 复杂 体验 差 中 优 Store/market认可 不认可 认可 认可 安装 不需要 需要 需要 跨平台 优 优 差 企业如何选择App开发方式移动端开发不能确定哪一种是最佳的开发方式，因为不存在最佳的开发方式，每种方式都有天生的优点和局限性，找到最适合本企业需求的一种开发方式是关键。过度依赖Hybrid方案会造成Web前端开发成本快速上升，甚至造成 App整体体验下降，甚至造成功能缺失。不要为了Hybrid而Hybrid，控制好方案中Native与Web的边界。 Html5+介绍简单了解基于HTML5的app开发HTML5中国产业联盟，简称“HTML5+联盟”，是为了更好的推进HTML5的商用、更好的为HTML5开发者服务而由产 业链主流厂商共同组成的一个联盟。联盟致力于整合产业链资源，建立围绕HTML5开发者的生态系统，通过产业链共同为HTMLl5开发者服务。W3C中国是联盟的指导单位。CSDN 和 DCloud 是联盟的秘书处单位。DCloud官网：enter link description hereHBuilder-HTML5 IDE编程是一款web开发工具。它能大幅提升开发效率，对程序员也设计了更人文关怀的UI，它包括最全面的语法库和浏览器兼容性数据。到现在 已经有两年的时间了，到现在大概有几十万的开发者在使用5+Runtime-HTML5强化引擎能力，性能接近原生是一个H5的增强引擎。这是一个可以去调用H5的能力和原生操作系统的产品。MUI-HTML5前端框架轻巧、漂亮、开源是高性能的前端框架，可用开发高性能App，也是目前最接近原生App效果的框架，可以有效解决HTML5原生开发中遇到的部分问题，同 时体积也小流应用-HTML5发行新方式秒装，秒更新是高性能的前端框架，可用开发高性能App，也是目前最接近原生App效果的框架，可以有效解决HTML5原生开发中遇到的部分问题，同时体积也小Html5+开发的优缺点提供了一个自定制的开发IDE，支持良好，甚至不需要安装，解压后就可以用。开发出来的app性能和用户体验很高。丰富API支持，号称40万+Html5+缺点庞大的文档，但并不容易理解，甚至让你不知道如何上手。复杂的打包过程。复杂的MUI框架，并不会让你少写代码，甚至更多。 React Native介绍React Native简介React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。React Native着力于提高多平台开发的开发效率 ——仅需学习一次，编写任何平台。(Learn once, write anywhere)Facebook已经在多项产品中使用了React Native，并且将持续地投入建设React Native。React Native核心实现React Native里面没有webview，这货不是Hybrid app，里面执行JS是用的 JavascriptCore。再说React Native的核心，iOS Native code提供了十来个最基本核心的类（RCTDeviceEventEmitter、RCTRenderingPerf等）、或组件（RCTView、RCTTextField、RCTTextView、RCTModalFullscreenView等），然后由React Native的JS部分，组成二十来个基本组件（Popover、Listview等），交由上层的业务方来使用（THGroupView）。就如他们在宣传时所说，他们实现了一套类似css的子集，用来解决样式问题，相当复杂和强大，靠这个才能将Native的核心组件组成JS层的基本组件再组成业务端的业务组件，应该是采用facebook/css-layout · GitHub的C语言版本实现的（在ppt中我们看到了类似flex-direction: column一类的代码，这个正是css-layout支持的语法）。在React Native中，写JS的工程师解决的是「将基本组件拼装成可用的React组件」的问题，写Native Code的工程师解决的是「提供核心组件，提供足够的扩展性、灵活性和性能」的问题。React Native优点不用Webview，彻底摆脱了Webview让人不爽的交互和性能问题。有较强的扩展性，这是因为Native端提供的是基本控件，JS可以自由组合使用。可以直接使用Native原生的「牛逼」动画。可以通过更新远端JS，直接更新app。 其他开发方法5.1 Jquery Mobile简介Jquery Mobile简介jQuery Mobile 是一个为触控优化的框架，用于创建移动 web 应用程序。jQuery 适用于所有流行的智能手机和平板电脑jQuery Mobile 构建于 jQuery 库之上，这使其更易学习，如果您通晓 jQuery 的话。它使用 HTML5、CSS3、JavaScript 和 AJAX 通过尽可能少的代码来完成对页面的布局。为什么使用Jquery MobilejQuery Mobile 将“写得更少、做得更多”这一理念提升到了新的层次：它会自动为网页设计交互的易用外观，并在所有移动设计上保持一致。您不需要为每种移动设备或 OS 编写一个应用程序：jQuery Mobile 解决了这个问题，因为它只用 HTML、CSS 和 JavaScript，这些技术都是所有移动 web 浏览器的标准。5.2 App Can简介App Can简介AppCan.cn开发平台是基于HTML5技术的跨平台移动应用快速开发一体化解决方案。开发者利用HTML5+CSS3+JavaScript技术可 以快速地开发与本地应用体验相媲美的移动应用。AppCan.cn平台提供了UI快速开发框架、本地功能调用API接口、应用打包系统、IDE集成开发环 境和本地应用调试模拟器，预置数百套界面模板和数十种应用插件，提供多套应用模板。完善的框架接口，人性化的开发环境，丰富的开发资源，强大的服务支持， 使开发者可以快速迈入移动开发领域。App Can特色支持Hybrid混合应用开发模式，集合WebApp和NativeApp两者优势。提供丰富的插件调用功能,插件仓库包含系统类、UI界面类、网络类、多媒体类、第三方扩展类。自定义Native插件扩展机制，以满足开发者的定制需求，也可以提交至插件仓库给大众分享。多窗口机制，始终贯穿应用实现中，实现页面交互的极致体验。推送消息，为开发者提供向指定群组或指定用户推送即时消息的服务，针对不同属性的用户推送差异化信息。统计分析，实时的运营数据统计及分析。也可以实现自定义事件统计，无限扩展分析维度。5.3 Cordova介绍Cordova是什么Cordova提供了一组设备相关的API，通过这组API，移动应用能够以JavaScript访问原生的设备功能，如摄像头、麦克风等。Cordova支持如下移动操作系统：iOS, Android,ubuntu phone os, Blackberry, Windows Phone, Palm WebOS, Bada 和 Symbian。和Phonegap的关系？Cordova是贡献给Apache后的开源项目，是从PhoneGap中抽出的核心代码，目前(PhoneGap和Apache Cordova之间的)唯一区别是下载的包的名字，这会持续一段时间。5.4 Ng-Cordova介绍ngCordova是在Cordova Api基础上封装的一系列开源的AngularJs服务和扩展，让开发者可以方便的在HybridApp开发中调用设备能力，即可以在AngularJs代码中访问设备能力Api。在cordova插件的sucess和error js回调方法中，是无法使用 angularjs的$scope对象和注入的方法的，只能访问全局的方法和变量，这样会导致很多麻烦，必须使用传统的js方法写很多难看的代码。使用 ngCordova应该可以解决这个问题。5.5 ES6简介1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成 为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是ECMAScript 1.0版。 ES6是什么ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。2015年6月，ECMAScript 6正式通过，成为国际标准。Node.js是JavaScript语言的服务器运行环境。它们对ES6的支持度，比浏览器更高。通过它们，可以体验更多ES6的特性。这个标准的牛逼之处就在于会逐步统一前端，因为新增加的module,异步编程，Generator函数这些东西在angular中和node中都有很好的实现了。而他们又是按照ECMAScript5规范写的。ECMAScript6学习网址 enter link description here5.6 Angular简介Angular中文网 enter link description hereAngular官网 enter link description here AngularJS 诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。Angular优点模板功能强大丰富，并且是声明式的，自带了丰富Angular指令是一个比较完善的前端MV*（MVW:Model-View-Whatever）框架，包含模板，数据双向绑定，路由，模块化，服务，过滤器，依赖注入等所有功能自定义Directive，比jQuery插件还灵活，但是需要深入了解Directive的一些特性，简单的封装容易，复杂一点官方没有提供详细的介绍文档，我们可以通过阅读源代码来找到某些我们需要的东西，如：在directive使用 $parse。ng模块化比较大胆的引入了依赖注入，能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助，我们的项目从上线到目前，UI变化很大，在摸索中迭代产品，但是js的代码基本上很少改动。Angular支持单元测试和e2e-testing。Angular应用场景单页面应用程序Angular更适合于CRUD的管理系统开发。也非常适合模块化，分层化，数据绑定hybrid开发神器Angular不适合做内容网站，需要SEO的。(SEO目前也有了prerender解决方案)交互频繁的，如游戏之类交互体验网站。（单页面应用程序）太过于简单的页面。（因为要考虑mvc,注入等，就会笨重5.7 Ionic介绍IONIC 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。 它使用 JavaScript MVVM 框架和 AngularJS 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。Ionic是一个专注于用WEB开发技术，基于HTML5创建类似于手机平台原生应用的一个开发框架。Ionic框架的目的是从 web的角度开发手机应用，基于PhoneGap的编译平台，可以实现编译成各个平台的应用程序。 Ionic框架构成CSS框架 - 提供原生 App 质感的 CSS 样式模拟。 ionic 这部分的实现使用了 ionicons 图标样式库。JavaScript框架 - 提供移动 Web 应用开发框架。ionic 基于 AngularJS 基础框架开发，遵循 AngularJS 的框架约束；此外 ionic 使用 AngularJS UI Router 实现前端路由。命令行/CLI - 命令行工具集用来简化应用的开发、构造和仿真运行。ionic 命令行工具使用了 Cordova，依赖于平台 SDK（Android &amp; iOS）实现将移动 Web 项目打包成原生 App。Ionic框架特点基于Angular语法，简单易学。是一个轻量级框架。性能优越，运行速度快。完美的融合下一代移动框架，支持 Angularjs 的特性， MVC ，代码易维护。提供了漂亮的设计，通过 SASS 构建应用程序，它提供了很多UI组件来帮助开发者开发强大的应用。专注原生，让你看不出混合应用和原生的区别提供了强大的命令行工具。Ionic Tips由于 ionic 使用了 HTML5 和 CSS3 的一些新规范，所以要求 iOS7+ / Android4.1+。在低于这些版本的手机上使用 ionic 开发的应用，有时会发生莫名其妙的问题。使用IONIC制作APP4.1 环境搭建4.1.1 系统环境的搭建AndroidJava jdk（android ADT需要）C++环境（Node需要）Android ADT（打包android应用的时候需要）Node（插件环境需要）Git（从github上下载模板，团队代码管理）IOSXCode（打包ios应用的时候需要）Node（插件环境需要）Git（从github上下载模板，团队代码管理）-4.1.2 项目依赖环境搭建cordova（打包工具）npm install -g cordovaionic（框架）npm install -g ionic4.2 项目搭建4.2.1 创建项目模板Ionic start myApp(的方式)Ionic start myApp blankIonic start myApp tabsIonic start myApp sidemenu4.2.2 模拟器运行androidionic emulate androidiosionic emulate ios4.2.3 打包app添加项目平台android – ionic platform add androidios – ionic platform add ios打包android – ionic build androidios – ionic build ios直接运行在手机ionic run android 流行开发平台介绍Angular 2.0介绍性能的限制AngularJS当初是提供给设计人员用来快速构建HTML表单的一个内部工具。随着时间的推移，各种特性 被加入进去以适应不同场景下的应用开发。然而由于最初的架构限制（比如绑定和模板机制），性能的 提升已经非常困难了。快速变化的WEB在语言方面，ECMAScript6的标准已经完成，这意味着浏览器将很快支持例如模块、类、lambda表达式、generator等新的特性，而这些特性将显著地改变JavaScript的开发体验。在开发模式方面，Web组件也将很快实现。然而现有的框架，包括Angular1.x对WEB组件的支持都不够好。简单易用说实话，Angular1.x太复杂了，学习曲线太陡峭了，这让人望而生畏。Angular团队希望在Angular2中将复杂性 封装地更好一些，让暴露出来的概念和开发接口更简单。移动化想想5年前……现在的计算模式已经发生了显著地变化，到处都是手机和平板。Angular1.x没有针对移动 应用特别优化，并且缺少一些关键的特性，比如：缓存预编译的视图、触控支持等。Angular2新特性移动：新的版本将专注于移动应用的开发。依据是它更容易处理桌面方面的事情，一旦挑战涉及到移动（性能、加载时间），注重这方面会使问题得到解决。模块化：各个模块将从Angular的核心中移除，从而获得更好的性能。这意味着你可以选择你需要的零件。现代化：Angular 2.0将把ES6和“常青”现代浏览器（自动更新到最新版本）作为目标。这意味着开发者可以专注于业务领域相关的代码。","link":"/2016/11/26/hybridApp/"},{"title":"HTTP状态码详解","text":"http 状态码详解 当咱们访问一个网页的时候，浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个信息头（server header）用以响应浏览器的请求，这个信息头就包含 HTTP 状态码 根据MDN中对 HTTP 响应代码的介绍，HTTP 响应状态代码可以分为五类： 信息响应(100–199) 成功响应(200–299) 重定向(300–399) 客户端错误(400–499) 服务器错误 (500–599) 信息响应(100–199) 状态码 描述 100 这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应 101 该代码是响应客户端的 Upgrade (en-US) 标头发送的，表示：服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源 102 WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。[6]这样可以防止客户端超时，并假设请求丢失 103 此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源 成功响应(200–299) 状态码 描述 200 请求成功，请求所希望的响应头或数据体将随此响应返回，成功的含义取决于HTTP方法：GET：资源已被提取并在消息正文中传输；HEAD：实体标头位于消息正文中；POST：描述动作结果的资源在消息体中传输；TRACE：消息正文包含服务器收到的请求消息 201 该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应 202 请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理 203 表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的 204 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息 205 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入 206 服务器已经成功处理了部分 GET 请求 207 代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码 208 在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合 226 服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示 table th:first-of-type { width: 70px; }","link":"/2019/05/20/http-code/"},{"title":"分享一个非常好用的终端工具 — iTerm2","text":"Mac OS 终端利器 iTerm2 写在前面最近同事推荐我一个颜值与实力并存的终端工具 — iTerm2，之前一直用Mas OS 自带的终端，也能满足开发需求，但是看到这个这么炫酷还是忍不住想试一下 What is iTerm2? iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with macOS 10.12 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted. 注意: It works on Macs with macOS 10.12 or newer iTerm2 终极配置之旅1. 检测环境 macOS自带zsh，可以通过 cat /etc/shells 检测是否有 /bin/zsh 2. 修改环境 修改默认的bash为zsh,重启Terminal或者iterm2 chsh -s /bin/zsh 检查修改结果,显示/bin/zsh即成功 echo $SHELL 切换为/bin/bash 通过命令 chsh -s /bin/bash 切换即可 3. 安装配置oh-my-zsh 安装 oh-my-zsh on github 到本地的 ~/.oh-my-zsh 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 人靠衣装，马靠鞍，尤其知道 iTerm2 有很多好看炫酷的 theme agnoster 是比较常用的 zsh 主题之一 (默认主题)，你可以挑选你喜欢的主题 我自己用的是 powerlevel9k 主题 1git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 将主题都下载在 ~/.oh-my-zsh/custom/themes 文件夹下面 定位到 ~/.zshrc 的 ZSH_THEME行，设置 ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot; 关于powerlevel9k 主题 更多配置 4. 记录我的配置之旅 4.1 同时将原bash用的各种alias都移到这里，因为原来的alias是属于bash的，zsh里需要重新alias一下命令在~/.zshrc 任意地方配置 alias，类似这样： 12alias tree=&apos;open -a SourceTree .&apos;alias ws=&apos;/usr/local/bin/webstorm&apos; 4.2 首先我不希望终端前面显示计算机用户名相关名称的显示，可以这样设置隐藏显示1在`~/.zshrc`配置文件中，任意地方配置 `DEFAULT_USER=$USER` 4.3 mac iterm2 安装 powerlevel9k 主题终端出现乱码，是因为没有安装 Meslo 字体，下面开始介绍字体安装1git clone git@github.com:supermarin/powerline-fonts.git 下载完成后打开文件目录，找到/Monaco/Menlo for Powerline.ttf该文件，然后双击 弹出安装字体的对话框，点击安装即可，如图所示： 字体安装了但是并没有配置进iterm2终端，点击终端的设置preferences -&gt; profilers -&gt; 在点击text Tab -&gt; change font 选择 Menlo for Powerline 字体进行设置，如图所示： 4.4 历史命令自动建议填充 zsh-autosuggestionszsh-autosuggestions 它根据命令历史记录在您键入时建议命令 安装教程 我是通过 Homebrew 安装的，如果你没有安装Homebrew 请自行安装，或者选择另外几种 zsh-autosuggestions 安装方法 1brew install zsh-autosuggestions 在~/.zshrc 任意地方配置： 1source /usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh 重启 iTerm2 新窗口，如图所示，它根据命令历史记录在键入时建议命令： 4.5 指令高亮插件 zsh-syntax-highlightingzsh-syntax-highlighting指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮 安装：1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting 在~/.zshrc配置： 1plugins=(git zsh-syntax-highlighting) 重新加载配置 source ~/.zshrc 试试指令高亮功能 4.6 iTerm2 配色方案更多 iTerm2 配色方案 下载 Solarized 配色 进入刚下载的solarized目录下：solarized/iterm2-colors-solarized双击安装 Solarized Dark.itermcolors 和 Solarized Light.itermcolors 但是不建议这样安装，因为现在iTerm2已经内置了这两种配色。直接选择就行: iTerm2 特殊技巧 1. 智能选中 在 iTerm2 中，双击选中，三击选中整行，四击智能选中，选中的同时也进行了复制。即：任何选中状态的字符串都被放到了系统剪切板中。 2. 强大的分屏操作 使用快捷键 cmd+d 实现左右分屏，快捷键 shift+cmd+d 实现上下分屏，效果如图： 分屏情况下，切换 Tab 中的 pane：⌘ + [ 或者 ⌘ + opt + arrow关闭 panel：⌘ + w新建 Tab ：⌘ + tTab 切换：⌘ + arrow 或者 ⌘ + shift + [窗口太多，可以使用 ⌘ + / 快速定位到光标所在位置一屏显示所有窗口：⌘ + opt + e 3. 快速打开profile或者切换到指定tab 快捷键 shift+cmd+o 4. 搜索历史命令 ctrl+r 4. 在 Finder 里如何打开 iTerm2 并定位到当前目录","link":"/2019/05/16/iTerm2/"},{"title":"instanceOf学习笔记","text":"关于instanceOf的学习笔记 instanceof运算规则：如果运算符后面的函数 的prototype属性所引用的对象，出现在 运算符前面的对象 的原型链上的话，就返回true；否则就返回false。 绘制作用域链的规则1》 将整个script标签的全局作用域，定义为0级作用域链。将全局作用域上的数据（变量、函数、对象等等）绘制在该链上。2》由于在词法作用域中，只有函数可以分割作用域。因此，只要遇到函数，就要引申出新的作用域链，级别为当前链的级别 + 1；3》 重复第二步骤，直到没有遇到函数为止。 变量的搜索原则：当访问一个变量时，1》 首先在当前变量所处作用域链上查找，如果找到就直接使用，并停止查找；2》 如果没有找到，就向上一级链（T - 1）上去查找，如果找到就直接使用，并停止查找；3》 如果没有找到，就继续向上一级链查找。直到0级链，如果找到就直接使用，并停止查找；4》 如果没有找到就报错。注意：1》 如果访问的变量不存在，会搜索整个作用域链（不仅性能低，而且抛出异常。）在实际开发，不推崇所有数据都写在全局上。尽量使用局部变量。推荐使用沙箱。如果在开发中，所有js代码都写在全局上，会造成全局变量的污染。2》同级别的链上的变量互不干扰。 在函数执行的时候，会创建一个执行的环境，包括activeObject（活动对象）以及作用域链1&gt; activeObject: 存储的是所有在函数内部定义的变量，以及函数的形参；会将变量名字以及形参名字作为该对象的属性来存储 闭包1》概念：一个函数有权去访问另一个函数的内部数据。2》缺点： 会造成函数内部的数据常驻内存，从而引发内存泄漏的问题。3》解决的问题：解决在函数外部无法访问函数内部的数据。s4》为了防止闭包导致内存泄漏，在使用完闭包后，将其赋值为null即可。5》闭包怎么缓存数据？因为在函数内部有方法（函数）对其有引用，并且又将其返回到外部作用域上的一个变量接收。 垃圾回收机制：GC（Garbage Collection） 引用计数如果一个变量被另一个变量引用，那么该变量的应用计数+1；当这个变量不再引用该变量（该变量被回收掉了）时，此时这个变量的引用计数 - 1；GC会在一定时间间隔去查看每个变量的计数，如果为0， 就将其占用的内存回收。缺点： 循环引用：会造成无法回收变量的内存12a{ val : b} , b{val:ａ} b = null;(a = null) ２. 标记清除从当前文档根部（window对象）找一条路径，如果能到达该变量，那么说明此变量不应该 被回收掉反之，应该被回收其所占用的内存。–如果变量进入某个执行环境，那么给其标记为 “进入环境”；–如果上述执行环境执行完成，被销毁，那么该环境内的所有变量都被标记为“已出环境”–如果变量被标记为已出环境，就会被回收掉其占用的内存空间。 闭包的应用 计数器 对象的私有属性 解决fib数列递归性能 沙箱模式： 好处： 不会污染全局变量（或者其他作用域的变量），并且能保证自己的代码安全执行。特性：a: 能分割作用域，不会污染全局 fnb: 在分割后的作用域内部的代码要能自执行。fn()结构：1234(function (){//代码块window.fn = fn;}());","link":"/2015/10/10/instanceOf/"},{"title":"面试题总结","text":"自己面试题总结 1.一个宽度为120px的div里面有三个40px的div,这时候给三个div加上border 1px的话，会发生什么，如何解决？答：加上border 1px的话，最后一个会掉下来，给父盒子设置display:flex; 给每个子盒子div设置flex为1；当给父盒子设置display:flex;时 就已经不会掉下来了。2.两个img标签中间有间隙如何解决？答：使用display: inherit;发生场景：两个img设置父盒子的一半宽，两个img不会显示在一行上，原因就是两个img中间有间隙，导致一行放不下。3.vertical-align的属性有哪些？答：该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐；允许指定负长度值和百分比值； baseline 元素放在父元素的基线上 默认值 sub 垂直对齐文本的下标 … super 垂直对齐文本的上标 … top 把元素的顶端与行中最高元素的顶端对齐 … text-top 把元素的顶端与父元素字体的顶端对齐 … middle 把此元素放置在父元素的中部 … bottom 把元素的顶端与行中最低的元素的顶端对齐 … text-bottom 把元素的底端与元素字体的底端对齐 … length … … % 使用继承的“line-height”属性的百分比来排列此元素 允许负值 inherit 规定应该从父元素继承vertical-align属性的值 任何版本的IE都不支持inherit属性 应用场景：123//单选或者多选框&lt;input type=&quot;checkbox&quot; class=&quot;checkbox&quot;&gt; 你好//单选框或者复选框与文字不对齐，可以通过设置vertical-align:-2px;来保持选框和文字对齐。 4.什么是基线，基线定义的标准是什么？没找到特别好的答案5.6.display: inline-block;和display: block都可以设置宽高吗?太那什么了，当然都可以，行元素直接设置宽高会无效,这时给行元素设置inline-block或者block就可以设置宽高了7.设置元素垂直居中对齐123456789101112131415161718192021222324252627&lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;./img.ipg&quot;&gt;&lt;/div&gt;//如果box的子元素是img的话，通过给box设置以下样式可以让img垂直居中对齐//display: table-cell;vertical-align:middle;text-align:center;//这里的vertical-align要在table-cell下才会生效&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/div&gt;//如果里面是div，给box设置上面的样式，是不会让他水平居中的，要这样设置.box { display: table-cell; vertical-align: middle;}.box1 { //width: height:设置 为了容易看见可以设置background margin: 0 auto;}//通过定位让元素垂直居中(无论子元素是什么都可以)父元素{position: relative}子元素{ position:absolute; top: 50%; left: 50%; margin-top: －子元素高的一半; margin-left: -子元素宽的一半;} 18. &lt;input type=&quot;button&quot;&gt;和&lt;button&lt;/button&gt;有什么区别？ 1&gt; 在button标签内可以放置文本和图像，以图像为背景的按钮但是在input中添加img无法实现2&gt; 如果在 HTML 表单中使用 button 元素，不同的浏览器会提交不同的值。IE将提交 button标签之间的文本，而其他浏览器将提交 value 属性的内容。所以在 HTML 表单中使用 input 元素来创建按钮。3&gt; 如果是button标签的话，通过.val()获取的是标签之前的文本，而不是value的值例如：12345&lt;button class=&quot;button&quot; value=&quot;test&quot;&gt;按钮&lt;/button&gt;&lt;script&gt; $(&apos;.button&apos;).val() // 在IE上获取的是“按钮”，而不是“test”&lt;/script&gt; 9.数组的方法，那些会改变原数组，那些不改变，字符串的呢？数组的方法总结： arr方法： 描述 是否改变原数组 join() 根据字符将数组元素拼接成字符串 不改变原数组 push()和pop() 从数组的前面添加和删除元素（push返回新的长度,pop返回数组的最后一个元素） 改变 shift()和unshift() 从数组的后天删除和添加元素（shift返回最后一个元素，unshift返回数组的新长度） 改变 sort(sortby) 数组排序（参数sortby是个函数，规定排序顺序） 改变原数组 concat() 连接两个数组或者更多的数组并返回结果 不改变原数组 reverse() 颠倒数组中元素的顺序 改变原数组 indexOf(m,n)和lastIndexOf() 查询数组中是否存在m,n是查找的起点位置,astIndexOf()从后开始查找 … forEach() 对数组进行遍历循环 splice 可以实现删除、插入和替换 改变数组，该返回数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组 slice(start,end) 截取一段数据含start,不含end 不改变原数组 12345678var arr = new Array(6)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;arr[3] = &quot;James&quot;arr[4] = &quot;Adrew&quot;arr[5] = &quot;Martin&quot;document.write(arr.sort()) 123456710. for(var i = 0; i &lt; 5; i++){ setTimeout(function(){ console.log(i); },0); }打印5个5因为setTimeout是异步定时函数，就算定时为0，也要等到循环执行结束之后太执行定时操作 11.( function(){…} )()和( function (){…} () )这两种立即执行函数的写法有什么不同？(function(){})(); 是 把函数当作表达式解析，然后执行解析后的函数相当于 var a = function(){}; a(); a得到的是函数(function(){}()); 是把函数表达式和执行当作语句直接执行、相当于 var a = function(){}(); a得到的是结果 会不断总结。。。","link":"/2016/08/20/interview-summary/"},{"title":"JavaScript 异步操作","text":"Async/await的使用 Javascript语言的执行环境是”单线程”在之前的学习中，了解到：Javascript语言的执行环境是”单线程”（single thread）。 就是说：浏览器只分配给js一个主线程用来执行任务即函数，但是每次只能执行一个任务，只有等到当前任务执行完成后，才执行后面的任务，这些任务形成一个任务队列排队等候执行。 其实，JS中是没有线程概念的，所谓的单线程也只是相对于多线程而言。 JS的设计初衷就没有考虑这些，针对JS这种不具备并行任务处理的特性，我们称之为“单线程”。 正如以下代码，先输出1，在输出2，中间执行间隔了1s： 1234567891011function foo() { console.log('first'); setTimeout(( function(){ console.log('second'); }), 1000);} for (var i = 0; i &lt; 10; i++) { foo();}// expected output: 10个 first 输出完后才会输出10个 second 虽然JS运行在浏览器中，是单线程的，但浏览器不是单线程的，javascript引擎线程是浏览器多个线程中的一个；所以当多个事件触发时，会依次放入队列，然后一个一个响应。 所以上面的代码先执行for循环，foo()调用先输出10个 first，而当前有for循环的任务，所以把 setTimeout 的任务加入队列，所以只能等10个first输出完后才会输出 10 个 second 这种模式的好处是实现起来简单，执行环境相对单纯；坏处是如果前面任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。 常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。 为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 JavaScript的异步的实现 回调函数 同步就不用说了，异步的实现值得一提，回调就是异步编程最基本的方法： 123456789function f1(callback){ setTimeout(function () { callback(); }, 1000);}function f2 () {}f1(f2); 采用这种方式，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。 优点：简单、容易理解和部署缺点：不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。 事件监听 js异步操作另一种实现就是事件驱动模式，浏览器异步处理就是典型的事件驱动，事件机制实际上就是异步过程的通知机制 最基础的异步。事件触发才调用函数，而不是根据代码出现的顺序。 代码运行到指定事件，会把函数加入队列中，事件被触发就会调用函数，比如settimeout，onload。 123window.onload = function(){ alert('hello!')} 常用于DOM事件，比如点击鼠标、点击键盘等事件。 1234var button = document.getElementById('#btn');button.addEventListener('click', function() { console.log();}); jquery中的dom监听操作： 1$('#btn').on('click', function () {}) 优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以 “ 去耦合 “，有利于实现模块化缺点：只能进行简单交互，串联异步调用麻烦！需要追踪事件对象，需要确保事件触发前绑定完毕。 发布订阅 上面的事件模式，我们可以理解成是一个”信号” 如果我们假定存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号；其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。 这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。 jQuery中的观察者模式，实际上是让on方法绑定的自定义事件先不执行，直到使用trigger方法来触发事件。 123456$.getJSON('data.json', function(results) { $(document).trigger('app.myevent', results); //相当于发布});$(document).on('app.myevent', function(e, results) { //相当于订阅 console.log(results);}); 以上所示，on方法就像一个订阅者，它订阅了自定义事件app.myevent；而trigger方法就像一个发布者，它发布事件和参数后，才真正让订阅者方法得以执行。 使用jQuery的观察者模式的好处是：一次发布，多次订阅 发布订阅的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。 优点：发布订阅模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。 缺点：发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，不易跟踪 bug Promise Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。 MDN中对Promises的详解 简单理解：每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数 一个 Promise 有以下几种状态: pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 基本用法： 1new Promise( function(resolve, reject) {...} /* executor */ ); executor 是带有 resolve 和 reject 两个参数的函数 。 Promise 构造函数执行时立即调用 executor 函数， resolve 和 reject 两个函数作为参数传递给 executor（ executor 函数在Promise构造函数返回所建promise实例对象前被调用）。 resolve 和 reject 函数被调用时，分别将promise的状态改为 fulfilled（完成）或 rejected（失败）。 executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用 resolve 函数来将promise状态改成 fulfilled，要么调用 reject 函数将 promise 的状态改为 rejected。 如果在 executor 函数中抛出一个错误，那么该 promise 状态为 rejected。executor函数的返回值被忽略。 Promise也有一些缺点: 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。 其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 async与await ES2017 提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话，async函数就是Generator函数的语法糖。 12345678910111213async function timeout(ms) { await new Promise((resolve) =&gt; { setTimeout(resolve, ms); });}async function asyncPrint(value, ms) { await timeout(ms); console.log(value);}asyncPrint('hello world', 50);// expected output: 50ms后输出 'hello world' 根据上面代码所示，可以说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖 参考推荐深入理解参考 阮一峰的async 函数讲解 有对executor相对详细解释","link":"/2019/09/13/js-asynchronous/"},{"title":"js数组相关方法","text":"js数组相关方法 写在前面一直都对数组的好多方法了解的不是很清晰，就想总结起来，方便查阅和记忆 forEach定义：forEach() 方法对数组的每个元素执行一次提供的函数。 语法：1arr.forEach(callback[, thisArg]) 参数： callback 为数组中每个元素执行的函数，该函数接收三个参数： currentValue 数组中正在处理的当前元素。 index (可选) 数组中正在处理的当前元素的索引。 array (可选) forEach() 方法正在操作的数组。 thisArg (可选) 当执行回调函数时用作 this 的值(参考对象)。 如果使用箭头函数表达式来传入函数参数，thisArg 参数会被忽略，因为箭头函数在词法上绑定了 this 值 返回值: undefined 注意： 传递给 callback 的值是 forEach 遍历到他们那一刻的值，那些已删除或者未初始化的项将被跳过 如果给 forEach() 传递了 thisArg 参数，当调用时，它将被传给 callback 函数，作为它的 this 值。否则，将会传入 undefined 作为它的 this 值。callback 函数最终可观察到 this 值，这取决于函数观察到 this 的常用规则。 并且不可链式调用 没有办法中止或者跳出 forEach() 循环，除了抛出一个异常。如果你需要这样，使用 forEach() 方法是错误的。 示例：12345var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];array1.forEach(function(element) { console.log(element);}); slice定义：slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 语法：1arr.slice([begin[, end]]) 参数： begin （可选）提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin，则 slice 从索引 0 开始。如果 begin 大于原数组的长度，则会返回空数组。 end （可选）提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（ 包含 begin，但不包含 end ）。 Map定义：map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果 语法：1234&lt;!--callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身--&gt;var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) 参数： callback 生成新数组元素的函数，使用三个参数：currentValuecallback 数组中正在处理的当前元素。index可选callback 数组中正在处理的当前元素的索引。array可选callback map 方法被调用的数组。 thisArg (可选) 执行 callback 函数时使用的this 值。如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 返回值: 一个新数组，每个元素都是回调函数的结果 注意： map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组） 123&lt;!--求数组中每个元素的平方根--&gt;var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt); 示例： 123456&lt;!--下面的例子演示如何在一个 String 上使用 map 方法获取字符串中每个字符所对应的 ASCII 码组成的数组：--&gt;var map = Array.prototype.mapvar a = map.call(&quot;Hello World&quot;, function(x) { return x.charCodeAt(0); })&lt;!--a的值为[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]--&gt; filter定义：filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 语法：1var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) 参数： callback 用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。它接受一下三个参数： element 数组中当前正在处理的元素。 index可选 正在处理的元素在数组中的索引。 array可选 调用了 filter 的数组本身。 thisArg（可选），执行 callback 时，用于 this 的值。 返回值: 一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。 注意： filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined filter 不会改变原数组，它返回过滤后的新数组 示例：12345678910111213141516171819202122&lt;!--该数组的元素由原数组中值大于 10 的元素组成--&gt;function isBigEnough(element) { return element &gt;= 10;}var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44]&lt;!--使用 filter() 根据搜索条件来过滤数组内容--&gt;var fruits = [&apos;apple&apos;, &apos;banana&apos;, &apos;grapes&apos;, &apos;mango&apos;, &apos;orange&apos;];/** * Array filters items based on search criteria (query) */function filterItems(query) { return fruits.filter(function(el) { return el.toLowerCase().indexOf(query.toLowerCase()) &gt; -1; })}console.log(filterItems(&apos;ap&apos;)); // [&apos;apple&apos;, &apos;grapes&apos;]console.log(filterItems(&apos;an&apos;)); // [&apos;banana&apos;, &apos;mango&apos;, &apos;orange&apos;] find定义：find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 语法：1arr.find(callback[, thisArg]) 参数： callback，在数组每一项上执行的函数，接收 3 个参数： element，当前遍历到的元素。 index可选，当前遍历到的索引。 array可选，数组本身。 thisArg可选，执行回调时用作this 的对象。 返回值: 数组中第一个满足所提供测试函数的元素的值，否则返回 undefined。 注意： 如果数组中一个尚未被callback函数访问到的元素的值被callback函数所改变，那么当callback函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素仍旧会被访问到 当在回调中删除数组中的一个值时，当访问到这个位置时，其传入的值时 undefined find方法不会改变数组。 示例：12345678910111213&lt;!--用对象的属性查找数组里的对象--&gt;var inventory = [ {name: &apos;apples&apos;, quantity: 2}, {name: &apos;bananas&apos;, quantity: 0}, {name: &apos;cherries&apos;, quantity: 5}];function findCherries(fruit) { return fruit.name === &apos;cherries&apos;;}console.log(inventory.find(findCherries)); // { name: &apos;cherries&apos;, quantity: 5 } every定义：every() 方法测试数组的所有元素是否都通过了指定函数的测试。 语法：1arr.every(callback[, thisArg]) 参数： callback 用来测试每个元素的函数。 thisArg 执行 callback 时使用的 this 值。 返回值: every 和数学中的”所有”类似，当所有的元素都符合条件才返回true。另外，空数组也是返回true。(空数组中所有元素都符合给定的条件，注：因为空数组没有元素)。 注意： 如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值 every 不会改变原数组。 示例：12345678&lt;!--检测数组中的所有元素是否都大于 10--&gt;function isBigEnough(element, index, array) { return (element &gt;= 10);}var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true 兼容性: 12345678910111213141516171819202122232425&lt;!--你可以把下面的代码放到脚本的开头来解决此问题，该代码允许在那些没有原生支持 every 的实现环境中使用它--&gt;if (!Array.prototype.every){ Array.prototype.every = function(fun /*, thisArg */) { &apos;use strict&apos;; if (this === void 0 || this === null) throw new TypeError(); var t = Object(this); var len = t.length &gt;&gt;&gt; 0; if (typeof fun !== &apos;function&apos;) throw new TypeError(); var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0; for (var i = 0; i &lt; len; i++) { if (i in t &amp;&amp; !fun.call(thisArg, t[i], i, t)) return false; } return true; };} fill定义：fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引 语法：1arr.fill(value[, start[, end]]) 参数： value，用来填充数组元素的值。 start 可选，起始索引，默认值为0。 end 可选，终止索引，默认值为 this.length。 返回值: 修改后的数组。 注意： 如果 start 是个负数, 则开始索引会被自动计算成为 length+start，如果 end 是个负数, 则结束索引会被自动计算成为 length+end fill 方法故意被设计成通用方法, 该方法不要求 this 是数组对象 当一个对象被传递给 fill方法的时候, 填充数组的是这个对象的引用 示例：1234567891011121314[1, 2, 3].fill(4); // [4, 4, 4][1, 2, 3].fill(4, 1); // [1, 4, 4][1, 2, 3].fill(4, 1, 2); // [1, 4, 3][1, 2, 3].fill(4, 1, 1); // [1, 2, 3][1, 2, 3].fill(4, 3, 3); // [1, 2, 3][1, 2, 3].fill(4, -3, -2); // [4, 2, 3][1, 2, 3].fill(4, NaN, NaN); // [1, 2, 3][1, 2, 3].fill(4, 3, 5); // [1, 2, 3]Array(3).fill(4); // [4, 4, 4][].fill.call({ length: 3 }, 4); // {0: 4, 1: 4, 2: 4, length: 3}// Objects by reference.var arr = Array(3).fill({}) // [{}, {}, {}];arr[0].hi = &quot;hi&quot;; // [{ hi: &quot;hi&quot; }, { hi: &quot;hi&quot; }, { hi: &quot;hi&quot; }] includes定义：includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 语法：1arr.includes(valueToFind[, fromIndex]) 参数： valueToFind，需要查找的元素值。 fromIndex 可选，从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。 返回值: 返回一个布尔值 Boolean ，如果在数组中找到了（如果传入了 fromIndex ，表示在 fromIndex 指定的索引范围中找到了）则返回 true 。 注意： 使用 includes()比较字符串和字符时是区分大小写 fromIndex 大于等于数组的长度，则会返回 false，且该数组不会被搜索 如果 fromIndex 为负值，计算出的索引将作为开始搜索searchElement的位置, 如果计算出的索引小于 0，则整个数组都会被搜索 示例：1234567891011[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN); // true&lt;!--includes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。下面的例子展示了 在函数的 arguments 对象上调用的 includes() 方法。--&gt;(function() { console.log([].includes.call(arguments, &apos;a&apos;)); // true console.log([].includes.call(arguments, &apos;d&apos;)); // false})(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); reduce定义：reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值 语法：1arr.reduce(callback[, initialValue]) 参数： callback, 执行数组中每个值的函数，包含四个参数： accumulator，累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（见于下方）。 currentValue，数组中正在处理的元素。 currentIndex可选，数组中正在处理的当前元素的索引。 如果提供了initialValue，则起始索引号为0，否则为1。 array可选，调用reduce()的数组 initialValue 可选, 作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。 返回值: 函数累计处理的结果 注意： 如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。 如果数组为空且没有提供initialValue，会抛出TypeError 示例：123[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array){ return accumulator + currentValue;}); callback 被调用四次，每次调用的参数和返回值如下表： callback accumulator currentValue currentIndex array return value first call 0 1 1 [0, 1, 2, 3, 4] 1 second call 1 2 2 [0, 1, 2, 3, 4] 3 third call 3 3 3 [0, 1, 2, 3, 4] 6 fourth call 6 4 4 [0, 1, 2, 3, 4] 10 常见使用：123456&lt;!--数组求和--&gt;function arrSum (arr) { return arr.reduce((pre, curr) =&gt; { return pre + curr }, 0)}","link":"/2018/04/09/js-array-methods/"},{"title":"js内存泄漏识别和优化方法","text":"js内存泄漏识别和优化方法 内存泄漏的识别 经验之谈：如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。 浏览器: Chrome 浏览器查看内存占用，按照以下步骤操作: 打开开发者工具，选择 Performance 面板 (以前叫做Timeline) 在顶部的Capture字段里面勾选 Memory 点击左上角的录制按钮。 在页面上进行各种操作，模拟用户的使用情况。 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。如图所示： 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏，反之，就是内存泄漏了。 了解更多，请查看这里 内存泄漏的优化方法 避免循环引用，这个我已经在js内存管理文章中介绍到 优化内存的一个最好的衡量方式就是只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 null，这个方法被称为“解除引用”。需要注意的是，解除一个值的引用不代表垃圾回收器会立即将这段内存回收，这样做的目的是让垃圾回收器在下一个回收周期到来时知道这段内存需要回收 无意的全局变量 1234567function foo(arg) { const bar = &quot;&quot;; &lt;!--或者--&gt; bar = &quot;&quot; &lt;!--没有声明变量，会被当做全局变量处理--&gt;}foo(); 上面的代码就无意中声明了一个全局变量，会得到 window 的引用，bar 实际上是 window.bar，它的作用域在 window 上，所以 foo 函数执行结束后，bar 也不会被内存收回 另外一种无意的全局变量的情况是： 1234567function foo() { &lt;!--在 foo 函数中，this 指的是 window--&gt; this.bar = &quot;&quot;; &lt;!--&quot;use strict&quot;; --&gt; &lt;!--this.bar2 = &quot;严格模式下this指向undefined&quot;; --&gt; &lt;!--bar = &quot;报错&quot;;--&gt;} 不管有意还是无意的设置了全局变量，我们都需要注意，如果声明的全局变量占用大量的内存，那么在使用完后将变量声明为 null 被遗忘的计时器和回调函数 1234567let someResource = getData();setInterval(() =&gt; { const node = document.getElementById(&apos;Node&apos;); if(node) { node.innerHTML = JSON.stringify(someResource)); }}, 1000); 上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。但在 setInterval 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。那什么才叫结束呢？就是调用了 clearInterval。如果回调函数内没有做什么事情，并且也没有被 clear 掉的话，就会造成内存泄漏。不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。上面的例子中，someResource 就没法被回收。同样的，setTiemout 也会有同样的问题。所以，当不需要 interval 或者 timeout 时，最好调用 clearInterval 或者 clearTimeout 在 IE8 以下的版本里，DOM 对象经常会跟 JavaScript 之间产生循环引用 1234function setHandler() { const ele = document.getElementById(&apos;id&apos;); ele.onclick = function() {};} 在这个例子中，DOM 对象通过 onclick 引用了一个函数，然而这个函数通过外部的词法环境引用了这个 DOM 对象，形成了循环引用。不过现在不必担心，因为所有现代浏览器都采用了标记－整理方法，避免了循环引用的问题 除了这种情况，我们现在还会在其他时候在使用 DOM 时出现内存泄漏的问题。当我们需要多次访问同一个 DOM 元素时，一个好的做法是将 DOM 元素用一个变量存储在内存中，因为访问 DOM 的效率一般比较低，应该避免频繁地反问 DOM 元素。所以我们会这样写： 1const button = document.getElementById(&apos;button&apos;); 当删除这个按钮时： 1document.body.removeChild(document.getElementById(&apos;button&apos;)); 虽然这样看起来删除了这个 DOM 元素，但这个 DOM 元素仍然被 button 这个变量引用，所以在内存上，这个 DOM 元素是没法被回收的。所以在使用结束后，还需要将 button 设成 null。 另外一个值得注意的是，代码中保存了一个列表 ul 的某一项 li 的引用，将来决定删除整个列表时，我们自觉上会认为内存仅仅会保留那个特定的 li，而将其他列表项都删除。但事实并非如此，因为 li 是 ul 的子元素，子元素与父元素是引用关系，所以如果代码保存 li 的引用，那么整个 ul 将会继续呆在内存里。 减少内存垃圾的另一个方法就是避免创建对象 new Object() 是一个比较明显的创建对象的方式，另外 const arr = [];、const obj = {};也会创建新的对象。另外下面这种写法在每次调用函数时都会创建一个新的对象：123function func() { return function() {};} 另外，当清空一个数组时，我们通常的做法是 array = []，但这种做法的背后是新建了一个新的数组然后将原来的数组当作内存垃圾。建议的做法是 array.length = 0，这样做不仅可以重用原来的变量，而且还避免创建了新的数组. 闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏 1234567function bindEvent() { var obj = document.createElement(&quot;XXX&quot;); var unused = function () { console.log(obj,&apos;闭包内引用obj obj不会被释放&apos;); }; // obj = null; } 解决方法：手动解除引用，obj = null。 console保存大量数据在内存中 过多的console，比如定时器的console会导致浏览器卡死。 解决：合理利用console，线上项目尽量少的使用console 自动类型装箱转换12var s = &quot;test test&quot;;alert(s.length); s 本身是一个 string 而非 object，它没有 length 属性，所以当访问 length 时，JS 引擎会自动创建一个临时 String 对象封装 s，而这个对象一定会泄漏。这个 bug 匪夷所思，所幸解决起来相当容易，记得所有值类型做.运算之前先显示转换一下：12var s = &quot;test test&quot;;alert(new String(s).length);","link":"/2019/04/09/js-mem-optimization/"},{"title":"js深浅拷贝原理以及方法","text":"js深浅拷贝相关 说到js深浅拷贝的问题就需要说到到js的数据类型，js的数据类型主要分为 基本数据类型 和 引用数据类型： 基本数据类型：Number\\String\\Boolean\\null\\undefined\\Symbol\\bigInt 引用类型：Object（Array\\Function） 在JavaScript中，每一个变量在内存中都需要一个空间来存储，其中的基本数据类型存放在栈内存，复杂数据类型（也就是引用类型）则存放在堆内存中，堆内存用于存放由 new 创建的对象，栈内存存放一些基本类型的变量和对象的引用变量 由于引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值，这样拷贝的时候，就出现两种情况：拷贝地址 和 拷贝值，也就是JS 中的常见的浅深拷贝问题， 浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象 数组深拷贝实现：一、slice 方法 将原数组中抽离部分出来形成一个新数组。我们只要设置为抽离全部，即可完成数组的深拷贝1234567891011var arr = [1,2,3,4,5]var arr2 = arr.slice(0)arr[2] = 5console.log(arr) // 输出 [1, 2, 5, 4, 5]console.log(arr2) // 输出 [1, 2, 3, 4, 5]// 拷贝成功，但是如果数组里面嵌套对象，这种方式就不能完成嵌套对象的深拷贝了var b = [{name: 'zhangsan', age: 18}]var b1 = b.slice(0)b1[0].name = 'lisi'console.log(b) // 输出 [{name: 'lisi', age: 18}] 二、concat 方法 它是用于连接多个数组组成一个新的数组的方法。那么，我们只要连接它自己，即可完成数组的深拷贝12345var arr = [1,2,3,4,5]var arr2 = arr.concat()arr[2] = 5console.log(arr) // 输出 [1, 2, 5, 4, 5]console.log(arr2) // 输出 [1, 2, 3, 4, 5] 三、扩展运算符(…) 12345var arr = [1,2,3,4,5]var [ ...arr2 ] = arrarr[2] = 5console.log(arr)console.log(arr2) concat 以及 扩展运算符这两种方法同样，如果数组里面嵌套对象，就不能完成嵌套对象的深拷贝了，可以利用递归遍历赋值的形式完成深层复杂数据深拷贝，介绍对象深拷贝的时候会讲到 对象深拷贝实现：一、最简单版本 1JSON.parse(JSON.stringify()); 这种写法非常简单，但是它还是有以下缺陷： 被拷贝的对象中某个属性的值为undefined，拷贝之后该属性会丢失 123456789var a = { name: 'zhangsan', age: undefined }var a1 = JSON.parse(JSON.stringify(a))console.log(a1) // { name: 'zhangsan' }// 能看到数值为undefined的属性，拷贝后 直接 丢失了// 如果数组中的对象值为undefined，拷贝也同样发生丢失问题var b = [{ name: undefined }]var b1 = JSON.parse(JSON.stringify(b))console.log(b1) // 输出：[{}] 如果拷贝的对象属性值有function的话，拷贝之后该属性会丢失 1234var a = { name: function () {}}var a1 = JSON.parse(JSON.stringify(a))console.log(a1) // 输出：{}// 可以输出看到没有拷贝到name属性 如果被拷贝的对象中有正则表达式，则拷贝之后的对象正则表达式会变成Object 123var a = {name: /bbb/}var a1 = JSON.parse(JSON.stringify(a))console.log(a1) // 输出：{name: {}} 二、Object.assign Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target） 1234567891011var a = { name: 'nihao', age: 18 }var a1 = Object.assign(a)a1.age = 26console.log(a.age) // 输出 18// 通过输出可以看到深拷贝成功，修改a1的age 并没有影响a的age值// 但是当对象里面还有对象嵌套的时候，就没法完成深拷贝了var b = { name: 'nihao', age: 18, friend: { name: 'lisi', age: 18 } }var b1 = Object.assign(b)b1.friend.age = 26console.log(b.friend.age) // 输出 26// 可以看到Object.assign只支持一层的深拷贝 三、扩展运算符(…) 123456789let obj = { a: { a1: 'a1' }, b: 'b'}let ass = {...obj}ass.a.a1 = 'aaa'ass.b = 'bbb' 扩展运算符(…) 和 Object.assign 一样也只能进行一层的深拷贝，里面嵌套的对象只能浅拷贝 四、递归遍历赋值 如果对象里面的属性没有复杂数据类型的时候，直接遍历赋值就可以了1234567function clone () { let cloneItem = {} for (let k in target) { cloneItem[k] = target[k] } return cloneItem} 但是考虑到我们要拷贝的对象是不知道有多少层深度的，所以我们可以想到可以利用递归来解决： 12345678910111213141516171819202122232425function clone (target) { if (typeof target === 'object') { let cloneItem = Array.isArray(target) ? [] : {} // 考虑到数组或者对象 for (let key in target) { cloneItem[key] = clone(target[key]) } return cloneItem } else { return target }}// 通过一个小栗子来测试一下：var a = { name: 'nihao', age: undefined, sayHello: function () {}, friends: [{ name: 'zhangsan', age: 18 },{ name: 'lisi', age: undefined }]}console.log(clone(a)) // 通过输出可以看到，完美拷贝成功 但是这样的递归赋值，也有它的缺点：不支持对象属性为正则的拷贝，容易造成引用死循环。 1234567var a = { name: 'nihao', age: undefined, sayHello: function () {}, target: a }console.log(clone(a)) // 因为对象的属性间接或直接的引用了自身，这样递归遍历的时候就会发生死循环，造成栈内存溢出","link":"/2019/10/01/js-copy/"},{"title":"有关js内存管理","text":"js内存管理机制 写在前面程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。 像C语言这样的底层语言一般都有底层的内存管理接口，必须手动释放内存，程序员负责内存管理。malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。 JavaScript创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。 后一个过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理。 这是错误的。 内存生命周期不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放\\归还 所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的 * JavaScript 的内存分配1. 值的初始化为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。 12345678910111213141516171819var n = 123; // 给数值变量分配内存var s = &quot;azerty&quot;; // 给字符串分配内存var o = { a: 1, b: null}; // 给对象及其包含的值分配内存// 给数组及其包含的值分配内存（就像对象一样）var a = [1, null, &quot;abra&quot;]; function f(a){ return a + 2;} // 给函数（可调用的对象）分配内存// 函数表达式也能分配一个对象someElement.addEventListener(&apos;click&apos;, function(){ someElement.style.backgroundColor = &apos;blue&apos;;}, false); 2. 通过函数调用分配内存有些函数调用结果是分配对象内存： 123var d = new Date(); // 分配一个 Date 对象var e = document.createElement(&apos;div&apos;); // 分配一个 DOM 元素 有些方法分配新变量或者新对象： 12345678910var s = &quot;azerty&quot;;var s2 = s.substr(0, 3); // s2 是一个新的字符串// 因为字符串是不变量，// JavaScript 可能决定不分配内存，// 只是存储了 [0-3] 的范围。var a = [&quot;ouais ouais&quot;, &quot;nan nan&quot;];var a2 = [&quot;generation&quot;, &quot;nan nan&quot;];var a3 = a.concat(a2); // 新数组有四个元素，是 a 连接 a2 的结果 * 使用值使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。 * 当内存不再需要使用时释放大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。 高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。 垃圾回收-GC如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。 垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。 在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。 垃圾回收有两种机制: 1. 引用计数垃圾收集; 2. 标记-清除算法.1. 引用计数垃圾收集这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。 语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，即没有引用指向该对象（零引用）就表示这个值不再用到了，因此可以将这块内存释放 简单示例：123456789101112131415161718192021var o = { a: { b:2 }}; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”的原始引用o被o2替换了var oa = o2.a; // 引用“这个对象”的a属性// 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = &quot;yo&quot;; // 最初的对象现在已经是零引用了 // 他可以被垃圾回收了 // 然而它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 限制：循环引用该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 12345678910function f(){ var o = {}; var o2 = {}; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return &quot;azerty&quot;;}f(); 实际例子IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏： 123456var div;window.onload = function(){ div = document.getElementById(&quot;myDivElement&quot;); div.circularReference = div; div.lotsOfData = new Array(10000).join(&quot;*&quot;);}; 在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。 2. 标记-清除算法这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。 这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。 这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。 循环引用不再是问题了在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。 限制: 那些无法从根对象查询到的对象都将被清除尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。 因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。","link":"/2019/02/08/js-memory/"},{"title":"javascript踩过的坑","text":"javascript踩过的坑 javaScript踩过的坑 click事件累加绑定情况一：(未复现)在页面中为一个元素绑定事件，事件执行后页面未刷新且将元素隐藏，但是元素绑定的事件未解绑，然后你再次点击，元素又被绑定个一次点击事件，这样第二次点击就会执行两次;情况二：123456$(&quot;#cover&quot;).mouseover(function (){ $(&apos;#btn&apos;).click(function (){ alert(&apos;测试累加绑定次数&apos;) }}// js中嵌套的click事件，点击多次会出现累加绑定，调用多次alert； 情况三：jquery嵌套event也会触发多次，在一次写的代码的时候就遇见过，代码如下：12345678910$(&quot;#btn_submit&quot;).on(&quot;click&quot;, function (){ // 模态框显示 $(&apos;模态框&apos;).modal(&quot;show&quot;); // 模态框里的按钮 $(&apos;#btn&apos;).on(&quot;click&quot;, function (){ if(输入验证正确){ ajax操作 } })}) 这时，click事件会出现累加绑定的现象，当输入不正确的时候，点击btn按钮，验证不通过不会触发ajax操作，但是click时间会累加绑定事件，当输入正确，点击btn按钮的时候，会触发两次绑定的事件，查看发现调用了两次ajax操作。 解决方法：1&gt; 情况一可以将元素彻底删除，重新生成，在重新绑定事件，这样每次绑定的事件都是重新绑定的，不会出现累加的情况，或者使用以下方法；2&gt; 如果是使用bind绑定的事件，可以用unbind方法解除绑定，现在bind方法已经不推荐使用了；1$(&apos;#btn&apos;).unbind(&quot;click&quot;).bind(&quot;click&quot;, function (){}) 3&gt; 如果使用了jquery的on方法绑定事件，可以有两种方式处理：3.1&gt; 使用one()方法为元素绑定一个一次性的事件处理函数，这个事件只会执行一次；1$(&apos;#btn&apos;).one(&quot;click&quot;, function (){}) 3.2&gt; 使用off()方法解除绑定；1$(&apos;#btn&apos;).off(&quot;click&quot;).on(&quot;click&quot;, function (){})","link":"/2016/11/26/js-problem/"},{"title":"JavaScript问题整理","text":"关于JavaScript的一些总结 JavaScript1.TML对象获取问题FireFox：document.getElementById(“idName”);ie:document.idname或者document.getElementById(“idName”).解决办法：统一使用document.getElementById(“idName”);2.const问题说明:Firefox下,可以使用const关键字或var关键字来定义常量;IE下,只能使用var关键字来定义常量.解决方法：统一使用var关键字来定义常量.3.event.x与event.y问题说明:IE下,event对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.解决方法：使用mX(mX = event.x ? event.x : event.pageX;)来代替IE下的event.x或者Firefox下的event.pageX.4.window.location.href问题说明:IE或者Firefox2.0.x下,可以使用window.location或window.location.href;Firefox1.5.x下,只能使用window.location.解决方法：使用window.location来代替window.location.href.5.frame问题以下面的frame为例：1&lt;frame src=&quot;xxx.html&quot; id=&quot;frameId&quot; name=&quot;frameName&quot; /&gt; (1)访问frame对象:IE:使用window.frameId或者window.frameName来访问这个frame对象. frameId和frameName可以同名。Firefox:只能使用window.frameName来访问这个frame对象.另外，在IE和Firefox中都可以使用window.document.getElementById(“frameId”)来访问这个frame对象.(2)切换frame内容:在 IE和Firefox中都可以使用window.document.getElementById(“testFrame”).src = “xxx.html”或window.frameName.location = “xxx.html”来切换frame的内容.如果需要将frame中的参数传回父窗口(注意不是opener,而是parent frame)，可以在frame中使用parent来访问父窗口。例如：1parent.document.form1.filename.value=&quot;Aqing&quot;; 6.模态和非模态窗口问题说明:IE下,可以通过showModalDialog和showModelessDialog打开模态和非模态窗口;Firefox下则不能.解决方法：直接使用window.open(pageURL,name,parameters)方式打开新窗口。如果需要将子窗口中的参数传递回父窗口,可以在子窗口中使用window.opener来访问父窗口.例如：var parWin = window.opener; parWin.document.getElementById(“Aqing”).value = “Aqing”;7.firefox与IE的父元素(parentElement)的区别IE：obj.parentElementfirefox：obj.parentNode解决方法: 因为firefox与IE都支持DOM,因此使用obj.parentNode是不错选择.8.document.formName.item(”itemName”) 问题问题说明：IE下，可以使用document.formName.item(”itemName”) 或document.formName.elements [“elementName”]；Firefox 下，只能使用document.formName.elements[“elementName”]。解决方法：统一使用document.formName.elements[“elementName”]。9.集合类对象问题问题说明：IE下，可以使用 () 或 [] 获取集合类对象；Firefox下，只能使用 [ ]获取集合类对象。解决方法：统一使用 [] 获取集合类对象。10.自定义属性问题问题说明：IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute() 获取自定义属性；Firefox下，只能使用getAttribute() 获取自定义属性。解决方法：统一通过getAttribute() 获取自定义属性。11.input.type属性问题问题说明：IE下input.type属性为只读；但是Firefox下input.type属性为读写。解决办法：不修改input.type属性。如果必须要修改，可以先隐藏原来的input，然后在同样的位置再插入一个新的input元素。12.event.srcElement问题问题说明：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性。解决方法：使用srcObj = event.srcElement ?event.srcElement : event.target;如果考虑第8条问题，就改用myEvent代替event即可。13.body载入问题问题说明：Firefox的body对象在body标签没有被浏览器完全读入之前就存在；而IE的body对象则必须在body标签被浏览器完全读入之后才存在。[注] 这个问题尚未实际验证，待验证后再来修改。[注] 经验证，IE6、Opera9以及FireFox2中不存在上述问题，单纯的JS脚本可以访问在脚本之前已经载入的所有对象和元素，即使这个元素还没有载入完成。14.事件委托方法问题说明：IE下，使用document.body.onload = inject; 其中function inject()在这之前已被实现；在Firefox下，使用document.body.onload = inject();解决方法：统一使用document.body.onload=new Function(’inject()’); 或者document.body.onload = function(){/ 这里是代码 /}[注意] Function和function的区别。15.Table操作问题问题说明：ie、firefox以及其它浏览器对于 table 标签的操作都各不相同，在ie中不允许对table和tr的innerHTML赋值，使用js增加一个tr时，使用appendChild方法也不管用。解决方法：//向table追加一个空行：var row = otable.insertRow(-1);var cell = document.createElement(“td”);cell.innerHTML = “”;cell.className = “XXXX”;row.appendChild(cell);[注] 由于俺很少使用JS直接操作表格，这个问题没有遇见过。建议使用JS框架集来操作table，如JQuery。16.对象宽高赋值问题问题说明：FireFox中类似obj.style.height = imgObj.height的语句无效。 js常见数据类型，除了typeof外，还有什么其他地方区分答：js常见数据类型：字符串、数字、布尔、数组、对象、Null、Undefined★ 检测对象类型：Array.isArray(arr) 兼容性IE9+toString.call([])数组 输出为 [object Array]字符串 输出为 [object String]数字 输出为 [object Number]boolean 输出为 [object Boolean]undefined 输出为 [object Undefined]null 输出为 [object Null]对象{} 输出为 [object Object]函数 输出为 [object Function][] instanceof(Array) = truearray.constructor == Array★ 全局的 isNaN() 方法也试图将一些非数字类型隐式转换为数字，如果转换成功，它会认为这个值是一个数字，否则会认为这是一个 NaN字符串和 undefined 都不能隐式转换为一个数字，所以被判断为是一个 NaN★ 检测NaN判断一个值为 NaN 的最好方式是判断它是一个数字类型同时不等于自身typeof obj === ‘number’ &amp;&amp; obj != +obj18.js[]声明和new array声明区别答： js的数组声明有两种方式：(1) new 方式声明一个数组:var arr = new Array(); //不传递参数；声明一个空数组var arr = new Array(3); //传递数字参数；声明一个长度为3的数组，每一项都是undefinedvar arr = new Array(“demo”); //传递一个字符串，声明一个数组，数组里的元素为’demo’;打印结果为：[‘demo’](2)直接声明的方式(这是一种字面量的声明方式)：var arr1 = [];var arr2 = [1,’tom’,{name:’jack’}];★ 两者区别：用new关键字去内存开辟一个存储空间，比较耗费资源，耗内存；而用字面量方式直接在内存开辟一个存储字段相对不耗费性能","link":"/2016/11/22/js-summary/"},{"title":"javascript 原形链的江湖恩怨","text":"javascript 原型链 写在前面说到原型链这个爱恨交织、错综复杂的东西，今天我们就来看看这是个神马东东首先追本溯源，为啥有原型链这么个东西，这就要讲到原型，继承，对象这些概念 1. 对象对象 object 说到对象的概念，我们都会仰天长叹：万物皆对象；在不同的编程语言中,设计者也利用各种不同的语言特性来抽象描述对象,最为成功的流派是使用“类”的方式来描述对象,这诞生了诸如 C++、Java 等流行的编程语言， 然而 JavaScript 为了保证对象之间的联系，引入了原型与原型链的概念2. 原型(prototype)与原型链如果说js是基于对象的，那么它也是基于原型的，现在我们先来理解几个点： 对象和函数可以说是相辅相成，对象都是函数创建出来的 123456你会不会抬杠的问：var a = {name: &apos;nihao&apos;}那你知道不，其实这段代码是这样的： var a = new Object() a.name = &apos;nihao&apos; 你看还是函数创建出来的 函数也是一个对象,不信你看 12var fn = function(){}fn instanceof Object // true 每个实例对象（object ）都有一个私有属性proto 每个函数都有一个 prototype 属性 对象的私有属性proto指向它的原型对象prototype，该原型对象也有一个自己的原型对象proto 具有原型的对象就有constructor属性,constructor属性其实是一个Object，指向同名的构造函数 依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾，即直到一个对象的原型对象为 null，根据定义，null 没有原型，并作为这个原型链中的最后一个环节。 根据这几个点，我们通过几张图来简单理解一下再来一层当把函数也看做一个对象的时候，对象就有proto属性，图形就更复杂了","link":"/2018/03/22/js-protype/"},{"title":"5个技巧让你书写更好的js条件语句","text":"5 Tips to Write Better Conditionals in JavaScript 1. 使用 Array.includes 来处理多重条件让我们看看下面的例子： 123456function getFruitColor(fruit) { if (fruit == &apos;apple&apos; || fruit == &apos;strawberry&apos;) { console.log(&apos;red&apos;); }} 好像能实现。但如果有更多红色的水果需要判断呢，比如樱桃和小红莓，我们要用更多的 || 来扩展这个表述吗 我们可以用 Array.includes 重写上面的条件 123456789function getFruitColor(fruit) { // 提取条件存储为数组 const redFruits = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;cherry&apos;, &apos;cranberries&apos;]; if (redFruits.includes(fruit)) { console.log(&apos;red&apos;); }} 2. 更少的嵌套，尽早返回让我们扩展前面的示例，以包含另外两个条件： 如果没有提供水果（名称），抛出错误。 如果（红色水果）数量超过 10 个，接受并打印。 看看上面的代码，我们有： 1组过滤无效条件的 if/else 语句 3层的 if 嵌套语句（条件 1、2、3） 123456789101112131415161718 &lt;!--当发现无效条件时，提前返回--&gt; function getFruitColor(fruit, quantity) { const redFruits = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;cherry&apos;, &apos;cranberries&apos;]; // condition 1: throw error early if (!fruit) throw new Error(&apos;No fruit!&apos;); // condition 2: must be red if (redFruits.includes(fruit)) { console.log(&apos;red&apos;); // condition 3: must be big quantity if (quantity &amp;gt; 10) { console.log(&apos;big quantity&apos;); } }} 通过反转条件和提早返回，我们可以进一步减少嵌套。看看下面的条件 1、2，我们是怎么做的 12345678910111213141516function getFruitColor(fruit, quantity) { const redFruits = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;cherry&apos;, &apos;cranberries&apos;]; // condition 1: throw error early if (!fruit) throw new Error(&apos;No fruit!&apos;); // condition 2: stop when fruit is not red if (!redFruits.includes(fruit)) return; console.log(&apos;red&apos;); // condition 3: must be big quantity if (quantity &amp;gt; 10) { console.log(&apos;big quantity&apos;); }} 但是两个版本相对比而言，上一个版本： 代码简短而直接，如果嵌套，代码就更清晰了过多的反转条件可能会导致更多的思考过程（增加认知负担）因此，总是以更少的嵌套及尽早返回为目标，但不要过度。 如果你感兴趣的话，StackOverflow 有一篇相关的文章讨论了这个话题： Avoid Else, Return Early by Tim Oxley StackOverflow discussion on if/else coding style 3. 使用默认的函数参数和解构我们在使用 JavaScript 时总是需要检查 null 或 undefined 值并分配默认值 12345678910111213function test(fruit, quantity) { if (!fruit) return; // if quantity not provided, default to one const q = quantity || 1; console.log(`We have ${q} ${fruit}!`);}//test resultstest(&apos;banana&apos;); // We have 1 banana!test(&apos;apple&apos;, 2); // We have 2 apple! 事实上，我们可以通过指定默认的函数参数来消除变量 q 12345function test(fruit, quantity = 1) { if (!fruit) return; console.log(`We have ${quantity} ${fruit}!`);} 如果我们的 fruit 是一个对象呢？我们可以指定默认参数吗？ 1234567891011121314function test(fruit) { // printing fruit name if value provided if (fruit &amp;&amp; fruit.name) { console.log (fruit.name); } else { console.log(&apos;unknown&apos;); }} //test resultstest(undefined); // unknowntest({ }); // unknowntest({ name: &apos;apple&apos;, color: &apos;red&apos; }); // apple 请看上面的示例，如果 fruit.name 是有效的，打印该水果名称，否则我们将打印 unknown 我们可以避免使用与默认函数参数和解构对条件 fruit &amp;&amp; fruit.name 进行检查 1234function test({name} = {}) { console.log (name || &apos;unknown&apos;);} 这样做的好处有： 因为我们只要水果中的属性 name，所以我们可使用 {name} 来解构，然后我们可以在代码中使用 name 作为变量，而不是 fruit.name 我们还将空对象 {} 指定为默认值。如果我们不这样做，当执行 test(undefined)，不能解构 undefined 或 null 的属性名时，您将会得到错误。因为在 undefined没有 name 属性 如果您不介意使用第三方库，有一些方法可以减少 null 检查： 使用 Lodash 的 get 函数 使用 Facebook 的开源库 idx（以及 Babeljs） 以下是使用Lodash的示例：123456789// Include lodash library, you will get _function test(fruit) { console.log(__.get(fruit, &apos;name&apos;, &apos;unknown&apos;); // get property name, if not available, assign default value &apos;unknown&apos;} //test resultstest(undefined); // unknowntest({ }); // unknowntest({ name: &apos;apple&apos;, color: &apos;red&apos; }); // apple 此外，如果您是函数式编程（FP）的粉丝，您可以选择使用Lodash fp，Lodash的函数式版本（方法为get或getOr）。 4. 选择 Map 或对象字面量，而不是 Switch 语句我们想要基于颜色打印水果名称: 1234567891011121314151617function test(color) { // use switch case to find fruits in color switch (color) { case &apos;red&apos;: return [&apos;apple&apos;, &apos;strawberry&apos;]; case &apos;yellow&apos;: return [&apos;banana&apos;, &apos;pineapple&apos;]; case &apos;purple&apos;: return [&apos;grape&apos;, &apos;plum&apos;]; default: return []; }} //test resultstest(null); // []test(&apos;yellow&apos;); // [&apos;banana&apos;, &apos;pineapple&apos;] 我们发现虽然可以实现但代码相当冗长。同样的结果可以通过对象字面量和更简洁的语法来实现： 12345678910// use object literal to find fruits in color const fruitColor = { red: [&apos;apple&apos;, &apos;strawberry&apos;], yellow: [&apos;banana&apos;, &apos;pineapple&apos;], purple: [&apos;grape&apos;, &apos;plum&apos;] }; function test(color) { return fruitColor[color] || [];} 或者，可以使用 Map 来实现相同的结果： 123456789// use Map to find fruits in color const fruitColor = new Map() .set(&apos;red&apos;, [&apos;apple&apos;, &apos;strawberry&apos;]) .set(&apos;yellow&apos;, [&apos;banana&apos;, &apos;pineapple&apos;]) .set(&apos;purple&apos;, [&apos;grape&apos;, &apos;plum&apos;]); function test(color) { return fruitColor.get(color) || [];} Map 是 ES2015 以后可用的对象类型，允许您存储键值对。 Todd Motto有一篇文章深入研究switch语句与对象文字，你可以在这里阅读。 重构的语法对于上面的例子，我们实际上可以使用Array.filter来重构我们的代码: 1234567891011121314const fruits = [ { name: &apos;apple&apos;, color: &apos;red&apos; }, { name: &apos;strawberry&apos;, color: &apos;red&apos; }, { name: &apos;banana&apos;, color: &apos;yellow&apos; }, { name: &apos;pineapple&apos;, color: &apos;yellow&apos; }, { name: &apos;grape&apos;, color: &apos;purple&apos; }, { name: &apos;plum&apos;, color: &apos;purple&apos; }]; function test(color) { // use Array filter to find fruits in color return fruits.filter(f =&gt; f.color == color);} 5. 使用Array.every和Array.some1234567891011121314const fruits = [ { name: &apos;apple&apos;, color: &apos;red&apos; }, { name: &apos;banana&apos;, color: &apos;yellow&apos; }, { name: &apos;grape&apos;, color: &apos;purple&apos; } ];function test() { let isAllRed = true; // condition: all fruits must be red for (let f of fruits) { if (!isAllRed) break; isAllRed = (f.color == &apos;red&apos;); } console.log(isAllRed); // false} 代码太长了！我们可以通过Array.every减少行数：12345678910const fruits = [ { name: &apos;apple&apos;, color: &apos;red&apos; }, { name: &apos;banana&apos;, color: &apos;yellow&apos; }, { name: &apos;grape&apos;, color: &apos;purple&apos; } ];function test() { // condition: short way, all fruits must be red const isAllRed = fruits.every(f =&gt; f.color == &apos;red&apos;); console.log(isAllRed); // false} 以类似的方式，如果我们想测试水果中是否有红色，我们可以用Array.some来实现它123456789const fruits = [ { name: &apos;apple&apos;, color: &apos;red&apos; }, { name: &apos;banana&apos;, color: &apos;yellow&apos; }, { name: &apos;grape&apos;, color: &apos;purple&apos; }];function test() { // condition: if any fruit is red const isAnyRed = fruits.some(f =&gt; f.color == &apos;red&apos;); console.log(isAnyRed); // true 参考： 5 Tips to Write Better Conditionals in JavaScript by Jecelyn Yeen","link":"/2019/03/18/js-optimization/"},{"title":"let和const的区别你真的请楚吗","text":"let和const的区别 let与const都是只在声明所在的块级作用域内有效let用来定义变量，无论是不是严格模式下，声明未初始化的时候，都不会报错，和var作用一样，返回undefinedconst用来定义常量，而且声明时必须初始化，否则报错 const不能修改定义的常量的值 但是可以修改常量的属性值，例如：123const a = {b: 9}; a.b = 1; console.log(a); 因为对于复合类型的变量，如数组和对象，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以可以修改const定义的数组或者对象的数值；也可以通过Object.freeze(name)方法冻结这个常量;例如Object.freeze(a);这时候a的属性值就不能随意更改了 有意思的是：12var let = 1; 在严格模式下报错，非严格模式下，打印let是1const let = 1;在不在严格模式下都会报错","link":"/2016/08/20/let-const/"},{"title":"移动端调试方案","text":"大大提高 debug 效率的移动端调试大法 前言在我们前端开发一些 H5 内嵌 app webview 项目的时候，经常会遇到调试的各种困难，下面就几种调试方案做一些整理，包括 ios，Android 机型调试，希望对大家有所帮助我们比较常见的调试工具有： 腾讯出品的 Web 调试面板 vconsole，抓包工具 Charles等，这些工具常见的使用方法，大家自行百度 Google 一下就有很多方案 下面就三种调试方案 做一下详细介绍，因为我的电脑是 mac 本，所以目前先使用 mac 举例（windows 后面补充），差别也不是很大 网页检查工具 weinre 第一步：我们通过如下方式安装 weinre： 1npm install -g weinre 第二步：然后在命令行中启动 weinre 服务端： 1weinre --boundHost [hostname | ip address |-all-] --httpPort [port] 可以指定自己的电脑 IP，和端口号启动，也可以通过下面的方式，直接启动到 8080 端口（也可以指定其他端口） 1weinre --httpPort 8080--boundHost -all- 第三步：接下来在 Chrome 浏览器打开 本地 ip:8080，或者 127.0.0.1:8080（不要用 localhost 访问），即可看到 weinre 的页面，点击 debug client user interface ，如红框所示： *注意：点击 debug client user interface 后，进入一个新的页面，Targets 会显示 none，所以我们需要增加 Debug Target，这时候我们需要在我们调试的项目的 index.html 页面引入 js 1&lt;script src=\"http://电脑ip:weinre服务启动的端口号/target/target-script-min.js#anonymous\"type=\"text/javascript\"&gt;&lt;/script&gt; 第四步：确保手机和电脑链接的同一个 wifi，使用手机浏览器 或者 测试 APP 上的跳转测试打开需要调试的页面，如果能看到 Target，下面有数据，就说明 Target 添加成功了，然后选中 Targets 下面的调试页面， 第五步：选中 Target 后，我们可以查看 Elements，就能看到我们检测的页面的元素了 也可以在 network 上面查看网络 api 请求，进行调试工作，如图所示： ios 机型调试方案说到 ios 调试，最经典的不过 Mac + IOS + Safari 方案： 第一步：打开 ios 手机 设置 &gt; Safari 浏览器 &gt; (在页面最下面)高级选项 &gt; Web 检查器，步骤如下： 备注：高级选项里面的 JavaScript 也要打开，一般默认都是打开状态 第二步： 打开 Mac 上的 Safari 浏览器 &gt; 偏好设置 &gt; 高级 &gt; 在菜单栏中显示“开发”菜单 第三步： 用苹果数据线连接你的Mac 电脑和 ios 手机，会弹出一个信任设备的弹窗，选择信任设备。然后在手机的Safari 浏览器中输入你要调试页面的 url 进行访问，并在电脑上的 safari 浏览器菜单上找到 【开发】选项查看检测到的页面，并点开，如下图所示 当我们点开需要调试的页面后，电脑 safari 会弹出调试的窗口，如下图所示 然后我们就能愉快的进行调试工作了，就和浏览器调试一样，当我们选中一块元素的时候，会直接响应到手机上 Android 机型调试方案Android 机型的调试方式有点复杂，Chrome 谷歌浏览器提供了很好的调试方案，但是需要加载https://chrome-devtools-frontend.appspot.com 上的资源（国内会被墙），如果你有 vpn 可以直接使用，也可以移步 Chrome 官方文档 第一步：打开 Android 手机 设置 &gt; 开发者选项 &gt; USB 调试，如下图所示： 备注：有些 Android 手机没有打开过开发者选项，设置里面是没有【开发者选项】的，基本打开方法都是找设置里面的手机版本，狂点几下，就会进入开发者模式，具体机型可以自行百度查看打开方法，这里不一一列举了。 第二步：然后通过 usb 数据线连接你的电脑和 Android 手机，会弹出如下界面，点击 确定: 第三步：在你的电脑 Chrome 浏览器输入 chrome://inspect/#devices 地址， Android 手机打开我们需要调试的 webview 页面，如图所示，我们就能看到我们的测试手机，以及 webview 页面 第四步：点击上面图中红框中检测到的 webview 页面，点击 inspect 按钮，进入调试页面，如图所示： 到此我们就能愉快的进行调试工作了。 备注：再调试的过程中，我们会遇到各种检测不到 Android 手机设备以及 检测不到 webview，或者点击 inspect 之后，页面空白的情况，试试下面的几种方案：如果是检测不到手机，可以检查一下 手机设置当中 开发者工具 以及 usb 调试 有没有打开；或者通过插拔 usb 数据线刺激一下 chrome inspect 检测如果遇到检测不到 webview 的情况，或者 点击 inspect 之后页面空白，就需要找相应的 APP 负责人 确认一下，手机上面装的是否是 debugger 调试版本的 app. Android 机型调试 推荐 直接使用 edge 浏览器 调试如果有的小伙伴没有 vpn 的话，可以下载 edge 浏览器，输入框访问：1edge://inspect/#devices 点击 “启动调试” 按钮，弹出 inspect 页面，如图所示： 点击 inspect 即可调试，步骤如 Chrome 浏览器打开 chrome://inspect/#devices 地址操作一样。 注意事项：启动调试后，检测设备稍慢，需要稍等一会；","link":"/2019/05/27/mobile-debugger/"},{"title":"模块化开发","text":"关于模块化开发的学习笔记 模块化开发1. 概述1.1 当你的网站开发越来越大复杂的时候，会经常遇到什么问题？ 命名冲突 文件依赖 。。。。。。 各种问题。。。 1.2 程序模块化开发优点 开发效率高 代码方便重用，别人开发的模块直接拿过来就可以使用， 不需要重复开发类似的功能 方便后期维护 软件的声明周期中最长的阶段其实并不是开发阶段,而是维护阶段，需求变更比较频繁，使用模块化的开发 1.3 总结 生产角度 一种生产方式，生产效率高，维护成本低 软件开发角度 就是一种开发模式，写代码的一种方式，开发效率高， 方便后期维护 1.4. 非模块化开发的问题 命名冲突 团队协作开发，不同开发人员的变量和函数命名可能 相同 文件依赖 代码重用时，引入js文件的数目可能少了或者引入的 顺序不对 1.5 模块的维护扩展(计算器实例)1.5.1 非模块化下的弊端 计算器模块：在全局定义四个分别用来计算加减乘除的四个函数 全局函数形成的模块只能人为的认为它们属于一个模块 但是程序并不能区分哪些函数是同一个模块问题 “污染”了全局变量，无法保证不与其它模块发生变量名冲突 模块成员之间看不出直接关系 1.5.2 对象封装 – 命名空间 将原来的计算器的四个函数封装到一个对象命名空间下 通过添加命名空间的形式从某种程度上解决了变量命名冲突的问题，但是并不能从根本上解决命名冲突 从代码级别可以明显的区分出哪些函数属于同一个模块 问题 暴露了所有的模块成员，内部状态可以被外部改写，不安全 命名空间越来越长 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt;第一个数：&lt;input id='x' type=\"text\" name='name'&gt; &lt;select name=\"\" id=\"opt\"&gt; &lt;option value=\"+\"&gt;+&lt;/option&gt; &lt;option value=\"-\"&gt;-&lt;/option&gt; &lt;option value=\"*\"&gt;*&lt;/option&gt; &lt;option value=\"/\"&gt;/&lt;/option&gt; &lt;/select&gt; 第二个数: &lt;input id='y' type=\"text\" name='name'&gt; &lt;button type='button' name='button' id='btn'&gt;=&lt;/button&gt; 结果：&lt;input type=\"text\" name='name' id='result'&gt; &lt;script src='./calculator.js'&gt;&lt;/script&gt; &lt;script&gt; var cal = (function(c){ c.divide = function(x,y){ return x / y; }; c.multiply = function(x,y){ return x * y; } return c; })(window.cal||{}); var btn = document.getElementById('btn'); btn.onclick = function(){ // 1. 获取文本框的值 var x = parseInt(document.getElementById('x').value); var y = parseInt(document.getElementById('y').value); // 2. 获取运算符 var opt = document.getElementById('opt'); var sum = 0; // 3. 运算 switch(opt.value){ case '+':sum = cal.add(x,y);break; case '-':sum = cal.sub(x,y);break; case '*':sum = cal.multiply(x,y);break; case '/':sum = cal.divide(x,y);break; default: } var result = document.getElementById('result'); result.value = sum; } &lt;/script&gt;&lt;/body&gt; 私有共有成员分离 将命名空间形式的计算器模块封装为立即执行函数形式，通过在函数内部返回值得形式向外暴露 私有空间的变量和函数不会影响全局作用域 公开公有方法，隐藏私有空间内部的属性、元素 12345678910var cal= (function(){ return { add:function(x,y){ return x + y; }, sub:function(x,y){ return x - y; } }})(); 总结 通过向对象的属性挂载功能实现扩展 开闭原则 代码健壮性判断 1.6 模块的第三方依赖 模块最好要保证模块的职责单一性，最好不要与程序的其它部分直接交互 通过向匿名函数注入依赖项的形式，除了保证模块的独立性，还使模块之间的依赖关系变得明显1234&lt;body&gt; &lt;script src='./jquery-1.11.1.min.js'&gt;&lt;/script&gt; &lt;script src='./third.js'&gt;&lt;/script&gt;&lt;/body&gt; third.js: 12345//匿名自执行函数(function($,q,t){//可以通过控制台报错来纠正 console.log($); $('body').css({'backgroundColor':'green'});}(window.$||{},window.q||{},window.t||{}));//对外显示出这段代码所依赖的第三方 2. SeaJS的使用一个基于CMD规范实现的模块化开发解决方案作者：Alibaba 玉伯官网：http://seajs.org/github：https://github.com/seajs/seajs特性：简单友好的模块定义规范自然直观的代码组织方式 2.1 全局函数123// js加载机制中,由上到下加载// 如果遇上变量的声明 是全局作用域// 当全局中出现两个同名变量时? 会被覆盖, 而不是先声明后不允许重复声明 文件引入顺序的依赖 全局变量的污染,无法使用多个同名变量 变量之间的关系不明显2.2 命名空间 解决了同名函数命名冲突问题 对象将所有数据都向外暴露了,可以供外部修改,不安全 私有属性,一般不向外暴露,而是提供公共的访问方式2.3 划分私有命名空间 1: 为了保证属性私有化,使用自执行函数,让变量是函数的作用域 2: 不再将变量直接暴露,而是提供对应的访问方式 3: 基于命名空间的保护,可以允许同名属性名称123function getMoney(){ return money;} 2.4 扩展与维护 坚持开闭原则(对于添加开发,对于修改是封闭) 使用自执行函数,将对象传递进来,进行属性的添加(挂载新属性) window.cal||{} 是为了保证程序的健壮性12345678910var cal = (function(c){ //添加乘法和除法功能 c.divide = function(x,y){//查找机制是当前没有,就向上级查找 return x/y; } c.multiply = function(x,y){ return x * y; } return c;//将对象返回回去})(window.cal||{}); //从当前window对象取cal对象,如果没有,就给空对象, 2.5 第三方依赖 依赖没有文档说明: 根据报错一个个的来整 依赖注入: 将自己逐级向上查找,转换为,通知外部传入 (window.$||{},wndow.q||{},wndow.t||{}); 将需要的对象在参数列表声明 2.6 模块化的好处 模块化的好处: 生产效率高/便于维护/便于扩展/复用性高 2.7 模块化分类 CMD&amp;AMD CMD 推崇同步加载 加载机制: 延迟加载(滞后/懒加载) 开发代码的规范（严格来讲就是模块化） —制约 文本要求 seajs 按照CMD实现（先有规范 后有实现） seajs 模块化加载框架 代码就是CMD代码 seajs作者 玉伯 AMD 推崇异步加载 加载机制: 前置加载(优先加载) 开发代码的规范（严格来讲就是模块化） —制约 文本要求 require.js (老外开发) 先要根据规范才有实现 –&gt; seajs 或者 requireJS 2.8 使用步骤 引入 sea.js 库 1&lt;script src='../code/seajs-3.0.0/dist/sea.js'&gt;&lt;/script&gt; 启动模块 1seajs.use(‘模块id’,function( 模块对象 ){ 业务代码 }); 定义模块 由于需要用到module 当前模块得声明成define(function(require, exports, module)1define(function(require, exports, module){ 模块代码 }); 引入模块 获取返回值（暴露接口） 一个js文件通过 module.exports = 向外返回的对象,让外部拿到 外部需要拿到对象 通过require(‘./spinning’);12345define(function(require,exports,module){ // 引入模块 var xiaohong = require('./xiaohong'); console.log(xiaohong);}) 导出模块 123//定义一个模块define(function(require,exports,module){ module.exports = '小红'; 2.8.1 定义模块 define 先有规范，后有实现 在CMD规范中，一个模块就是一个js文件 define 是一个全局函数，用来定义模块define( factory )12- 对象{}这种方式，外部会直接获取到该对象define(function(require,exports,module){}) 12- 字符串define('字符串') 123- 函数function( require, exports, module ){ // 模块代码 }为了减少出错，定义函数的时候直接把这三个参数写上duidefine({name:'jack','age':18}) 2.8.2 exports 和 module.exports 功能：通过给 exports或module.exports动态的挂载变量、函数或对象，外部会获取到该接口 exports 等价于 module.exportsexports == module.exports true 可以通过多次给exports 挂载属性向外暴露 不能直接给 exports 赋值 12345eg: module.exports -&gt; 空对象 &lt;- exports当两者被赋值时 module.exports = '123';exports = '234';二者的指向改变 module.exports -&gt; '123';exports -&gt; '234';seajs内部机制是return module.exports所以 返回的是module.exports的值 如果想暴露单个变量、函数或对象可以通过直接给 module.exports 赋值 即可 2.8.3 启动模块 seajs.use 在调用 seajs 之前，必须先引入 sea.js 文件 通过 seajs.use() 函数可以启动模块–默认传递一个参数 12(‘模块id’[,callback] ) 加载一个模块，并执行回调函数( [ ‘模块1’, ‘模块2’ ] [, callback] ) 加载多个模块，并执行回调函数–传递多个参数 返回值一一对应传递的数组参数顺序callback 参数是可选的seajs.use 和 DOM ready 事件没有任何关系 12 最好不要在 define 中 使用 seajs.use 2.8.4 加载模块 require require(‘模块id路径字符串’) 用于根据一个模块id加载该模块 参数必须是一个字符串 该方法返回值是 要加载的模块中的 module.exports 对象 只能在模块环境define中使用，define(factory)的构造方法第一个参数必须命名为 require 不要重命名require函数或者在任何作用域中给 require 重新赋值 2.8.5 模块标识 模块标识就是一个字符串，用来标识模块 模块标识可以不包含后缀名 .js 以 . /或 ../ 开头的相对路径模块，相对于 require 所在模块的路径 不以 ./ 或 ../ 开头的顶级标识，会相对于模块的基础路径解析（配置项中的base） 相对路径 ./main.js 绝对路径 E:/frontend/employcourse/itcastCourse/课堂练习/14node/01-day/demo/10-path/main.js 也可以是url地址： http://127.0.0.1:8080/js/a.js/js/a.js ‘base路径’: 默认就是seajs加载的路径 dist路径 不能以./开头 不能以盘符开头 不能以/开头 直接是一个名称 可以/结尾1234567seajs.use(['abc'],function(){});//abc不存在 默认在这里找E:/frontend/employcourse/itcastCourse/课堂练习/14node/01-day/demo/seajs-3.0.0/dist/abc.js//默认就是seajs加载的路径 dist路径//如果在seajs加载的路径 dist路径下存在abc.js文件 就不会报错否则找不到abc会报错 2.9 高级配置SeaJS alias：别名配置 起一个别名 可以是绝对路径 不能是盘符目录123456789101112html文件：seajs.config({ alias:{ 'jack':'E:/frontend/employcourse/itcastCourse/课堂练习/14node/01-day/demo/11-config/b.js'// 只能做文件的别名 } }); // seajs.use(['main'],function(a){}); seajs.use(['./tmp/main'],function(a){});main.js文件:define(function(require,exports,module){ require('jack');}) paths：路径配置 (只能做文件的别名) 给目录起一个别名使用： require(对应的字段名)1234567891011html文件：seajs.config({ paths:{ 'dirA':'E:/frontend/employcourse/itcastCourse/课堂练习/14node/01-day/demo/11-config' } }); seajs.use(['./tmp/main'],function(a){});main.js文件:define(function(require,exports,module){ require('dirA/b.js');}) base：基础路径 12345678910html文件：seajs.config({ base:'E:/frontend/employcourse/itcastCourse/课堂练习/14node/01-day/demo/11-config/tmp' }); // seajs.use(['main'],function(a){}); seajs.use(['./tmp/main'],function(a){});main.js文件:define(function(require,exports,module){ require('../b.js');}) vars：变量配置 map：映射配置 应用场景：目录层级过深 或者跨盘符的情况就可以使用 3.0 前端模块自动化整合 减少请求 js代码合并 合并的时候 如何区分模块gulp gulp-concatgulp-transport gulp-userefseajs合并本身index.html可以引入具体的文件,辨识12345//生成的路径 已经根据dest函数指定的路径了&lt;!-- build:js js/seajs.js --&gt; &lt;script src='../../seajs-3.0.0/dist/sea.js'&gt;&lt;/script&gt;&lt;!-- build:js js/seajs.js --&gt;//将src目录下的内容构建到dist目录下 4. seajs与require两者区别： seajs： 同步加载 加载机制：延迟加载 | 懒加载 | 滞后 什么时候用什么时候加载 require.js: 推崇异步加载 加载机制：加载前置 | 优先加载 要用什么就先加载什么 use 参数方式 异步加载 让用户不会觉得加载慢require 特点 require 加载机制中 模块优先从缓存中获取 如果缓存中存在 就取 不存在 就加载 异步调用 可以使用： require.async() 不管异步调用多少次 都是同步优先 异步就是不阻塞 后续代码执行 两种路径类别 补上.js也可以 相对路径 ./main.js 绝对路径 带盘符 绝对路径还可以是url路径 http://xxx.com base路径 默认就是seajs加载的路径 dist路径 不能以./开头 不能以盘符开头 不能以/开头 直接是一个名称 可以/结尾 高级配置 alias 指定一个文件的别名 可以是绝对路径 不能是盘符目录 paths 给目录起一个别名 如何使用? require(对应的字段名) base 基础路径基于非绝对路径 非相对路径 才去处理 12 应用场景 目录层级过深或者跨盘符的情况就可以使用 前端模块自动化整合 减少请求 js代码合并 合并的时候 如何区分模块gulp gulp-concat gulp-seajs-transport gulp-useref本身index.html 可以引入具体的文件,辨识12 将src目录下的内容构建到dist目录 requireJS 引入 启动模块 requirejs([依赖的模块1，依赖的模块2],function(模块1的返回值，模块2的返回值){ }) require引入的时候必须是数组 推荐：其他模块define的时候也用数组 define([依赖的模块1，依赖的模块2],(模块1的返回值，模块2的返回值){} 接受模块的返回值，function的参数中接受（模块1的返回值） 向外导出 函数内直接return seajs和requireJS的区别 代码的样子：requirejs 依赖向声明前置 seajs声明滞后 加载机制：requirejs加载前置 seajs加载滞后（何时用何时加载） CMD 和AMD CMD推崇同步 AMD推崇异步 时间换空间 12","link":"/2016/12/06/modularization/"},{"title":"NodeJS学习","text":"关于NodeJS的学习笔记 1. Node.js概述1.1 Node.js是一个在浏览器之外可以解析和执行JavaScript代码的运行时环境，或者说是一个运行时平台;基于V8引擎，事件驱动，非阻塞IO模型，高效轻便1.2 Node.js的特性 无阻塞IO模型 事件驱动 1.3 Node.js通常用来构建提供实时服务的应用程序1.4 Node.js的好处 可以在服务器端使用JavaScript了 统一了开发环境和语言，JavaScript无处不在 高性能的JavaScript引擎 – Google V8 诞生于2009年，由Ryan Dasl 发布，并且是开源的 Node.js非常轻量 Node.js同时支持Windows、Linux、Mac OSX 跨平台 1.5 Node.js的用途 多人游戏、实时系统、联网软件和具有上千个并发用户的应用程序 实时多人游戏后台服务器 基于Web的聊天客户端 单页面浏览器应用程序 基于JSON的API 不适合CPU密集型应用 1.5.1 Node能做什么 操作文件 操作数据库 接收请求 操作系统底层 数据持久化（连接数据库） 1.5.2 Node与PHP的区别*类似java/c++/php java–&gt;服务器应用程序 web开发中 要接收请求 还需要服务器来运行java代码 IIS apache node.js不需要服务器 本身这个平台就是服务器 1.5.3 谁在使用Node 国外：Uber/linked in 把消息队列从ruby语言切换到了node 国内：BAT 天猫 –&gt; 2015年双11天猫将原来的java部分，切换成了node 970亿 PV page view 日访问量 处理高频率的访问 1.5.4 node.js适合开发什么node.js适合开发IO密集（基于网络数据的输入输出）node.js不适合开发cpu密集 1.6 Node.js基于哪个JavaScript引擎Chrome 的 V8引擎 2. 安装与配置Node.js环境2.1 版本管理工具nvm 项目地址：https://github.com/creationix/nvm 直接输入nvm查看nvm的常用命令以及作用 nvm的一些常用命令： 安装指定版本 node nvm install 版本号 [arch] 卸载指定版本 node nvm uninstall 版本号 切换使用指定版本的 node nvm use 版本号 [arch] 查看本地安装的所有版本 nvm list|ls 2.2 path环境变量 当要求系统运行一个程序而没有告诉它程序所在的完整路径时 系统首先在当前目录下面寻找该程序 如果找不到，则系统会跑到path中指定的路径去找，如果找到，直接运行 如果最终path环境变量中也没有找到，则直接提示不是内部或外部命令，也不是可运行的程序 path环境的添加的两种方式 直接在path的变量值中以分好分隔加入程序所在的目录;（系统变量或者用户变量）path变量中，添加一个值，node js的目录 找到对应的node.exe 也可以在外部先定义一个变量，然后在path以%变量名%的方式添加变量;定义一个系统变量NODE_PATH值：（最后一个）nodejs版本的路径 添加到path变量中%NODE_PATH% 2.3 cmd cmd：command 命令行程序，允许用户可以在终端命令台中与操作系统交互，其实就是输出输出 作用：输入一些命令，cmd.exe可以执行， 在cmd中操作文件目录 cd（change directory） 切换目录 mkdir/md（make directory） 创建一个文件夹 rd（remove directory） 删除文件夹 del（delete） 删除指定文件 dir 列出当前目录中所有的内容 ren（rename） 改变文件名真伪全局的区别哪里都能用真全局对象在程序运行的时候 所有模块共享一个值伪全局对象在运行的时候 所有模块各有各自的值 nvm的使用nvm version （直接nvm给出对应的命令）nvm ls 查看版本信息nvm install 4.5[.0] [32||64]安装对应版本nvm uninstall 4.5.0 卸载版本nvm use 4.5.0 切换版本node 版本切换 新老版本的维护开发 需求切换版本绿色版：环境变量 –&gt;安装新版本的时候，要更改原来的目录名称 使其不被删除环境变量配置 （系统变量或者用户变量）path变量中，添加一个值，node js的目录 找到对应的node.exe 定义一个系统变量NODE_PATH值：（最后一个）nodejs版本的路径 添加到path变量中%NODE_PATH%nodejs和javascriptjavascript 在浏览器中和nodejs平台的区别架构上nodejs中没有DOM和BOM –&gt;window和document","link":"/2016/05/06/node/"},{"title":"分享一些实用的终端命令","text":"大大提高你的工作效率的终端命令 写在前面 无论是后端还是前端，都会或多或少的接触到linux命令的操作，知道一些实用的linux命令技巧，真的能大大提高我们的工作效率 命令编辑及光标移动这里有很多快捷键可以帮我们修正自己的命令。接下来使用[光标]代替光标的位置 删除从开头到光标处的命令文本: ctrl + u12345cd /text/demo;ls -al[光标]小提示：cd 路径 它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径如果此时使用ctrl + u快捷键，那么该条命令都会被清除，而不需要长按backspace键。 删除从光标到结尾处的命令文本: ctrl + k123cd /proc/tty光标;ls -al如果此时使用ctrl + k快捷键，那么从光标开始处到结尾的命令文本将会被删除。 还有其他的操作，不再举例，例如： ctrl + a:光标移动到命令开头 ctrl + e：光标移动到命令结尾 alt f:光标向前移动一个单词 alt b：光标向前移动一个单词 ctrl w：删除一个词（以空格隔开的字符串） 历史命令快速执行记录执行的历史命令: history 搜索执行过的命令: ctrl + r 实时查看日志: tail -f 加文件名123tail -f filename.log可以实时显示日志文件内容，当然，使用less命令查看文件内容，并且使用shift+f键，也可达到类似的效果mode 磁盘或内存情况查看怎么知道当前磁盘是否满了呢: df -h 使用df命令可以快速查看各挂载路径磁盘占用情况 当前内存使用情况: free -h 123456789想看内存使用情况, linux上使用free命令, mac上没这命令，可以这样查询：$ top -l 1 | head -n 10 | grep PhysMem可以在.bashrc文件中添加一个别名叫free:alias free=&apos;top -l 1 | head -n 10 | grep PhysMem&apos;以后直接使用free来查看就可以了 使用-h参数 不知道你是否注意到，我们在前面几个命令中，都使用了-h参数，它的作用是使得结果以人类可读的方式呈现 查看文件夹以及文件大小du命令可以显示文件占用的磁盘大小：du -- display disk usage statistics 语法：du [-H | -L | -P] [-a | -s | -d depth] [-c] [-h | -k | -m | -g] [-x] [-I mask] [file ...] 比较常用的几个选项： -d：指定目标文件夹的统计层数，-d 0统计整个文件夹大小，-d 1统计文件夹下第一层的文件大小，以此类推 -h：显示人类可以读懂的单位（K、M、G） -s：统计单个文件、文件夹的大小，等同于-d 0 不指定file参数，会统计当前文件夹下的所有文件的大小 12举例 ：比如你想查看当前某个文件夹的大小du -h -s [dir_url] Mac_查看开关机记录查看开机时间记录: last | grep reboot 查看关机时间记录: last | grep shutdown 查询Mac一共运行了多久: uptime 123456714:03 up 3:51, 4 users, load averages: 1.89 1.80 2.00参数说明: 14:03-&gt;当前时间；up 3:51: 系统运行时长; 4 users -&gt; 登录用户（第二个是串行端口终端）load averages -&gt; 后面的三个数字则显示了系统最近1分钟、5分钟、15分钟的系统平均负载情况(例如，本输出中系统有4个逻辑CPU，如果load average的三个值长期大于4时，说明CPU很繁忙，负载很高，可能会影响系统性能，但是偶尔大于4时，倒不用担心，一般不会影响系统性能。相反，如果load average的输出值小于CPU的个数，则表示CPU还有空闲) 终端输入w（类似uptime可推算出开机时间，可查看登录用户信息）1234514:17 up 4:05, 3 users, load averages: 2.05 2.63 2.45USER TTY FROM LOGIN@ IDLE WHATusername console - 10:12 4:04 -username s000 - 14:17 - wusername s001 - 10:19 9 hexo 多条命令执行使用分号隔开可以执行多条命令 123456789101112cd /temp/log/;rm -rf *但是如果当前目录是/目录，并且/temp/log目录不存在，那么就会发生激动人心的一幕：cd: /temp/log: No such file or directory 因为;可以执行多条命令，但是不会因为前一条命令失败，而导致后面的不会执行，因此，cd执行失败后，仍然会继续执行rm -rf *，由于处于/目录下，结果就可以删库跑路啦 如果解决呢？很简单，使用&amp;&amp;，例如:cd /temp/log/&amp;&amp;rm -rf * 根据进程名称进行操作列出当前系统运行中的进程的状态信息：ps 它只显示命令执行时的进程状态，如果想要动态列出状态信息，可以选择使用top命令 1234567891011121314151617181920ps 参数：a 显示所有进程-a 显示同一终端下的所有程序-A 显示所有进程c 显示进程的真实名称-N 反向选择-e 等于“-A”e 显示环境变量f 显示程序间的关系-H 显示树状结构r 显示当前终端的进程T 显示当前终端的所有程序u 指定用户的所有进程-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程 -C&lt;命令&gt; 列出指定命令的状况--lines&lt;行数&gt; 每页显示的行数--width&lt;字符数&gt; 每页显示的字符数--help 显示帮助信息--version 显示版本显示 进程太多时分页显示: ps -aux|more 快速直接查找进程id: pgrep + 进程名称；或者： pidof + 进程名称 根据名称杀死进程: killall + 进程名称；或者：pkill + 进程名称 1一般我们可以使用kill -9 pid方式杀死一个进程，但是这样就需要先找到这个进程的进程id，实际上我们也可以直接根据名称杀死进程 查看进程运行时间: ps -p 进程id -o lstart,etime 查看压缩日志文件有时候文件是压缩的, 不解压查看: zcat test.gz；或者：zless test.gz 命令行下的复制粘贴在命令行下，复制不能再是ctrl + c了，因为它表示终止当前进程，而控制台下的复制粘贴需要使用下面的快捷键： 1234ctrl + insertshift + insertmac 系统：cmd + c; cmd + v 搜索包含某个字符串的文件当前目录下查找包含test字符串的文件: grep -rn “搜索的关键字” 查看端口号进程占用lsof -i tcp:8080 （想查阅的端口号） 接下来继续在命令行输入 kill pid (即：杀死进程 图中的 PID: 351 或者 379) 指定目录下的全部文件复制到另一个目录中 copy12345语法： cp [选项] 源文件或目录 目标文件或目录 说明：该命令把指定的源文件复制到目标文件或把多个源文件复制到目标目录中。示例：cp -rf /source_demo/* /newFilesource_demo文件夹的所有子文件都会强制复制到newFile目录下 该命令的各选项含义如下： a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。 d 拷贝时保留链接。 f 删除已经存在的目标文件而不提示。 i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。 p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。 r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。 l 不作拷贝，只是链接文件。 指定目录下的全部文件移动到另一个目录中 move用法同copy 文件传输工具 curlcurl 是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具，它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 常见参数： -A/–user-agent 设置用户代理发送给服务器-b/–cookie &lt;name=string/file&gt; cookie字符串或文件读取位置-c/–cookie-jar 操作结束后把cookie写入到这个文件中-C/–continue-at 断点续转-D/–dump-header 把header信息写入到该文件中-e/–referer 来源网址-f/–fail 连接失败时不显示http错误-o/–output 把输出写到该文件中-O/–remote-name 把输出写到该文件中，保留远程文件的文件名-r/–range 检索来自HTTP/1.1或FTP服务器字节范围-s/–silent 静音模式。不输出任何东西-T/–upload-file 上传文件-u/–user &lt;user[:password]&gt; 设置服务器的用户和密码-w/–write-out [format] 什么输出完成后-x/–proxy &lt;host[:port]&gt; 在给定的端口上使用HTTP代理-#/–progress-bar 进度条显示当前的传送状态 基本用法:123&lt;!--执行后，www.linux.com 的html就会显示在屏幕上了--&gt;curl http://www.linux.com 常见用处： 获取页面内容: 当我们不加任何选项使用 curl 时，默认会发送 GET 请求来获取链接内容到标准输出。 1curl http://www.example.com 显示 HTTP 头: 如果我们只想要显示 HTTP 头，而不显示文件内容，可以使用 -I 选项 1curl -I http://www.example.com 也可以同时显示 HTTP 头和文件内容，使用 -i 选项： 1curl -i http://www.example.com 将链接保存到文件: 我们可以使用 &gt; 符号将输出重定向到本地文件中 1curl http://www.example.com &gt; index.html 也可以通过 curl 自带的 -o/-O 选项将内容保存到文件中 -o（小写的 o）：结果会被保存到命令行中提供的文件名-O（大写的 O）：URL 中的文件名会被用作保存输出的文件名 12curl -o index.html http://www.example.comcurl -O http://www.example.com/page/2/ 注意：使用 -O 选项时，必须确保链接末尾包含文件名，否则 curl 无法正确保存文件。如果遇到链接中无文件名的情况，应该使 用 -o 选项手动指定文件名，或使用重定向符号。 同时下载多个文件: 我们可以使用 -o 或 -O 选项来同时指定多个链接，按照以下格式编写命令： 123curl -O http://www.example.com/page/2/ -O http://www.example.com/page/3/&lt;!--或者：--&gt;curl -o page1.html http://www.example.com/page/1/ -o page2.html http://www.example.com/page/2/ 使用 -L 跟随链接重定向: 如果直接使用 curl 打开某些被重定向后的链接，这种情况下就无法获取我们想要的网页内容。例如： 1curl http://www.example.com 而当我们通过浏览器打开该链接时，会自动跳转到 http://www.example.com。此时我们想要 curl 做的，就是像浏览器一样跟随链接的跳转，获取最终的网页内容。我们可以在命令中添加 -L 选项来跟随链接重定向： 1curl -L http://www.example.com 使用 -A 自定义 User-Agent: 我们可以使用 -A 来自定义用户代理，例如下面的命令将伪装成安卓火狐浏览器对网页进行请求： 1curl -A &quot;Mozilla/5.0 (Android; Mobile; rv:35.0) Gecko/35.0 Firefox/35.0&quot; http://www.baidu.com 使用 -H 自定义 header: 当我们需要传递特定的 header 的时候，可以仿照以下命令来写： 1curl -H &quot;Referer: www.example.com&quot; -H &quot;User-Agent: Custom-User-Agent&quot; http://www.baidu.com 可以看到，当我们使用 -H 来自定义 User-Agent 时，需要使用 “User-Agent: xxx” 的格式。 我们能够直接在 header 中传递 Cookie，格式与上面的例子一样： 1curl -H &quot;Cookie: JSESSIONID=D0112A5063D938586B659EF8F939BE24&quot; http://www.example.com 使用 -c 保存 Cookie: 当我们使用 cURL 访问页面的时候，默认是不会保存 Cookie 的。有些情况下我们希望保存 Cookie 以便下次访问时使用 12&lt;!-- -c 后面跟上要保存的文件名。--&gt;curl -c &quot;cookie-example&quot; http://www.example.com 使用 -b 读取 Cookie: 前面讲到了使用 -H 来发送 Cookie 的方法，这种方式是直接将 Cookie 字符串写在命令中。如果使用 -b 来自定义 Cookie，命令如下： 1curl -b &quot;JSESSIONID=D0112A5063D938586B659EF8F939BE24&quot; http://www.example.com 如果要从文件中读取 Cookie，-H 就无能为力了，此时可以使用 -b 来达到这一目的：1curl -b &quot;cookie-example&quot; http://www.example.com 即 -b 后面既可以是 Cookie 字符串，也可以是保存了 Cookie 的文件名。 使用 -d 发送 POST 请求: 我们以登陆网页为例来进行说明使用 cURL 发送 POST 请求的方法。假设有一个登录页面 www.example.com/login，只需要提交用户名和密码便可登录。我们可以使用 cURL 来完成这一 POST 请求，-d 用于指定发送的数据，-X 用于指定发送数据的方式： 1curl -d &quot;userName=tom&amp;passwd=123456&quot; -X POST http://www.example.com/login 在使用 -d 的情况下，如果省略 -X，则默认为 POST 方式：1curl -d &quot;userName=tom&amp;passwd=123456&quot; http://www.example.com/login 强制使用 GET 方式: 发送数据时，不仅可以使用 POST 方式，也可以使用 GET 方式，例如：1curl -d &quot;somedata&quot; -X GET http://www.example.com/api 或者使用 -G 选项：1curl -d &quot;somedata&quot; -G http://www.example.com/api 从文件中读取 data1curl -d &quot;@data.txt&quot; http://www.example.com/login 带 Cookie 登录1curl -c &quot;cookie-login&quot; -d &quot;userName=tom&amp;passwd=123456&quot; http://www.example.com/login 再次访问该网站时，使用以下命令：1curl -b &quot;cookie-login&quot; http://www.example.com/login 这样，就能保持访问的是登录后的页面了。","link":"/2019/03/27/linux-skill/"},{"title":"nginx使用笔记","text":"Mac OS系统下，Nginx的配置和常用命令 为什么选择NginxNginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性: 作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型. 作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。 Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。 正向代理与反向代理代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端 正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 客户端可以根据正向代理访问到它本身无法访问到的服务器资源。 正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问 反向代理 是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。 反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务 安装mac 必备软件包管理工具homebrew，通过brew可以很方便的在Mac中安装软件或者是卸载软件. 常用指令如下: brew 搜索软件:brew search nginx brew 安装软件:brew install nginx brew 卸载软件:brew uninstall nginx brew 升级:brew update 查看安装信息(经常用到, 比如查看安装目录等):brew info nginx 查看已经安装的软件:brew list brew安装nginx1brew install nginx 安装完以后，可以在终端输出的信息里看到一些配置路径： /usr/local/etc/nginx/nginx.conf - 配置文件路径 /usr/local/Cellar/nginx/1.15.9 - 安装路径 nginx默认使用8080端口 如果发现端口被占用了，可以杀掉使用使用改端口的进程，也可以修改/usr/local/etc/nginx/nginx.conf 下的: 123456789http { server { listen 8080; &lt;!--8080端口被占用，此处的listen的端口配置 可以改为8081或者其他--&gt; server_name localhost; #charset koi8-r; ..... } } 测试nginx是否安装成功，因为默认配置文件监听的是8080端口，所以先对8080端口发起请求： curl -ILhttp://127.0.0.1:8080 curl 命令见 分享一些实用的Linux技巧文章总结的 - curl 命令 如果安装成功，打开浏览器输入：localhost:8080 会有一个默认欢迎界面 基本配置 main:nginx的全局配置，对全局生效。 events:配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 nginx常用命令： 打开 nginxnginx 或者 sudo nginx 关闭nginx服务sudo brew services stop nginx 重新启动nginxnginx -s reload 停止nginxnginx -s stop 查看nginx进程ps -ef|grep nginx 这段命令可以查看本身的进程 ps 命令见 分享一些实用的Linux技巧文章总结的 - ps 命令 nginx 代理本地到服务器接口查看配置文件 /usr/local/etc/nginx/nginx.conf https server设置 1.8123456789101112131415161718server { server_name ds.local; location / { root path; // path: 需要代理的项目目录 try_files $uri /index.html; // 自动找index.html 入口文件 index index.html; } location \"/api/1\" { proxy_pass URL // \"/api/1\"： 为接口前缀 // URL: 需要代理的服务器地址 }} 如果有多个项目想要ngin代理 配置文件 /usr/local/etc/nginx/nginx.conf 中 https server设置： 1.8123// 将上述https server设置 注释 或者删除，修改为：include servers/*; 然后 /usr/local/etc/nginx 路径下新建 servers 文件夹 比如project1 和 project2 需要代理 则在servers 文件夹 新建文件 host.project1.conf 和 host.project2.conf 然后每个项目的nginx文件添加相应的配置 host.project1.conf 文件：1.81234567891011121314151617server { server_name project1.local; location / { root /project1/path; // path: 需要代理的项目目录 try_files $uri /index.html; // 自动找index.html 入口文件 index index.html; } location \"/api/1\" { proxy_pass URL // \"/api/1\"： 为接口前缀 // URL: 需要代理的服务器地址 }} host.project2.conf 文件：1.81234567891011121314151617server { server_name project2.local; location / { root /project2/path; // path: 需要代理的项目目录 try_files $uri /index.html; // 自动找index.html 入口文件 index index.html; } location \"/api/1\" { proxy_pass URL // \"/api/1\"： 为接口前缀 // URL: 需要代理的服务器地址 }}","link":"/2019/04/16/nginx-init/"},{"title":"react入门学习","text":"react入门学习 关于react自学路程 通过最近的面试给我的反馈就是react无疑已经是许多公司首选框架，我也觉得确实应该好好学习一下了，自己喜欢整理一些东西，整理的过程可以使自己逻辑更清晰，也是检验自己是不是真的理解这个知识的一种途径。 1. 什么是react，react的优缺点正如官方所说：React is a JavaScript library for building user interfaces.react是facebook维护的一个为了更好的构建用户界面的js库，它可以在浏览器端运行，也可以在服务端运行。 react优点： 1&gt; 因此虚拟dom的引入大大的提高了性能；2&gt; 虚拟dom也帮助我们解决了跨浏览器兼容的问题，它为我们提供了一套标准的api，在IE8上也是兼容的；3&gt; React推荐以组件的方式去重新思考UI构成，将UI上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI的构建，这样代码更见模块化，重用性高，可维护性高； react缺点： 1&gt; 首先新框架，都说学习成本高2&gt; 好多坑要自己慢慢踩，emmmmmm…..3&gt; React本身只是一个V而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用 2. react的diff算法简述在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。 而复杂或频繁的DOM操作是很消耗性能的，因此react引入了虚拟DOM（virtual DOM），在浏览器端用Javascript实现了一套DOM API。 基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比（当两个节点不同时，应该如何处理。这分为两种情况： 节点类型不同 ; 节点类型相同，但是属性不同，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。 而且React能够批处理虚拟DOM的刷新 在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化； 需要注意的是，删除节点意味着彻底销毁该节点，而不是再后续的比较中再去看是否有另外一个节点等同于该删除的节点。 如果该删除的节点之下有子节点，那么这些子节点也会被完全删除，它们也不会用于后面的比较。 3. JSX语法简介HTML语言直接写在js语言中，不加任何引号，这就是JSX，可以允许html和js混写，例如下面：123456789101112var examples = [&apos;name&apos;,&apos;age&apos;,&apos;gender&apos;];React.render( &lt;ul&gt; { examples.map(function(example){ return &lt;li&gt;{example}&lt;/li&gt;; } ) } &lt;/ul&gt;, document.getElementById(&apos;container&apos;)); 遍历examples数组，并用ul的li的形式输出到界面上；JSX也允许将模板插入到js中，例如：12345678var arr = { &lt;h1&gt;hello world&lt;/h1&gt;, &lt;h2&gt;hello niwei&lt;/h2&gt;,}React.render( &lt;div&gt;{arr}&lt;/div&gt;, document.getElementById(&apos;container&apos;)); 4. 关于react的学习自己练习并整理一些代码，关于代码的理解都有注释，也是自己学习深入的过程地址：https://github.com/qilanbei/ReactStudy","link":"/2017/10/27/react-init/"},{"title":"如何发布自己模块到 NPM","text":"手把手教你用npm发布一个package npm包管理npm其实是Node.js的包管理工具（node package manager） 在我们工作开发当中，为了开发效率，会用到很多开源的代码，大家也都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用 而且npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。不然，靠我们自己手动管理会很繁琐 准备工作去官网注册一个属于自己的账号 安装nodejs后 自动就有npm了，请自己google安装配置吧 Tip: 关于node版本管理工具，除了nvm 还有个工具叫做 n , 对，人家就叫这个名字，简单时尚 npm的基础使用如果之前你设置了淘宝镜像 将npm包的镜像换成 https://www.npmjs.com/ npm config set registry https://www.npmjs.com/ 由于我们这里是往 Npm 仓库 发布包的，这里设置的下载地址是 淘宝镜像仓库，二者不一致会导致错误 如果这个官方npm加载速度慢，之后再切换回来 npm config set registry https://registry.npm.taobao.org 总结一些常用的npm指令： login: 登录npm access：设置已发布包的访问级别 adduser： 添加一个注册用户账号 audit：运行一个安全审核 bin： 显示bin文件夹 build：Build 一个包 cache: 操作程序包缓存 publish: 发布一个package updated: 更新一个package unpublish: 撤销一个package 更对命令操作查看官网 如何开发一个package1. 初始化项目 新建目录 mkdir packageDemo &amp;&amp; cd packageDemo 生成package.json文件 npm init 本地通过npm init 来创建 package.json 文件，需要数据一些模块的信息，如名称、版本、描述、作者、license等 具体的目录结构如下： 1234567891011121314.├── .eslintrc.json // eslint 文件├── .git├── .gitignore // .gitignore 可忽略上传文件和一些默认的编辑器配置文件├── .npmignore // .npmignore 不需要publish的文件├── .travis.yml // travis CI├── LICENSE├── README.md├── index.js // 入口文件├── lib // 主要逻辑代码├── node_modules├── package-lock.json├── package.json└── test //测试用例 开发自己的功能 根据需要增加 eslint 和 代码检查 发布一个 package 到 npm登录npm 首先，我们需要到 npm官网 注册一个账号。然后添加到本地配置 npm adduser 1234npm adduserUsername:password:Email: 为了安全起见，输入密码不会显示任何东西，你只需输入完成按回车即可，不用担心自己是否没有输入上 然后验证自己的配置:npm whoami 如果已经添加过，直接login npm login 1234npm loginUsername:password:Email: (this IS public) 输入自己在npm上面的用户名、密码、邮箱，完成登录之后，显示： 发布公有npm包 项目完成之后，我们需要将模块发布到npmjs 最后，在package.json 定义好版本，通过 npm publish 发布模块即可 1234npm publish//返回下面的信息就是发布成功了 + packageName@0.0.1 发布过程会把整个目录发布,不想发布的内容模块,可以通过 .gitignore 或 .npmignore 文件忽略 发布成功后 你的包名就是 package.json中的name 发布成功之后可以去npm官网搜索一下是否已经发布成功到npm了 发布组织下的一个package 首先，你要被加到一个组织下，如图所示： package.json上面的name 需要要这样命名： @组织名称/包名称 scope 是 npm 的新特性。如果一个模块的名字以 “@” 开始，那么他就是一个scoped package。scope 就是”@”与”/“之间的部分。 1.81234567891011121314151. 当你注册私有模块到一个组织下时，你的 scope 就是当前组织名@organizationName/packageName2. 当你注册私有模块到一个用户下时，你的 scope 就是当前用户的用户名@username/packageName3. 如果要使用 npm init 初始化一个软件包，你可以通过自定义 --scope 选项设置你的 scopenpm init --scope=&lt;your_scope&gt;4. 如果你在大多数时候使用的 scope 都是相同的，可以设置一个默认的scope，这样在我们初始化的时候会自动使用该 scopenpm config set scope &lt;your_scope&gt; 这样发布的时候，就属于组织下的package了 发布，要告诉这是一个组织下的公有包 npm publish --access public 发布私有包 默认情况下，scoped package 会发布为私有模块，发布为私有模块是需要付费的，费用是每个月 $7 一旦完成发布，你将会在npm库站点上看到你的 scoped package，有 private 标志，说明是非公共的模块，他人无法使用。 如果你要授权给其他人使用你的模块，你可以在 package 的权限设置页面设置哪些用户可以拥有 只读或读写 权限。也可以通过命令行进行相关设置 npm owner add &lt;user&gt; &lt;package name&gt; 如何更新npm包 使用命令行 npm version patch 更新package.json里面的版本号npm version 0.0.2 //package.json修改为 0.0.2版本 [ 注：patch会自动更新package.json里面的版本号 ] 使用 npm publish,更新就会完成 npm version后面参数说明： 123patch：小变动，比如修复bug等，版本号变动 v0.0.1 -&gt; v0.0.2minor：增加新功能，不影响现有功能,版本号变动 v0.1.0-&gt;v0.2.0major：破坏模块对向后的兼容性，版本号变动 v1.0.0-&gt;v2.0.0 使用npm包 下载公有模块 通过 npm install packageName 下载想要的package 下载之前，也可以通过 npm search packageName 查询一下 使用更新后的NPM包 1234针对patch： npm install packageName针对minor： npm install packageName针对major： npm install packageName@2.0.0 下载私有模块 npm install @scope/packageName 总结发布流程应该是这样的： 第一次发布 创建目录，使用 npm init 添加 package.json 文件，开发自己的功能 执行 git push origin master，将改动同步到远程代码仓库 开发完成后，在本地添加用户配置 npm adduser 定义好 package.json 文件中的版本号version 根据自己需求发布到相应的公有私有模块，执行 npm publish ，将模块发布到 npm 仓库 更新发布 根据此次变更执行 npm version [new version] 命令（npm 会根据 new version 指定的类型更新 package.json 中的 version 字段，然后进行一次 commit 执行 git push origin master，将改动同步到远程代码仓库 开发完成后，登录 npm npm login 根据自己需求发布到相应的公有私有模块，执行 npm publish ，将模块发布到 npm 仓库","link":"/2019/04/17/npm-publish/"},{"title":"关于react问题整理","text":"对接触react过程中遇到的问题进行整理 1. 如何绑定一个函数到一个组件实例有A, B, C 三种绑定方式 A: 第一种绑定方式，官网推荐，这样绑定对于react底层设计友好 12345678910111213class Foo extends Component { constructor(props) { super(props); &lt;!--A:--&gt; this.handleClick = this.handleClick.bind(this); } handleClick() { console.log(&apos;Click happened&apos;); } render() { return &lt;button onClick={this.handleClick}&gt;Click Me&lt;/button&gt;; }} B：第二种绑定方式：在render方法中使用Function.prototype.bind 1234567891011render() { 但是会在每次组件渲染时创建一个新的函数，可能会影响性能 return &lt;button onClick={this.handleClick.bind(this)}&gt;Click Me&lt;/button&gt;; 也可以在Render中的使用箭头函数，此语法问题在于每次渲染组件时都会创建不同的回调函数。在大多数情况下， 这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。 我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题 直接箭头函数是向回调函数传递参数的最简单的办法，如下： return &lt;button onClick={() =&gt; this.handleClick()}&gt;Click Me&lt;/button&gt;; } C: 第三种绑定方式, 使用箭头函数的方式 为什么这样可以 箭头函数本身没有this ,但是它会捕捉其所在上下文的this来作为自己的this ES6中的箭头函数会直接调用的this是继承父级的this123handleClick = () =&gt; { console.log(&apos;Click happened&apos;); } 2. 为什么我的函数每次组件渲染时都会被调用在你传递函数给组件时：12345render() { // Wrong: handleClick is called instead of passed as a reference! return &lt;button onClick={this.handleClick()}&gt;Click Me&lt;/button&gt;} 确保你没有调用函数, 正确做法是，传递函数本身（不带括号）：1234render() { // Correct: handleClick is passed as a reference! return &lt;button onClick={this.handleClick}&gt;Click Me&lt;/button&gt;} 3. 如何传递参数给事件处理器或回调可以使用箭头函数包裹事件处理器，并传递参数： 12345678910111213render() { return ( &lt;div&gt; &lt;ul&gt; {this.state.letters.map(letter =&gt; &lt;li key={letter} onClick={() =&gt; this.handleClick(letter)}&gt; {letter} &lt;/li&gt; )} &lt;/ul&gt; &lt;/div&gt; ) } 或者使用.bind() 12&lt;li key={letter} onClick={this.handleClick.bind(this, letter)}&gt;{letter}&lt;/li&gt; 通过data-属性传递参数: 12345678910111213141516171819handleClick(e) { this.setState({ justClicked: e.target.dataset.letter }); }render() { return ( &lt;div&gt; Just clicked: {this.state.justClicked} &lt;ul&gt; {this.state.letters.map(letter =&gt; &lt;li key={letter} data-letter={letter} onClick={this.handleClick}&gt; {letter} &lt;/li&gt; )} &lt;/ul&gt; &lt;/div&gt; ) } 4. 为什么我setState数据之后，打印出来还是原来的值首先你要知道setState到底做了什么setState() 用于安排一个组件的 state 对象的一次更新的时间表。当状态改变时，组件通过重新渲染来响应 setState 的调用是异步的——不要紧接在调用 setState 之后，依赖 this.state 来反射新值。 12345678910111213incrementCount() { // Note: this will *not* work as intended. this.setState({count: this.state.count + 1});}handleSomething() { // Let&apos;s say `this.state.count` starts at 0. this.incrementCount(); this.incrementCount(); this.incrementCount(); 你期望的是变成3 但是每次都是1} 那如何用依赖于当前状态的值更新状态如果你需要基于当前状态计算值，则传递一个更新函数而不是一个对象（请参阅下面的详细信息） 关于setState，其实官网示例是这样的：setState(updater, [callback])， 所以传递一个函数而不是一个对象给 setState 来确保调用总是使用最新的状态，传递一个更新函数允许你在更新器中访问当前的状态值，由于 setState 调用是批处理的，这允许你链式更新并确保它们一个建立在另一个之上，而不是产生冲突 将setState()认为是一次请求而不是一次立即执行的命令来更新组件。为了更为可观的性能，React可能会推迟它，稍后会一次性更新这些组件。React不能保证状态改变被应用是立刻地 这使得在调用setState()后立刻读取this.state变成一个潜在陷阱 代替地，使用componentDidUpdate或一个setState回调（setState(updater, callback)），当中的每个方法都会保证在更新被应用之后触发。 updater函数接收到的state 和 props保证都是最新的。updater的输出被浅合并到state中 setState()的第二个参数是一个可选的回调函数，其执行将是在一旦setState完成，并且组件被重新渲染之后。 通常，对于这类逻辑，我们推荐使用componentDidUpdate 1234567incrementCount() { this.setState((state) =&gt; { // Important: read `state` instead of `this.state` when updating. return {count: state.count + 1} });} 为什么React不是同步地更新this.state这个问题也可以参考我的另一篇blog: react入门学习 中关于react的diff算法的简述提到 其实，React故意”等待”直到所有的组件都调用setState()在他们的事件处理器中才开始重新渲染。这提升了性能，避免了不必要的重新渲染 5. 无法以异步方式访问event.target12345678910111213141516function onClick(event) { console.log(event); // =&gt; nullified object. console.log(event.type); // =&gt; \"click\" const eventType = event.type; // =&gt; \"click\" setTimeout(function() { console.log(event.type); // =&gt; null console.log(eventType); // =&gt; \"click\" }, 0); // Won't work. this.state.clickEvent will only contain null values. this.setState({clickEvent: event}); // You can still export event properties. this.setState({eventType: event.type});}","link":"/2018/08/16/react-study/"},{"title":"关于正则表达式","text":"关于正则表达式 正则引擎关于正则首先要说的是正则引擎主要可以分为基本不同的来两大类：一种是DFA（确定型自动机），一种是NFA（不确定型有穷自动机）。而DFA对应的是文本主导的匹配，从左到右，每个字符不会匹配两次，它的时间复杂度是多项式的，通常情况下，它的速度更快，但支持的特性少，不支持捕获组、各种引用等等；NFA对应的是正则表达式主导的匹配，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，通常它的速度慢，最优时间复杂度为多项式，最差情况为指数级的，但是NFA支持的特性多，因而绝大多数编程场景下（包括java,js），面对的都是NFA； NFA匹配的过程就是吃入字符，尝试匹配，如果通过，再吃入尝试；如果不通过，就吐出，回到上一个状态，因为同一个字符串正则中可能存在一种不同转化路径，这时正则引擎换一个转化状态进行尝试，如果通过，继续吃入字符，否则继续吐出字符，回到上一个状态。这种尝试不成功就返回上一状态的过程，就称为回溯。正则匹配的性能好坏，就看回溯的情况，回溯越多，性能越差。 而在DFA匹配时候，采用的是用文本来匹配正则表达式的方式，从a开始匹配t，直到第一个t跟正则的t匹配，但e跟o匹配失败，继续，直到文本里面的第二个 t 匹配正则的t，接着o与o匹配，n的时候发现正则里面有三个可选匹配，开始并行匹配，直到文本中的g使得第一个可选条件不匹配，继续，直到最后匹配。 可以看到，DFA匹配过程中文本中的字符每一个只比较了一次，没有吐出的操作，应该是快于NFA的。另外，不管正则表达式怎么写，对于DFA而言，文本的匹配过程是一致的，都是对文本的字符依次从左到右进行匹配，所以，DFA在匹配过程中是跟正则表达式无关的，而 NFA 对于不同但效果相同的正则表达式，匹配过程是完全不同的。 2.回溯说完了引擎，我们再来看看到底什么是回溯。对于下面这个表达式，相信大家很清楚它的意图， ab{1,3}c 也就是说中间的b需要匹配1~3次。那么对于文本“abbbc”，按照第1部分NFA引擎的匹配规则，其实是没有发生回溯的，在表达式中的a匹配完成之后，b恰好和文本中的3个b完整匹配，之后是c发生匹配，一气呵成。如果我们把文本换成“abc”呢？无非就是少了一个字母b，却发生了所谓的回溯。匹配过程如下图所示（后面有’为匹配，没有为不匹配），（左） 正则 （右） 文本第一步 | a‘ | b{1,3} | c |第二步 | a‘ | b{1,3}‘| c |第三步 | a‘ | b{1,3}‘| c | 1~2步应该都好理解，但是为什么在第3步开始，虽然已经文本中已经有一个b匹配了b{1,3}，后面还会拉着字母c跟b{1,3}做比较呢？这个就是我们下面将要提到的正则的贪婪特性，也就是说b{1,3}会竭尽所能的匹配最多的字符。在这个地方我们先知道它一直要匹配到撞上南墙为止。 在这种情况下，第3步发生不匹配之后，整个匹配流程并没有走完，而是像栈一样，将字符c吐出来，然后去用正则表达式中的c去和文本中的c进行匹配。这样就发生了一次回溯。 3.贪婪、懒惰与独占下面的几个特殊字符相信大家都知道它们的用法： i. ?: 告诉引擎匹配前导字符0次或一次。事实上是表示前导字符是可选的。ii. +: 告诉引擎匹配前导字符1次或多次。iii. *: 告诉引擎匹配前导字符0次或多次。iv. {min, max}: 告诉引擎匹配前导字符min次到max次。min和max都是非负整数。如果有逗号而max被省略了，则表示max没有限制；如果逗号和max都被省略了，则表示重复min次。 默认情况下，这个几个特殊字符都是贪婪的，也就是说，它会根据前导字符去匹配尽可能多的内容。这也就解释了为什么在第3部分的例子中，第3步以后的事情会发生了。 在以上字符后加上一个问号（？）则可以开启懒惰模式，在该模式下，正则引擎尽可能少的重复匹配字符，匹配成功之后它会继续匹配剩余的字符串例如：ab{1,3}？c由此可见，在非贪婪模式下，第2步正则中的b{1,3}?与文本b匹配之后，接着去用c与文本中的c进行匹配，而未发生回溯。 如果在以上四种表达式后加上一个加号（+），则会开启独占模式。同贪婪模式一样，独占模式一样会匹配最长。不过在独占模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。我们以下面的表达式为例， ab{1,3}+bc 如果我们用文本”abbc”去匹配上面的表达式，可以发现，在第2和第3步，b{1,3}+会将文本中的2个字母b都匹配上，结果文本中只剩下一个字母c。那么在第4步时，正则中的b和文本中的c进行匹配，当无法匹配时，并不进行回溯，这时候整个文本就无法和正则表达式发生匹配。如果将正则表达式中的加号（+）去掉，那么这个文本整体就是匹配的了。","link":"/2017/03/22/regex/"},{"title":"token相关","text":"关于token相关笔记 token相关1.token的工作原理1&gt; 登录时候,客户端通过用户名与密码请求登录2&gt; 服务端收到请求区验证用户名与密码3&gt; 验证通过,服务端会签发一个Token,再把这个Token发给客户端.4&gt; 客户端收到Token,存储到本地,如Cookie,SessionStorage,LocalStorage.5&gt; 客户端每次像服务器请求API接口时候,都要带上Token.6&gt; 服务端收到请求,验证Token,如果通过就返回数据,否则提示报错信息.2.token值得注意的事1&gt; token 过期时间为 30 分钟2&gt; Token 应该被保存起来（放到 local / session stograge 或者 cookies）在单页应用程序中，有些用户刷新浏览器后会带来一些跟 token 相关的问题。而解决方法很简单：你应该把 token 保存到起来：放到 session storage, local storage 或者是客户端的 cookie 里。而浏览器不支持 session storage 时都应该转存到 cookies 里。在这种情况下要把 cookie 当作一个储存机制，而不是一种验证机制。3&gt; 登录时有关token的操作3.1&gt; ajax请求login接口的时候，接口会返回token和refreshToken信息，存储到localStorage中1234567891011// ajax回调函数中：// data 为ajax请求回来的数据let token = { token: data.token, refreshToken: data.refreshToken,}; window.localStorage.setItem(&apos;admintoken&apos;, JSON.stringify(token));// JSON的一个常见用途是将数据与Web服务器进行交换。将数据发送到Web服务器时，数据必须是字符串。使用JSON.stringify（）将JavaScript对象转换为字符串。 utils.setCookie(&apos;haslogin&apos;,&apos;1&apos;); //登录成功 记录haslogin为1；用来router.js设置未登录或者登录未成功设置路由跳转到登录页 utils.setCookie(&apos;Token&apos;, token.token); 3.2&gt; 封装setCookie()此处有个时间转化的问题（待解决）Date的方法：例如当前时间为：2017/8/7 上午11:50:24toGMTString()：此日期会在转换为字符串之前由本地时区转换为 GMT 时区 Mon, 07 Aug 2017 03:50:24 GMT（实际已经被toUTCString转化），注意：不赞成使用此方法。在使用toGMTString时，最后会被toUTCString() 取而代之toUTCString()：会将日期用世界时表示，Mon, 07 Aug 2017 03:50:24 GMTtoLocaleString()：根据本地时间格式，把 Date 对象转换为字符串，转化为当前时间2017/8/7 上午11:50:241234567891011121314// expires 为token设置的过期时间setCookie: function (key, value, expires) { var cValue = key + &quot;=&quot; + value; if (expires) { cValue += &quot;;expires=&quot; + expires; } else { let exp = new Date() exp.setTime(exp.getTime() + 55 * 60 * 1000);// Date对象的getTime()方法可返回距 1970 年 1 月 1 日之间的毫秒数// exp.getTime() + 55 * 60 * 1000 是为了设置一个token的过期时间 cValue += &quot;;expires=&quot; + exp.toLocaleString(); } document.cookie = cValue; }, 3.3&gt; 在设置路由的时候，判断是否登录了，未登录或者登录未成功跳转登录页12345678910route.beforeEach((to, from, next)=&gt;{let loginInfo = utils.getCookie(&apos;haslogin&apos;); if(!loginInfo &amp;&amp; to.path !== &apos;/login&apos;){ return next({ name: &apos;login&apos;, // query: {redirect: to.fullPath} }) } next()}) 3.前端拦截token1234567891011121314151617// 登录路由设置个字段,用来记录是否已经登录path: &apos;/login&apos;, name:&apos;login&apos;, component: resolve =&gt; require([&apos;./login.vue&apos;], resolve), meta: { noCheckSession: true }// 路由拦截(router.js)route.beforeEach((to, from, next)=&gt;{ let loginInfo = utils.getCookie(&apos;haslogin&apos;); // 在登录成功的时候 接口返回token相关信息 将信息记录在cookie中 if(!loginInfo &amp;&amp; to.path !== &apos;/login&apos;){ return next({ name: &apos;login&apos;, // query: {redirect: to.fullPath} // 跳转到登录页面 }) } next()}) token cookie session 区别Local / session storage 不会跨域工作，请使用一个标记 cookie保存在 local / session storage 的 tokens，就不能从不同的域名中读取（甚至是子域名也不行）// Cookie的有效期操作 cookies 可以在浏览器关闭后删除（session cookies）； 通过绝对有效期或弹性有效期（sliding window expiration）； Cookies 可以通过携带有有效期地保存起来。","link":"/2017/01/03/token/"},{"title":"vue父子组件间数据传递","text":"vue父组件和子组件间怎么进行数据传递 ★ 父组件传递数据给子组件(可以通过props属性来实现)：由于组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的 props 选项；在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的 HTML 特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件：12345678910111213141516171819202122232425262728293031323334353637383940//父组件//引入的add-widget组件//使用 v-bind 的缩写语法通常更简单：&lt;add-widget :msg-val=&quot;msg&quot;&gt; //这里必须要用 - 代替驼峰// HTML 特性是不区分大小写的。所以，当使用的不是字符串模板，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名，当你使用的是字符串模板的时候，则没有这些限制 &lt;/add-widget&gt;data(){ return { msg: [1,2,3] };}//如果你想要用一个对象作为 props 传递所有的属性，你可以使用不带任何参数的 v-bind (即用 v-bind 替换掉 v-bind:prop-name)。例如，已知一个 todo 对象：todo: { text: &apos;Learn Vue&apos;, isComplete: false}//模板里：&lt;todo-item v-bind=&quot;todo&quot;&gt;&lt;/todo-item&gt;//等价于：&lt;todo-item v-bind:text=&quot;todo.text&quot; v-bind:is-complete=&quot;todo.isComplete&quot;&gt;&lt;/todo-item&gt;//子组件通过props来接收数据：//方式1：props: [&apos;msgVal&apos;]//方式2 :props: { msgVal: Array //这样可以指定传入的类型，如果类型不对，会警告}//方式3：props: { msgVal: { type: Array, //指定传入的类型 //type 也可以是一个自定义构造器函数，使用 instanceof 检测。 default: [0,0,0] //这样可以指定默认的值 }}//注意 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用 ★ 子组件与父组件通信//由于prop是单向数据传递的，为了防止子组件无意修改了父组件的状态，所以子组件想要给父组件传递数据，vue是不允许的，这时候我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的123456789//子组件:&lt;template&gt; &lt;div @click=&quot;up&quot;&gt;&lt;/div&gt;&lt;/template&gt;methods: { up() { this.$emit(&apos;upupEvent&apos;,&apos;hehe&apos;); //主动触发upupEvent方法，&apos;hehe&apos;为向父组件传递的数据 }}","link":"/2016/08/26/vue-component-params/"},{"title":"如何搭建vue项目","text":"如何搭建vue项目 开发环境要求1&gt; Node.js: javascript运行环境，不同系统不能直接运行各种编程语言;2&gt; npm: Node.js下的包管理器;3&gt; webpack: .vue的Vue组件 或者像 微信小程序的.wxml和.wxss等自定义的组件都无法被用户端的各种浏览器解析，需要被翻译和打包成.js文件;4&gt; vue-cli: Vue的脚手架工具，主要作用：目录结构、本地调试、代码部署、热加载、单元测试，相当于按照设计好的图来盖房子。 安装环境1&gt; 安装nodejsNode.js安装包及源码下载地址为：https://nodejs.org/en/download/Windows 安装包(.msi):32 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x86.msi64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi按照提示安装即可。node安装完成之后，自带npm★ 如果npm下载的慢，可以使用淘宝镜像：npm install -g cnpm –registry=https://registry.npm.taobao.org2&gt; vue的安装依赖于node.js，所以要先安装node.js再安装vue，此时npm 版本需要大于 3.0，如果低于此版本需要升级它 ，升级 npm: cnpm install npm -g；安装全局vue-cli脚手架,用于帮助搭建所需的模板框架：cnpm install -g vue-cli；或者在下载vue-cli的后面加上淘宝镜像：npm install -g vue-cli –registry=https://registry.npm.taobao.org；检查是否安装成功，在终端执行：vue；回车，如果出现vue信息说明安装成功，或者输入vue –version，返回版本号说明安装成功。3&gt; 此时环境已经搭建好了，下面用vue-cli构建项目在终端执行命令：// 创建一个基于webpack模板的新项目：vue init webpack my-project//命令执行后，会弹出以下配置信息：vue init webpack my-project //回车 ? Project name my-project//输入项目名字? Project description study vue//输入项目描述? Author niwei//作者? Vue build standalone ? Install vue-router? Yes//是否安装vue-router，对于单页应用,官方提供了vue-router进行路由跳转的处理? Use ESLint to lint your code? Yes//是否进行eslint代码检测，ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具? Pick an ESLint preset Standard//选择一个ESLint预设的标准? Setup unit tests with Karma + Mocha? Yes//是否单元测试? Setup e2e tests with Nightwatch? Yes// 是否端到端的测试 vue-cli · Generated “my-project”. To get started: cd my-project npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack // 进入到项目文件：cd my-project （和package.json文件同路径） // 根据package.json文件安装相应依赖： cnpm install 回车，发现文件下多了一个node_modules文件夹（里面就是安装的各种依赖） 检测环境是否搭建成功1&gt; 在终端执行： npm run dev 项目文件目录解析","link":"/2016/08/20/vue-create/"},{"title":"TypeScript学习之路","text":"万年不变的开头，TypeScript 慢慢学习之路 1. TypeScript的类型介绍JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types) 原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 BigInt 接下来一一介绍折几种类型在 TypeScript 中的应用: 布尔值§ 12// 布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：let isDone: boolean = false; 注意，使用构造函数 Boolean 创造的对象不是布尔值： 1234567let createdByNewBoolean: boolean = new Boolean(1);// 事实上 new Boolean() 返回的是一个 Boolean 对象let createdByBoolean: boolean = Boolean(1);// 直接调用 Boolean 也可以返回一个 boolean 类型 数值 123456// 使用 number 定义数值类型：let decLiteral: number = 6;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity;","link":"/2020/11/26/typescript/"},{"title":"TypeScript初体验","text":"万年不变的开头，TypeScript 慢慢学习之路 1. 什么是Typescript？说到 TypeScript 一定离不开我们非常熟悉的 JavaScript，先单纯从名字上看TypeScript，再看 ‘TypeScript’ - ‘type script’ - ‘type’，有没有发现type这个词很有意思，也就是”类型”的意思，TypeScript这样的命名也意味着 ts 是离不开”类型”这个词的，正如官网定义: Typed JavaScript at Any Scale.添加了类型系统的 JavaScript，适用于任何规模的项目。 这也带出了 TypeScript 的两个最重要的特性 —— 类型系统、适用于任何规模 2. Javascript和Typescripy的区别在类型系统的分类上看： 类型系统 按照「类型检查的时机」来分类，可以分为动态类型和静态类型。 JavaScript 是一门解释型语言，没有编译阶段，它就是一种动态类型，所以在代码运行时才会报错 而静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查，所以 TypeScript 是静态类型的 类型系统按照「是否允许隐式类型转换」来分类，可以分为强类型和弱类型： 12console.log(1 + &apos;1&apos;);// 打印出字符串 &apos;11&apos; 上面这段代码，用过js的小伙伴肯定都知道发生隐式类型转换之后，1 + ‘1’ 会变成 ‘11’，所以 js 是弱类型的。反看 TypeScript 它是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性，所以这段代码在 ts 中运行结果也是 ‘11’，所以 TypeScript 也是弱类型。 而TypeScript 不同于 JavaScript ，ts是支持强类型和静态类型的，也被称为 JavaScript 超集，它支持ES6语法，包含了 JavaScript 的所有元素，可以载入 JavaScript 代码运行，并扩展了 JavaScript 的语法，支持面向对象编程的概念，如类、接口、继承、泛型等。 接下来总结一下js 和 ts 区别: TypeScript 并不直接在浏览器上运行，而是需要编译器编译成纯 JavaScript 来运行。 TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。 TypeScript 代码可以在无需任何修改的情况下与 JavaScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。 TypeScript 通过类型注解提供编译时的静态类型检查。 TypeScript 中的数据要求带有明确的类型，JavaScript 不要求。 TypeScript 为函数提供了缺省参数值。 TypeScript 引入了 JavaScript 中没有的“类”概念。 TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。 下面通过表格更明显的来对比一下： TypeScript JavaScript 后缀名 .ts 后缀名 .js 支持ES6 不支持ES6 支持强类型和静态类型 不支持强类型和静态类型 编译时报错 运行时报错 支持面向对象编程概率，如接口、继承、类、泛型等 是一种脚本语言 支持模块 不支持模块 支持泛型 不支持泛型 不支持在浏览器端运行，需要编译成js 支持在浏览器端运行 3. 环境搭建了解了大概什么是ts之后，下面就实际操作试一下 因为 TypeScript 需要编译为 JavaScript 才能运行，所以需要Node环境的支持，在编译前请保证你本地已经安装 Node 运行环境 有两种主要的方式来获取TypeScript工具： 通过npm（Node.js包管理器） 123npm install typescript -g# ORyarn global add typescript 安装Visual Studio的TypeScript插件 查看TypeScript版本: 1tsc --version 4. TypeScript 初体验安装了ts之后来初体验一下，构建你的第一个ts文件: 在一个目录下，利用 touch 命令创建一个ts文件1touch demo.ts 然后将下面这段代码，复制进去，聪明的你一定看出来这不就是 js 嘛，对的，就是 js 代码，现在只是想让你初体验一下 ts 编译1234567function greeter(person) { return &quot;Hello, &quot; + person;}const user = &quot;Jane User&quot;;document.body.innerHTML = greeter(user); 编译代码，在命令行上，运行TypeScript编译器：1tsc greeter.ts 输出结果为一个 greeter.js 文件，内容和我们之前输入的一样（因为原来就是 js 编写的），现在我们就利用 ts 改写一下 我们利用 ts 提供的 类型注解（是一种轻量级的为函数或变量添加约束的方式） 来给 person 函数的参数添加: string 类型注解，如下： 1234567function greeter(person: string) { return &quot;Hello, &quot; + person}const user = &quot;Jane User&quot;document.body.innerHTML = greeter(user) 这意味着 greeter 函数的 person 参数只能接收 string 类型的参数，而且是必传参数，如果传入其他类型或者不传参数就会报错，如果想要改为可选参数，冒号前添加一个问号，则表明该参数是可选的，所以可以写成这样： 123function greeter(person?: string) { return &quot;Hello, &quot; + person} 要注意的是尽管有错误，greeter.js 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行 有小伙伴可能会问，如果我要传入的参数不是一个基本数据类型，如果是一个对象怎么办？ 这就要用到 ts 的另一个概念 - 接口（接口是一系列抽象方法的声明，是一些方法特征的集合）： 12345678910111213141516// 使用接口来描述一个拥有 firstName 和 lastName 字段的对象interface Person { firstName: string; lastName: string;}function greeter(person: Person) { return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;}// 赋值的时候，变量的形状必须和接口的形状保持一致const user = { firstName: &quot;Jane&quot;, lastName: &quot;User&quot; };document.body.innerHTML = greeter(user); interface 是仅存在于TS上下文中的一种虚拟结构，TS编译器依赖接口用于类型检查，最终编译为JS后，接口将会被移除，它只是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement） 与其他语言相比，JS并没有直接对类的描述，只有基于原型的继承方式，一直到了ES6，class 关键字作为一种语法糖出现，而 TypeScript 是面向对象的 JavaScript，也就支持面向对象的所有特性，比如 类、接口等 TypeScript 类定义方式如下： 123class class_name { // 类作用域} 与 interface 不同，class 作为TS的一种变量类型存在于上下文之中，class 中可以提供，变量、方法等的具体实现方式等，它的作用不仅仅是约束数据结构 最后，让我们使用类来改写这个例子: 12345678910111213141516171819202122// 注意类和接口可以一起共作，我们可以自行决定抽象的级别interface Person { firstName: string; lastName: string;}class Student { fullName: string; // 在构造函数的参数上使用public等同于创建了同名的成员变量 constructor(public firstName, public middleInitial, public lastName) { this.fullName = firstName + &quot; &quot; + middleInitial + &quot; &quot; + lastName; }}function greeter(person: Person) { return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;}const user = new Student(&quot;Jane&quot;, &quot;M.&quot;, &quot;User&quot;);document.body.innerHTML = greeter(user); 接下来我们来实际运行一下： 使用命令 mkdir 在终端创建一个 demo 文件夹 1mkdir demo cd 到 demo 文件目录下： 1cd demo 然后利用命令 touch 在终端创建一个 greeter.ts 文件以及一个 index.html 文件 123touch greeter.tstouch index.html 这样我们就在 demo 文件目录下，创建了两个文件，分别是 greeter.ts 和 index.html 将我们刚才的代码复制到 greeter.ts 文件中 要想 greeter.ts 运行起来，我们需要先编译 ts 文件为 js 文件，然后通过 html 文件引用，在浏览器端运行 利用 tsc 编译 ts 文件为 js 文件1tsc greeter.ts 编译完成，我们会在 demo 文件目录下发现 多了一个 greeter.js 文件，然后我们在 html 文件中引用 编译后的 greeter.js 文件： 1234567891011121314var Student = /** @class */ (function () { function Student(firstName, middleInitial, lastName) { this.firstName = firstName; this.middleInitial = middleInitial; this.lastName = lastName; this.fullName = firstName + &quot; &quot; + middleInitial + &quot; &quot; + lastName; } return Student;}());function greeter(person) { return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;}var user = new Student(&quot;Jane&quot;, &quot;M.&quot;, &quot;User&quot;);document.body.innerHTML = greeter(user); index.html 文件： 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;TypeScript Greeter&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;script src=&quot;greeter.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然后我们将 html 文件用浏览器打开，看到页面出现 “Hello, Jane User”","link":"/2020/11/15/ts-init/"},{"title":"Vue学习笔记","text":"Vue入门学习笔记 学习过程中整理,参考网址https://segmentfault.com/a/1190000008879966官网地址：https://cn.vuejs.org/ 1.vue 生命周期 所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同， this.fetchTodos 的行为未定义。 1.1生命周期概总： 根组件实例：8个 (beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed)组件实例：8个 (beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed)全局路由钩子：2个 (beforeEach、afterEach)组件路由钩子：3个 (beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave)指令的周期： 5个 (bind、inserted、update、componentUpdated、unbind)beforeRouteEnter的next所对应的周期nextTick所对应的周期1.2生命周期详解生命周期图示： 组件实例周期:1&gt; beforeCreate:在vue实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用，页面初始化数据加载一般写这里。此时组件的选项还未挂载，因此无法访问methods，data,computed上的方法或数据。 2&gt; created():vue实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见，所以如果涉及操作dom对象的方法不适合写在这里。你可以在这里调用methods中的方法、改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上、获取computed中的计算属性等等。通常我们可以在这里对实例进行预处理。在这里也可以发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的。因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个页面发请求。建议在组件路由勾子beforeRouteEnter中来完成。 3&gt; beforeMonut:在挂载开始之前被调用，相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。开始挂载编译生成的HTML到对应位置时触发。vue 已经绑定到元素身上，但是还没把数据同步给相应的元素 4&gt; mounted():在这个周期内，对data的改变可以生效，可以获取dom元素，但是要进下一轮的dom更新，dom上的数据才会更新。该钩子在服务器端渲染期间不被调用。beforeRouteEnter的next的钩子比mounted触发还要靠后，指令的生效在mounted周期之前。 5&gt;beforeUpdate():数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 6&gt;updated():由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态(？)。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。该钩子在服务器端渲染期间不被调用。 7&gt;beforeDestroy():实例销毁之前调用。在这一步，实例仍然完全可用，还可以用this来获取实例，一般在这一步做一些重置的操作。比如清除掉组件中的定时器和监听的dom事件。该钩子在服务器端渲染期间不被调用。 8&gt;destroyed():Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 全局路由钩子:作用于所有路由切换，一般在main.js里面定义。1&gt;router.beforeEach():12345//示例：router.beforeEach((to, from, next) =&gt; { console.log(&apos;路由全局勾子：beforeEach -- 有next方法&apos;) next()}) 一般在这个勾子的回调中，对路由进行拦截。比如，未登录的用户（或者是未绑定手机号的用户），直接进入了需要登录才可进的页面，那么可以用next(false)来拦截，使其跳回原页面或者跳到登录页，值得注意的是，如果没有调用next方法，那么页面将卡在那。 next的四种用法：1.next() 跳入下一个页面2.next(‘/path’) 改变路由的跳转方向，使其跳到另一个路由3.next(false) 返回原来的页面4.next((vm)=&gt;{}) 仅在beforeRouteEnter中可用，vm是组件实例。 2&gt; router.afterEach():1234//示例router.afterEach((to, from) =&gt; { console.log(&apos;路由全局勾子：afterEach --- 没有next方法&apos;)}) 在所有路由跳转结束的时候调用，和beforeEach是类似的，但是它没有next方法。 组件路由钩子:和全局钩子不同的是，它仅仅作用于某个组件，一般在.vue文件中去定义。1&gt;beforeRouteEnter:123456789//示例 beforeRouteEnter (to, from, next) { console.log(this) //undefined，不能用this来获取vue实例 next(vm =&gt; { console.log(vm) //vm为vue的实例 console.log(&apos;组件路由勾子beforeRouteEnter的next&apos;)//这个里面的代码是很晚执行的，在组件mounted周期之后,beforeRouteEnter的代码很早执行的，在组件beforeCreate之前；但是next里面回调的执行，很晚，在mounted之后，可以说是离dom渲染最近的一个周期。 }) } beforeRouterEnter在组件创建之前调用，所以它无法直接用this来访问组件实例。但是可以给next传一个回调，回调的第一个参数即是组件实例，可以利用这点，对实例上的数据进行修改，调用实例上的方法。可以在这个方法去请求数据，在数据获取到之后，再调用next就能保证进页面的时候，数据已经获取到了。没错，这里next有阻塞的效果。你没调用的话，就会一直卡在那。 3&gt;beforeRouteLeave:1234beforeRouteLeave (to, from, next) { console.log(this) //可以访问vue实例 next();}, 在离开路由时调用。可以用this来访问组件实例。但是next中不能传回调。4&gt;beforeRouteUpdate:123456beforeRouteUpdate (to, from, next) { // 在当前路由改变，但是改组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候调用， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` } 这个方法是vue-router2.2版本加上的。因为原来的版本中，如果一个在两个子路由之间跳转，是不触发beforeRouteLeave的。这会导致某些重置操作，没地方触发。在之前，我们都是用watch $route来hack的。 自定义指令的钩子函数：绑定自定义指令的时候也会有对应的周期。1&gt;bind:只调用一次，指令第一次绑定到元素时调用。用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 2&gt;inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在document 中）实际上是插入vnode的时候调用。 3&gt;update:所在组件的 VNode 更新时调用，但是可能发生在其孩子的 VNode 更新之前，（被绑定元素所在的模板更新时调用），不论指令的值（绑定值）是否变化。通过比较更新前后的值来忽略不必要的模板更新 。注意，如果在指令里绑定事件，并且用这个周期的，记得把事件注销。 4&gt;componentUpdated:所在组件的 VNode 更新时调用，但是可能发生在其孩子的 VNode 更新之前。被绑元素所在模板完成一次更新周期时调用。 5&gt;unbind:只调用一次，指令与元素解绑时调用。 Vue.nextTick、vm.$nextTick:1234567//示例： created () { this.$nextTick(() =&gt; { console.log(&apos;nextTick&apos;) //回调里的函数一直到真实的dom渲染结束后，才执行 }) console.log(&apos;组件：created&apos;) }, nextTick方法的回调会在dom更新后再执行，因此可以和一些dom操作搭配一起用，如 ref。 应用场景：你用ref获得一个输入框，用v-model绑定。在某个方法里改变绑定的值，在这个方法里用ref去获取dom并取值，你会发现dom的值并没有改变。因为此时vue的方法，还没去触发dom的改变。因此你可以把获取dom值的操作放在vm.$nextTick的回调里，就可以了。 VNode图示： VNode可以理解为vue框架的虚拟dom的基类，通过new实例化的VNode大致可以分为几类:EmptyVNode: 没有内容的注释节点TextVNode: 文本节点ElementVNode: 普通元素节点ComponentVNode: 组件节点CloneVNode: 克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true… 2.vue-cli脚手架2.1 安装vue-cli1&gt;在终端执行: npm install -g vue-cli;2&gt;安装完成之后创建自己的项目:1vue init &lt;template-name&gt; &lt;project-name&gt; 例如：vue init webpack myProject 会提示创建的项目名字，作者，是否需要安装vur-router等 根据自己需求而定3&gt;创建完成后，到新建的项目文件中 cd myProject; 下载所有需要的依赖：npm install; 依赖安装好后；就可以运行项目了：npm run dev其实npm run dev执行的是package.json文件里的这段命令中的’dev’：12345&quot;scripts&quot;: { &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;start&quot;: &quot;node build/dev-server.js&quot;, &quot;build&quot;: &quot;node build/build.js&quot; }, 3.学习如何搭建一个项目3.1 搭建项目目录结构 安装依赖1&gt;新建文件夹demo后，cd demo;2&gt;执行npm init -y 会在该文件夹下面生成一个package.json文件;3&gt;然后可以执行npm install &lt;依赖&gt; –save-dev;4&gt;在demo文件下新建一个src文件夹和一个index.html文件；1234index.html: &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt; 5&gt;在src文件夹下新建app.vue文件、入口js文件main.js、components文件等;app.vue:1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h1&gt;vue学习之路&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: &apos;&apos;, data (){ return {} }, components: { // 加载的各种组件 }, mounted (){ // 钩子函数 }, methods: { // 各种方法 }, computed: { // 计算值 } }&lt;/script&gt;&lt;style lang=&quot;css&quot;&gt;&lt;/style&gt; 123456789//main.js:import Vue from &apos;vue&apos;import App from &apos;./App&apos;-&gt; app.vue文件的路径// 创建一个vue实例 注意大小写 new Vuenew Vue({ el: &apos;#app&apos;, template: &apos;&lt;App/&gt;&apos;, components: {App}}) 关于组建的学习在后面3.2 配置webpack1&gt;在demo文件下面新建一个build文件夹;2&gt;在build文件下新建一个webpack.base.cont.js文件123456789101112131415161718192021222324252627282930313233343536373839&apos;user strict&apos;;const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = { entry: &apos;entry&apos;, // entry就是入口文件 制定main.js为入口js,就是entry: &apos;main.js的路径&apos;, output: { // 一些输出配置 path: path.resolve(_dirname, &apos;outputPath&apos;), firename: &apos;firename&apos;, // 例如 &apos;[name].[hash:8].js&apos; publicPath: &apos;path&apos;, // 例如&apos;static/&apos;&apos; }, module: { rules: { // 就是解析模块的一些规则 { test: /\\.vue$/, loader: &apos;vue-loader&apos;, //使用vue-loader解析.vue的文件 }, { test: /\\.js$/, loader: &apos;babel-loader?presets=es2015&apos;,//使用babel-loader解析.js的文件 exclude: /node_modules/ } } }, resolve: { extensions:[&apos;.js&apos;,&apos;.vue&apos;], alias:{ &apos;vue$&apos;:&apos;vue/dist/vue.esm.js&apos; } }, plugins: { new HtmlWebpackPlugin({ firename: &apos;index.html&apos;, template: path.resolve(__dirname,&apos;../index.html&apos;) }) }} 3&gt;配置好webpack.base.cont.js文件后，在终端执行webpack –config/webpack.base.cont.js 命令；在相应文件下会生成解析好的文件；但是每次文件不能做到实时编译4.实时编译 5 总结一些vue知识1&gt;阻止事件冒泡：1@clcik.stop=&quot;&quot; (vue提供)| event.cancelBubble = true(事件对象event自带) 2&gt;阻止默认事件 : 例如@contextmenu 浏览器会弹出操作菜单 @contextmenu.prevent=”” (vue提供) | event.preventDefault() (事件对象event自带)click.prevent()=”clcikFun()” 注意在使用event时，@click=”fun(\\$event)”,传入$event。 3&gt;:class和:style:class=”[‘blue’]”； :style=”[‘margin’: 20 + ‘px’]”或者:style=”json格式的值”:style 使用复合样式时，使用驼峰命名 7 vue遍历问题由于 JavaScript 的限制， Vue 不能检测以下变动的数组：12// 当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue// 当你修改数组的长度时，例如： vm.items.length = newLength [] instanceof(Array) = truearray.constructor == Array★ 需要了解的是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：1234567// Vue.set （可以设置某个值也能让对象添加属性）：// Vue 指全局的vue实例，在使用的时候 用import先引用vue；// indexOfItem指index 如果是对象，存在key值 则indexOfItem可以用key代替;// example1.items 指 Object | ArrayVue.set(example1.items, indexOfItem, newValue) // Array.prototype.spliceexample1.items.splice(indexOfItem, 1, newValue) 1234567891011121314151617181920212223&lt;body&gt; &lt;ul&gt; &lt;li v-for=&quot;item in arr&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue({ data (){ arr: [&apos;aaa&apos;,&apos;bbb&apos;,&apos;ccc&apos;], obj: { &apos;aaa&apos;: 111, &apos;bbb&apos;: 222, &apos;ccc&apos;: 333 } } }) vm.arr[0] = &apos;ddd&apos;; // 不会触发视图更新 Vue.set(this.arr,0,&apos;ddd&apos;); // 会触发视图更新 vm.$set(this.arr,0,&apos;ddd&apos;); // 会触发视图更新 // 如果使用局部实例vm Vue.set(this.obj,&apos;aaa&apos;,444); // 会触发视图更新 vm.$set(this.obj,&apos;aaa&apos;,444); // 会触发视图更新&lt;/script&gt; 如果属性是js动态添加的，set改变后，视图不会更新问题123456789101112131415161718&lt;script&gt; export default { name: &apos;&apos;, data (){ obj: {} }, methods: { changeProp (){ this.obj.aaa = 222; //视图不会更新为222，依然还是111 }, addProp (){ this.obj.aaa = 111; // js动态添加上一个aaa的属性 } } }&lt;/script&gt;``` 解决方案： // 1/ 改变完 值之后 改变一下对象 changeProp (){ vm.$set(this.obj,’aaa’,222); //视图不会更新为222，依然还是111 }, addProp (){ this.obj.aaa = 111; }// 2/添加属性的时候 通过vm.$set()添加,改变时 通过vm.$set()改变methods: { changeProp (){ vm.$set(this.obj,’aaa’,222); //视图不会更新为222，依然还是111 }, addProp (){ this.obj.aaa = ‘111’; // 通过.的方式加载属性在obj对象上 vm.$set(this.obj,’aaa’,111); }} `","link":"/2016/08/25/vue-init/"},{"title":"uni-app开发学习之路","text":"uni-app入门学习 什么是uni-appuni-app是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。 uni-app在手，做啥都不愁。即使不跨端，uni-app也是更好的小程序开发框架（详见）、更好的App跨平台框架、更方便的H5开发框架。不管领导安排什么样的项目，你都可以快速交付，不需要转换开发思维、不需要更改开发习惯。 有关：uni-app的由来 uni-app: 如何学习 uni-app: 插件市场 更多介绍请关注：uni-app官网 快速体验代码示例学习参考：Github示例代码一套代码编到10个平台，这不是梦想。眼见为实，扫描10个二维码，亲自体验最全面的跨平台效果！ 框架简介 先了解一下项目目录结构： Tips: static 目录下的 js 文件不会被编译，如果里面有 es6 的代码，不经过转换直接运行，在手机设备上会报错。 css、less/scss 等资源同样不要放在 static 目录下，建议这些公用的资源放在 common 目录下 生— title: uni-app开发学习之路 date: 2020-10-16 15:54:46 description: uni-app categories: uni-apptags: uni-apptoc: true 文章目录 uni-app入门学习 什么是uni-appuni-app是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。 uni-app在手，做啥都不愁。即使不跨端，uni-app也是更好的小程序开发框架（详见）、更好的App跨平台框架、更方便的H5开发框架。不管领导安排什么样的项目，你都可以快速交付，不需要转换开发思维、不需要更改开发习惯。 有关：uni-app的由来 uni-app: 如何学习 uni-app: 插件市场 更多介绍请关注：uni-app官网 快速体验代码示例学习参考：Github示例代码一套代码编到10个平台，这不是梦想。眼见为实，扫描10个二维码，亲自体验最全面的跨平台效果！ 框架简介 先了解一下项目目录结构： Tips: static 目录下的 js 文件不会被编译，如果里面有 es6 的代码，不经过转换直接运行，在手机设备上会报错。 css、less/scss 等资源同样不要放在 static 目录下，建议这些公用的资源放在 common 目录下 生命周期 应用生命周期 =&gt; uni-app 支持如下应用生命周期函数： | 函数名 | 说明 || —- | —- || onLaunch | 当 uni-app 初始化完成时触发（全局只触发一次）|| onShow | 当 uni-app 启动，或从后台进入前台显示 || onHide | 当 uni-app 从前台进入后台 || onError | 当 uni-app 报错时触发 || onUniNViewMessage | 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 || onUnhandledRejection | 对未处理的 Promise 拒绝事件监听函数（2.8.1+）|| onPageNotFound | 页面不存在监听函数 || onThemeChange | 监听系统主题变化 | 注意： 应用生命周期仅可在App.vue中监听，在其它页面监听无效。 onlaunch里进行页面跳转，如遇白屏报错，请参考 页面生命周期uni-app 支持如下页面生命周期函数： | 函数名 | 说明 || — | —– || onLoad | 监听页面加载，其参数为上个页面传递的数据，参数类型为Object(用于页面传参) || onShow | 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 || onReady | 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 || onHide | 监听页面隐藏 || onUnload | 监听页面卸载 || onResize | 监听窗口尺寸变化 || onPullDownRefresh | 监听用户下拉动作，一般用于下拉刷新 || onReachBottom | 页面上拉触底事件的处理函数 || onTabItemTap | 点击 tab 时触发，参数为Object，具体见下方注意事项 || onShareAppMessage | 用户点击右上角分享 || onPageScroll | 监听页面滚动，参数为Object || onNavigationBarButtonTap | 监听原生标题栏按钮点击事件，参数为Object || onBackPress | 监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack || onNavigationBarSearchInputChanged | 监听原生标题栏搜索输入框输入内容变化事件 || onNavigationBarSearchInputConfirmed | 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发 || onNavigationBarSearchInputClicked | 监听原生标题栏搜索输入框点击事件 || onShareTimeline | 监听用户点击右上角转发到朋友圈 || onAddToFavorites | 监听用户点击右上角收藏 | 快速上手关于如何学习uni-app，可以参考官网uni-app学习指引，里面还有官方视频教学，方便大家快速上手学习 uni-app支持通过可视化界面、vue-cli命令行 两种方式快速创建项目。 通过 HBuilderX 可视化界面创建项目可视化的方式比较简单，HBuilderX内置相关环境，开箱即用，无需配置nodejs。 开始之前，开发者需先下载安装 HBuilderX 工具：HBuilderX 官方IDE下载地址 HBuilderX是通用的前端开发工具，但为uni-app做了特别强化，对vue支持也很强大。 下载App开发版，可开箱即用；如下载标准版，在运行或发行uni-app时，会提示安装uni-app插件，插件下载完成后方可使用。如使用cli方式创建项目，可直接下载标准版，因为uni-app编译插件被安装到项目下了 ##### 1. 创建项目：在点击工具栏里的文件 -&gt; 新建 -&gt; 项目 这时会弹出一个新建项目的弹窗，如下图所示： ![](/images/uni-app-create.png) 继续选择 `uni-app` 类型，输入项目名称，选择模板，点击创建，即可成功创建。 uni-app 自带的模板有 Hello uni-app ，是官方的组件和API示例。还有一个重要模板是 `uni ui` 项目模板，日常开发推荐使用该模板，已内置大量常用组件。 ##### 2. 运行uni-app项目 进入hello-uniapp项目，点击工具栏的运行，如下图所示： ![](/images/uni-app-start.png) - 浏览器运行：点击工具栏的运行 -&gt; 运行到浏览器 -&gt; 选择浏览器，即可在浏览器里面体验uni-app 的 H5 版。 - 真机运行：连接手机，开启USB调试，点击工具栏的运行 -&gt; 真机运行 -&gt; 选择运行的设备，即可在该设备里面体验uni-app。 - 在微信开发者工具里运行：点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app。 如果是第一次使用，需要先配置小程序ide的相关路径，才能运行成功。以微信开发者工具为例，如下图所示: ![](/images/ide-source.png) 需在输入框输入微信开发者工具的安装路径： ![](/images/wechat-ide-source.png) 若HBuilderX不能正常启动微信开发者工具，可以在微信开发者工具中菜单栏查看：设置-&gt;安全设置，如图所示： ![](/images/wx-safety-setting.png) 查看微信开发者工具的服务端口是否打开，如果没有，将服务端口打开： ![](/images/wx-port-setting.png) 如果HBuilderX仍然不能正常启动微信开发者工具，需要开发者手动启动，然后将uni-app生成小程序工程的路径拷贝到微信开发者工具里面，在HBuilderX里面开发，在微信开发者工具里面就可看到实时的效果 Tips: - 如果是第一次使用，需要配置开发工具的相关路径。点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 运行设置，配置相应小程序开发者工具的路径。 - 支付宝/百度/字节跳动/360小程序工具，不支持直接指定项目启动并运行。因此开发工具启动后，请将 HBuilderX 控制台中提示的项目路径，在相应小程序开发者工具中打开。 - 如果自动启动小程序开发工具失败，请手动启动小程序开发工具并将 HBuilderX 控制台提示的项目路径，打开项目。 ##### 3. 发布uni-app - 打包为原生App（云端） 在HBuilderX工具栏，点击发行，选择原生app-云端打包，如下图： ![](/images/release-demo.png) - 打包为原生App（离线） `uni-app` 支持离线打包，在 HBuilderX 发行菜单里生成离线打包资源，然后参考离线打包文档操作，可以从HBuilderX的发行菜单里找到[文档链接](https://nativesupport.dcloud.net.cn/AppDocs/README)。 在HBuilderX工具栏，点击发行，选择本地打包，如下图，点击即可生成本地打包APP资源： ![](/images/local-release.png) - 发布为H5 在 `manifest.json` 的可视化界面，进行如下配置（发行在网站根目录可不配置应用基本路径），此时发行网站路径是 `www.xxx.com/h5` ![](/images/h5-release.png) 在HBuilderX工具栏，点击发行，选择网站-H5手机版，点击即可生成 H5 的相关资源文件，保存于 unpackage 目录。 - 发布为小程序 申请微信小程序AppID，参考：[微信教程](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/getstart.html#%E7%94%B3%E8%AF%B7%E5%B8%90%E5%8F%B7) 在HBuilderX中顶部菜单依次点击 &quot;发行&quot; =&gt; &quot;小程序-微信&quot;，输入小程序名称和appid点击发行即可在 `unpackage/dist/build/mp-weixin` 生成微信小程序项目代码。 ![](/images/wx-release.png) 在微信小程序开发者工具中，导入生成的微信小程序项目，测试项目代码运行正常后，点击“上传”按钮，之后按照 “提交审核” =&gt; “发布” 小程序标准流程，逐步操作即可，详细查看：[微信官方教程](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#%E5%8F%91%E5%B8%83%E4%B8%8A%E7%BA%BF) 其他小程序的发布请参见[官网教程](https://uniapp.dcloud.io/quickstart?id=%e5%8f%91%e5%b8%83uni-app) #### 通过vue-cli命令行 除了HBuilderX可视化界面，也可以使用 `cli` 脚手架，可以通过 `vue-cli` 创建 `uni-app` 项目。 环境安装 - 全局安装vue-cli 1npm install -g @vue/cli 创建uni-app 12345使用正式版（对应HBuilderX最新正式版）:vue create -p dcloudio/uni-preset-vue my-project使用alpha版（对应HBuilderX最新alpha版）:vue create -p dcloudio/uni-preset-vue#alpha my-alpha-project 此时，会提示选择项目模板，初次体验建议选择 hello uni-app 项目模板，如下所示： ![](/images/template-demo.png) 运行、发布uni-app 12npm run dev:%PLATFORM%npm run build:%PLATFORM% 更多平台的运行和发布请参见[官网教程](https://uniapp.dcloud.io/quickstart?id=quickapp) 命周期 应用生命周期 =&gt; uni-app 支持如下应用生命周期函数： 函数名 说明 onLaunch 当 uni-app 初始化完成时触发（全局只触发一次） onShow 当 uni-app 启动，或从后台进入前台显示 onHide 当 uni-app 从前台进入后台 onError 当 uni-app 报错时触发 onUniNViewMessage 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 onUnhandledRejection 对未处理的 Promise 拒绝事件监听函数（2.8.1+） onPageNotFound 页面不存在监听函数 onThemeChange 监听系统主题变化 注意： 应用生命周期仅可在App.vue中监听，在其它页面监听无效。 onlaunch里进行页面跳转，如遇白屏报错，请参考 页面生命周期uni-app 支持如下页面生命周期函数： 函数名 说明 onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为Object(用于页面传参) onShow 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 onReady 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 onHide 监听页面隐藏 onUnload 监听页面卸载 onResize 监听窗口尺寸变化 onPullDownRefresh 监听用户下拉动作，一般用于下拉刷新 onReachBottom 页面上拉触底事件的处理函数 onTabItemTap 点击 tab 时触发，参数为Object，具体见下方注意事项 onShareAppMessage 用户点击右上角分享 onPageScroll 监听页面滚动，参数为Object onNavigationBarButtonTap 监听原生标题栏按钮点击事件，参数为Object onBackPress 监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack onNavigationBarSearchInputChanged 监听原生标题栏搜索输入框输入内容变化事件 onNavigationBarSearchInputConfirmed 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发 onNavigationBarSearchInputClicked 监听原生标题栏搜索输入框点击事件 onShareTimeline 监听用户点击右上角转发到朋友圈 onAddToFavorites 监听用户点击右上角收藏 快速上手关于如何学习uni-app，可以参考官网uni-app学习指引，里面还有官方视频教学，方便大家快速上手学习 uni-app支持通过可视化界面、vue-cli命令行 两种方式快速创建项目。 通过 HBuilderX 可视化界面创建项目可视化的方式比较简单，HBuilderX内置相关环境，开箱即用，无需配置nodejs。 开始之前，开发者需先下载安装 HBuilderX 工具：HBuilderX 官方IDE下载地址 HBuilderX是通用的前端开发工具，但为uni-app做了特别强化，对vue支持也很强大。 下载App开发版，可开箱即用；如下载标准版，在运行或发行uni-app时，会提示安装uni-app插件，插件下载完成后方可使用。如使用cli方式创建项目，可直接下载标准版，因为uni-app编译插件被安装到项目下了 1. 创建项目：在点击工具栏里的文件 -&gt; 新建 -&gt; 项目这时会弹出一个新建项目的弹窗，如下图所示： 继续选择 uni-app 类型，输入项目名称，选择模板，点击创建，即可成功创建。 uni-app 自带的模板有 Hello uni-app ，是官方的组件和API示例。还有一个重要模板是 uni ui 项目模板，日常开发推荐使用该模板，已内置大量常用组件。 2. 运行uni-app项目进入hello-uniapp项目，点击工具栏的运行，如下图所示： 浏览器运行：点击工具栏的运行 -&gt; 运行到浏览器 -&gt; 选择浏览器，即可在浏览器里面体验uni-app 的 H5 版。 真机运行：连接手机，开启USB调试，点击工具栏的运行 -&gt; 真机运行 -&gt; 选择运行的设备，即可在该设备里面体验uni-app。 在微信开发者工具里运行：点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app。 如果是第一次使用，需要先配置小程序ide的相关路径，才能运行成功。以微信开发者工具为例，如下图所示: 需在输入框输入微信开发者工具的安装路径： 若HBuilderX不能正常启动微信开发者工具，可以在微信开发者工具中菜单栏查看：设置-&gt;安全设置，如图所示： 查看微信开发者工具的服务端口是否打开，如果没有，将服务端口打开： 如果HBuilderX仍然不能正常启动微信开发者工具，需要开发者手动启动，然后将uni-app生成小程序工程的路径拷贝到微信开发者工具里面，在HBuilderX里面开发，在微信开发者工具里面就可看到实时的效果 Tips: 如果是第一次使用，需要配置开发工具的相关路径。点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 运行设置，配置相应小程序开发者工具的路径。 支付宝/百度/字节跳动/360小程序工具，不支持直接指定项目启动并运行。因此开发工具启动后，请将 HBuilderX 控制台中提示的项目路径，在相应小程序开发者工具中打开。 如果自动启动小程序开发工具失败，请手动启动小程序开发工具并将 HBuilderX 控制台提示的项目路径，打开项目。 3. 发布uni-app 打包为原生App（云端） 在HBuilderX工具栏，点击发行，选择原生app-云端打包，如下图： 打包为原生App（离线） uni-app 支持离线打包，在 HBuilderX 发行菜单里生成离线打包资源，然后参考离线打包文档操作，可以从HBuilderX的发行菜单里找到文档链接。 在HBuilderX工具栏，点击发行，选择本地打包，如下图，点击即可生成本地打包APP资源： 发布为H5 在 manifest.json 的可视化界面，进行如下配置（发行在网站根目录可不配置应用基本路径），此时发行网站路径是 www.xxx.com/h5 在HBuilderX工具栏，点击发行，选择网站-H5手机版，点击即可生成 H5 的相关资源文件，保存于 unpackage 目录。 发布为小程序 申请微信小程序AppID，参考：微信教程在HBuilderX中顶部菜单依次点击 “发行” =&gt; “小程序-微信”，输入小程序名称和appid点击发行即可在 unpackage/dist/build/mp-weixin 生成微信小程序项目代码。 在微信小程序开发者工具中，导入生成的微信小程序项目，测试项目代码运行正常后，点击“上传”按钮，之后按照 “提交审核” =&gt; “发布” 小程序标准流程，逐步操作即可，详细查看：微信官方教程 其他小程序的发布请参见官网教程 通过vue-cli命令行除了HBuilderX可视化界面，也可以使用 cli 脚手架，可以通过 vue-cli 创建 uni-app 项目。 环境安装 - 全局安装vue-cli 1npm install -g @vue/cli 创建uni-app 12345使用正式版（对应HBuilderX最新正式版）:vue create -p dcloudio/uni-preset-vue my-project使用alpha版（对应HBuilderX最新alpha版）:vue create -p dcloudio/uni-preset-vue#alpha my-alpha-project 此时，会提示选择项目模板，初次体验建议选择 hello uni-app 项目模板，如下所示： 运行、发布uni-app 12npm run dev:%PLATFORM%npm run build:%PLATFORM% 更多平台的运行和发布请参见官网教程","link":"/2020/10/16/uni-app/"},{"title":"Vue利用keepAlive实现页面缓存","text":"keepAlive + vuex 写在前面在自己做项目的过程当中，遇到这样的需求：当从列表页进入详情页，再返回到列表页的时候，保存列表页进入详情页之前的分页数据、筛选数据等，这样可以提高用户体验 起初我是利用h5的localStorage进行存储的，进入详情页之前，在localStorage保存列表页数据，后来觉得这个方法一点也不高大上，便查阅了以下资料： 在Vue中，对于这种“页面缓存”的需求，我们可以使用keep-alive组件来解决 什么是 keep-alive在Vue构建的单页面应用（SPA）中，路由模块一般使用vue-router。vue-router不保存被切换组件的状态，它进行push或者replace时，旧组件会被销毁，而新组件会被新建，走一遍完整的生命周期, 而 keep-alive 可以使被包含的组件状态维持不变，即便是组件切换了，其内的状态依旧维持在内存之中。在下一次显示时，也不会重现渲染 &lt;keep-alive&gt; 与 &lt;transition&gt; 相似，只是一个抽象组件，它不会在DOM树中渲染(真实或者虚拟都不会)，也不在父组件链中存在，比如：你永远在 this.$parent 中找不到 keep-alive props： include: 字符串或正则表达式。只有匹配的组件会被缓存。 exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。 用法在 route 表里面设置 meta.keepAlive 用来标记哪些是需要缓存的页面 1234567891011121314151617// router.js:export const routers = [ { path: 'list', name: 'list', component: List, meta: { keepAlive: true } }, { path: 'list/:id', name: 'listDetail', component: listDetail, meta: {} }] 12345// App.vue:&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 有人这样处理，但是我这样使用了之后，还是有很多漏洞，比如：从不需要缓存的页面到需要缓存的列表页（这时候$route.meta.keepAlive是false），进入列表详情页，再回来第一次并不会缓存（因为进入之前是false 所以没有缓存），再进入详情页才可以（此时$route.meta.keepAlive才是true）等问题 上面这种方案我没有成功，有兴趣的朋友可以试试 所以我接着查阅发现下面这种方案，&lt;keep-alive&gt; 结合 vuex 状态存储 在 router 表里定义 meta.keepAlive 标记需要缓存的页面 在 App.vue 页面，利用 &lt;keep-alive&gt; 的 include 参数 这样写： 12345678910&lt;keep-alive :include=&quot;cachedViews&quot;&gt; &lt;router-view :key=&quot;key&quot;/&gt;&lt;/keep-alive&gt;// cachedViews 利用vuex 状态存储管理computed:{ ...mapState({ cachedViews: state =&gt; state.tagsView.cachedViews })} 关于mapState 是vuex辅助函数之一，不熟悉的可以自行google 还有mapActions, mapMutations用法 而这个 cachedViews 数组需要利用vuex状态存储管理 12345678910111213141516171819202122232425262728// 新建 tagViews.js 文件export const tagViews = { state: { cachedViews: [] // 保存需要缓存的页面，也就是 &lt;keep-alive :include=\"cachedViews\"&gt; 这里使用的参数 }, mutations: { // 这里缓存的是 route.path 也是可以的，我使用的是route.name ADD_CACHED_VIEW (state, view) { if (state.cachedViews.includes(view.name)) return if (view.meta.keepAlive) { state.cachedViews.push(view.name) } }, DEL_CACHED_VIEW (state, view) { let index = state.cachedViews.indexOf(view.name) index &gt; -1 &amp;&amp; state.cachedViews.splice(index, 1) } }, actions: { addCachedView ({ commit }, view) { commit('ADD_CACHED_VIEW', view) }, delCachedView ({ commit }, view) { commit('DEL_CACHED_VIEW', view) } }} 这样就可以实现了，是不是还是很简单的，但是这里面有几个小坑，其实有时候入坑也是好的，会让你更深入的理解一个知识点 router表里面定义的 name 必须和组件页面 export 出来的 name 一致 1234567891011121314151617181920212223// routers.jsexport const routers = [ { path: &apos;list&apos;, name: &apos;list&apos;, component: List, meta: { keepAlive: true } }]// list.vue&lt;template&gt; list&lt;/template&gt;&lt;script&gt;export default { name: &apos;list&apos;, // 也就是此处的name 必须和router定义里的name一致 data () { return {} }}&lt;/script&gt; 使用了 keep-alive 之后 include 进行了缓存的页面，生命周期发生了变化： 没有进行缓存的页面，生命周期为：created mounted destroyed 进行了缓存的页面，生命周期变成：第一次进入， created mounted activated deactivated 第二次进行了缓存之后：activated deactivated 这时就不在经历 created mounted 周期 如果有必须每次进入必须加载的数据 可以利用 activated 这个生命周期做","link":"/2019/06/30/vue-keepAlive/"},{"title":"网页性能优化","text":"网页性能优化 ####1. 图片优化 1.1 样式代替图片例如：半透明、圆角、阴影、高光、渐变等。这些效果主流的浏览器都能够完美支持，而对于那些低端浏览器，我们并不会完全抛弃他们，“渐进增强”则是一个很好的解决方案。1.2 精灵图CSS Sprites，将同类型的图标或按钮等背景图合到一张大图中，减少页面请求。1.3 字体图标Icon Font，将图标做成字体文件。优点是图标支持多个尺寸，兼容所有浏览器，减少页面请求等。美中不足的是只支持纯色的icon。SVG，对于绝大多数图案、图标等，矢量图更小，且可缩放而无需生成多套图。现在主流浏览器都支持SVG了，所以可放心使用1.4 base64将图片转化为base64编码格式，资源内嵌于CSS或HTML中，不必单独请求。1.5图片响应式通常图片加载都是可以通过lazy加载的形式来的，那么可以在加载的时候来判断屏幕的尺寸来达到加载大图还是小图的目的来达到优化。 ####2. 资源优化2.1 CSS顶部, JS底部2.2 CSS JS文件压缩2.3 尽量使用图片使用精灵图，字体图标2.4 图片加载可通过懒加载的方式。总之就是减少资源体积减少资源请求次数。 3. 代码性能3.1 css代码性能优化1&gt;使用CSS缩写，减少代码量；2&gt;减少查询层级：如.header .logo要好过.header .top .logo；3&gt;减少查询范围：如.header&gt;li要好过.header li；4&gt;避免TAG标签与CLASS或ID并存：如a.top、button#submit；5&gt;删除重复的CSS； 3.2 html代码性能优化 1&gt;正确的闭合标签1如避免使用&lt;div/&gt;，浏览器会多一个将它解析成&lt;div\\&gt;&lt;/div\\&gt;的过程； 2&gt;减少DOM节点：加速页面渲染；3&gt;最小化重绘和重排浏览器下载完成所有的html标记，js，css，图片后，它解析文件并创建两个内部结构，一个事dom树，一个是渲染树，浏览器根据DOM树排列，根据渲染树绘制；什么情况下发生重排：(1)添加或者删除可见的dom元素(2)元素位置可变(3)元素尺寸改变（边距，填充，边框宽高等）(4)内容改变(5)最初的页面渲染(6)浏览器窗口改变尺寸最好减少这些属性（布局信息）的查询次数，查询时将它赋值给局部变量，参与计算，当你需要对dom树中的多个元素进行修改时，最好根据以下方式来减少重排和重绘：(1)从文档中国摘下此元素(2)对其应用多重改变(3)将元素带回文档中 3.3 js性能优化1&gt;缓存变量的值，尽量少的使用全局变量2&gt;如果需要不断运行的代码，不该使用setTimeout，而是使用setInterval，因setTimeout每一次都会初始化一个定时器，而setInterval只会在开始时初始化一个定时器3&gt;避免使用with语句，由于js的解析器需要检查with块中的变量是否属于with包含的对象，将使with语句执行速度下降，导致js语句很难优化，为了兼顾速度与代码量，找个折中的方案：1234var form = document.forms[];form.name.value = &quot;lihang&quot;;form.address.value = &quot;beijing&quot;;form.age.value = &quot;23&quot;; 4&gt;尽量少的去使用闭包，使用后要记得销毁5&gt;访问速度与成员嵌套深度有关，嵌套约深，访问速度越慢例如：local.href的访问速度快于window.localtion.href6&gt;prop()的执行速度要快于attr()attr()函数主要依赖的是Element对象的getAttribute()和setAttribute()两个方法。prop()函数主要依赖的则是JS中原生的对象属性获取和设置方式。7&gt;尽量使用for循环遍历数组，少使用for in循环8&gt;建议将对象进行缓存处理，特别是DOM访问是比较消耗资源的1234567891011121314151617181920212223242526272829303132//c.length没有缓存，每次迭代都要计算一下数组的长度 function foo1() { var i, b, c=[1,2,3]; for (i=0;i&amp;lt;c.length;i++) { b = c[i]; if(b === &quot;2&quot;){ return b; } } } //性能更好，第一次将数组的长度缓存到变量l中，第二次及后续的循环无需计算数组长度 function foo2() { var i, b, c=[1,2,3],l; for (i=0,l=c.length;i&amp;lt;l;i++) { b = c[i]; if(b === &quot;2&quot;) return b; } } //document.getElementById(&apos;info&apos;)没有缓存，每次都要遍历DOM function foo1() { var e; document.getElementById(&apos;info&apos;).innerHTML=&quot;call 1&quot;; document.getElementById(&apos;info&apos;).innerHTML=&quot;call 2&quot;; } //性能更好，第二次无需访问DOM function foo2() { var e=document.getElementById(&apos;info&apos;); e.innerHTML=&quot;call 1&quot;; e.innerHTML=&quot;call 2&quot;; } 9&gt;尽量不要在函数内部进行过深的嵌套判断10&gt;避免循环引用，防止内存泄漏11&gt;建议避免在函数内返回一个未声明的变量，会污染外部变量","link":"/2016/04/26/web-optimiza/"},{"title":"Yarn vs npm 你需要知道的一切","text":"Yarn 和 npm 具体区别 大家可能都已经比较熟悉npm了，对于yarn可能还不是特别熟悉，我就是这样的，所以有了这篇文章，总结记录学习的过程。 1. What is yarn?Yarn发布于2016年10月，目前为止在Github上迅速拥有了36,691个Star。而npm只有17,165个Star，从star的数量上就让我更充满对yarn探索的欲望。 那么什么是yarn呢？yarn官网介绍： Yarn 对你的代码来说是一个包管理器， 你可以通过它使用全世界开发者的代码，或者分享自己的代码。 Yarn 做这些快捷、安全、可靠，所以你不用担心什么。 通过Yarn你可以使用其他开发者针对不同问题的解决方案，使自己的开发过程更简单。 使用过程中遇到问题，你可以将其上报或者贡献解决方案。一旦问题被修复，Yarn会更新保持同步。 代码通过包（package）（或者称为模块（module））的方式来共享。 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为package.json Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，正如官方文档中写的，Yarn 是为了弥补 npm 的一些缺陷而出现的： npm 安装包（packages）的速度不够快，拉取的 packages 可能版本不同 npm 允许在安装 packages 时执行代码，这就埋下了安全隐患 但是Yarn 没想要完全替代 npm，它只是一个新的 CLI 工具，拉取的 packages 依然来自 npm 仓库。仓库本身不会变，所以获取或者发布模块的时候和原来一样。 2. Yarn vs npmnpm 和 Yarn 都是通过 package.json 记录项目需要拉取的依赖模块，不过在使用时，往往 package.json 中模块的版本号不太会写得非常确切，通常是定个版本范围。比如：package: &quot;4.17.4&quot; 意思是安装指定版本4.17.4的package包package: &quot;^4.17.4&quot; 意思是安装在4.X.X中最高版本号的package包package: &quot;~4.17.4&quot; 意思是安装在4.17.X中最高版本号的package包 理论上，次版本号的变化并不会影响向后兼容性。因此安装最新版的依赖库应该是能正常工作的，而且能引入自4.17.4版本以后的重要错误和安全方面的修复。但是，另一方面，不同的开发人员即使使用了相同的package.json文件，在他们自己的机器上也可能会安装同一个库的不同种版本，这样就会存在潜在的难以调试的错误，在我们团队中就经常出现”我的电脑上没有问题”和”为什么只有我的电脑上出现这个问题”的情形。 每次执行npm install的时候，不是都从网络上搜索下载，npm是有本地缓存的，它保存了已经下载的每个版本的压缩包。本地缓存的内容可以通过npm cache ls命令进行查看。本地缓存的设计有助于减少安装时间，但是下载过程还是很慢，因为npm遍历了整个依赖树，然后再决定如何生成扁平的node_modules目录结构。npm必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作。 Yarn vs npm lock文件的不同 （yarn.lock文件保证在不同的设备上也能安装相同版本的 packages）而为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。 npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新 Yarn vs npm 在执行包的安装过程中的不同无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务，npm 是按照队列执行每个 package，也就是说必须要等到当前 package 成功安装之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能； Yarn安装过程分为三个步骤： 解决方案： Yarn通过向注册表发出请求并以递归方式查找每个依赖项来开始解析依赖项。 获取：接下来，Yarn查找全局缓存目录以查看是否已下载所需的包。如果没有，Yarn会获取包的tarball并将其放在全局缓存中，这样它就可以脱机工作，不需要多次下载依赖项。依赖关系也可以作为完整脱机安装的tarball放在源代码控制中。 链接：最后，Yarn通过将全局缓存中所需的所有文件复制到本地node_modules目录来将所有文件链接在一起。 通过彻底打破这些步骤并获得确定性结果，Yarn能够并行化操作，从而最大限度地提高资源利用率并使安装过程更快。在一些Facebook项目中，Yarn将安装过程减少了一个数量级，从几分钟到几秒钟。Yarn还使用互斥锁来确保多个正在运行的CLI实例不会相互冲突和相互污染。在整个过程中，Yarn对包装安装提出了严格的保证。您可以控制为哪些包执行哪些生命周期脚本。包校验和也存储在锁文件中，以确保每次都获得相同的包。 Yarn vs npm 更简洁的输出npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji （Windows 上 emoji 不可见）直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 3. 关于 Yarn 的总结yarn优势： Yarn缓存它下载的每个包，因此它永远不需要再次下载相同的包。它还并行执行几乎所有操作以最大限度地利用资源。这意味着更快的安装速度; 使用详细但简洁的锁文件格式和确定性算法进行安装操作，Yarn能够保证在一个系统上运行的任何安装在另一个系统上都能完全相同; Yarn在执行代码之前使用校验和来验证每个已安装软件包的完整性. yarn特征： 离线模式: 如果您之前已安装过软件包，则无需连接互联网即可重新安装。 确定性: 无论安装顺序如何，相同的依赖关系都将以相同的方式安装在任何计算机上 网络性能: yarn有效地对请求进行排队并避免请求瀑布以最大化网络利用率 网络恢复力: 单个失败的请求不会导致整个安装失败。 失败时会自动重试请求 平面模式 Yarn将不匹配的依赖项版本解析为单个版本，以避免创建重复项。 更多表情符号 4. npm 与 yarn 常用命令对比 Npm Yarn 功能描述 npm install (npm i) yarn install (yarn i) / yarn 根据package.json文件下载相应依赖，安装是默认的行为 npm i –save [package] yarn add [package] 添加一个依赖包 npm i [package] –save-dev yarn add [package] -dev 添加一个依赖包到 devDependencies npm uninstall [package] yarn remove [package] 删除一个依赖包 npm update –save yarn upgrade 更新依赖包 npm install –global [package] yarn global add [package] 安装依赖包到全局 npm install -g license-checker; license-checker yarn licenses [list generate-disclaimer] yarn license ls()列出所有安装包的授权信息","link":"/2019/06/29/yarn-and-npm/"}],"tags":[{"name":"JavaScript 标准内置对象 - Object","slug":"JavaScript-标准内置对象-Object","link":"/tags/JavaScript-标准内置对象-Object/"},{"name":"javascript学习","slug":"javascript学习","link":"/tags/javascript学习/"},{"name":"Babel学习笔记","slug":"Babel学习笔记","link":"/tags/Babel学习笔记/"},{"name":"浏览器兼容性","slug":"浏览器兼容性","link":"/tags/浏览器兼容性/"},{"name":"Charles","slug":"Charles","link":"/tags/Charles/"},{"name":"浏览器加载解析过程","slug":"浏览器加载解析过程","link":"/tags/浏览器加载解析过程/"},{"name":"有关跨域知识总结","slug":"有关跨域知识总结","link":"/tags/有关跨域知识总结/"},{"name":"Canvas学习","slug":"Canvas学习","link":"/tags/Canvas学习/"},{"name":"CSS相关及一些兼容性问题","slug":"CSS相关及一些兼容性问题","link":"/tags/CSS相关及一些兼容性问题/"},{"name":"你应该知道的css细节及技巧","slug":"你应该知道的css细节及技巧","link":"/tags/你应该知道的css细节及技巧/"},{"name":"问题总结","slug":"问题总结","link":"/tags/问题总结/"},{"name":"Echarts 图表tooltip的自动播放","slug":"Echarts-图表tooltip的自动播放","link":"/tags/Echarts-图表tooltip的自动播放/"},{"name":"D3.js学习","slug":"D3-js学习","link":"/tags/D3-js学习/"},{"name":"JavaScript 小知识","slug":"JavaScript-小知识","link":"/tags/JavaScript-小知识/"},{"name":"es6的扩展运算符","slug":"es6的扩展运算符","link":"/tags/es6的扩展运算符/"},{"name":"函数的四种调用模式","slug":"函数的四种调用模式","link":"/tags/函数的四种调用模式/"},{"name":"eslint使用笔记","slug":"eslint使用笔记","link":"/tags/eslint使用笔记/"},{"name":"git学习","slug":"git学习","link":"/tags/git学习/"},{"name":"Gulp学习","slug":"Gulp学习","link":"/tags/Gulp学习/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"混合App开发","slug":"混合App开发","link":"/tags/混合App开发/"},{"name":"HTTP 学习","slug":"HTTP-学习","link":"/tags/HTTP-学习/"},{"name":"iTerm2","slug":"iTerm2","link":"/tags/iTerm2/"},{"name":"instanceOf","slug":"instanceOf","link":"/tags/instanceOf/"},{"name":"自己面试题总结","slug":"自己面试题总结","link":"/tags/自己面试题总结/"},{"name":"Async/await的使用","slug":"Async-await的使用","link":"/tags/Async-await的使用/"},{"name":"js数组相关方法","slug":"js数组相关方法","link":"/tags/js数组相关方法/"},{"name":"js内存管理","slug":"js内存管理","link":"/tags/js内存管理/"},{"name":"JavaScript 进阶","slug":"JavaScript-进阶","link":"/tags/JavaScript-进阶/"},{"name":"javascript踩过的坑","slug":"javascript踩过的坑","link":"/tags/javascript踩过的坑/"},{"name":"关于JavaScript的一些总结","slug":"关于JavaScript的一些总结","link":"/tags/关于JavaScript的一些总结/"},{"name":"javascript 原型链","slug":"javascript-原型链","link":"/tags/javascript-原型链/"},{"name":"更好的使用js编程","slug":"更好的使用js编程","link":"/tags/更好的使用js编程/"},{"name":"let和const的区别","slug":"let和const的区别","link":"/tags/let和const的区别/"},{"name":"前端工具","slug":"前端工具","link":"/tags/前端工具/"},{"name":"模块化开发学习","slug":"模块化开发学习","link":"/tags/模块化开发学习/"},{"name":"NodeJS学习","slug":"NodeJS学习","link":"/tags/NodeJS学习/"},{"name":"终端命令","slug":"终端命令","link":"/tags/终端命令/"},{"name":"nginx使用笔记","slug":"nginx使用笔记","link":"/tags/nginx使用笔记/"},{"name":"react入门学习","slug":"react入门学习","link":"/tags/react入门学习/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"关于react问题整理","slug":"关于react问题整理","link":"/tags/关于react问题整理/"},{"name":"关于正则表达式","slug":"关于正则表达式","link":"/tags/关于正则表达式/"},{"name":"token相关","slug":"token相关","link":"/tags/token相关/"},{"name":"vue父子组件间数据传递","slug":"vue父子组件间数据传递","link":"/tags/vue父子组件间数据传递/"},{"name":"如何搭建vue项目","slug":"如何搭建vue项目","link":"/tags/如何搭建vue项目/"},{"name":"Vue入门学习","slug":"Vue入门学习","link":"/tags/Vue入门学习/"},{"name":"uni-app","slug":"uni-app","link":"/tags/uni-app/"},{"name":"Vue 页面缓存","slug":"Vue-页面缓存","link":"/tags/Vue-页面缓存/"},{"name":"网页性能优化","slug":"网页性能优化","link":"/tags/网页性能优化/"},{"name":"yarn","slug":"yarn","link":"/tags/yarn/"}],"categories":[{"name":"JavaScript 进阶","slug":"JavaScript-进阶","link":"/categories/JavaScript-进阶/"},{"name":"语法相关","slug":"语法相关","link":"/categories/语法相关/"},{"name":"Babel","slug":"Babel","link":"/categories/Babel/"},{"name":"浏览器工作相关","slug":"浏览器工作相关","link":"/categories/浏览器工作相关/"},{"name":"前端工具","slug":"前端工具","link":"/categories/前端工具/"},{"name":"跨域","slug":"跨域","link":"/categories/跨域/"},{"name":"前端绘图","slug":"前端绘图","link":"/categories/前端绘图/"},{"name":"Babel 进阶","slug":"Babel-进阶","link":"/categories/Babel-进阶/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"CSS相关","slug":"CSS相关","link":"/categories/CSS相关/"},{"name":"总结","slug":"总结","link":"/categories/总结/"},{"name":"Echarts","slug":"Echarts","link":"/categories/Echarts/"},{"name":"JavaScript 小知识","slug":"JavaScript-小知识","link":"/categories/JavaScript-小知识/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Git相关","slug":"Git相关","link":"/categories/Git相关/"},{"name":"构建工具","slug":"构建工具","link":"/categories/构建工具/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"混合App开发","slug":"混合App开发","link":"/categories/混合App开发/"},{"name":"HTTP 相关","slug":"HTTP-相关","link":"/categories/HTTP-相关/"},{"name":"前端辅助工具","slug":"前端辅助工具","link":"/categories/前端辅助工具/"},{"name":"前端面试总结","slug":"前端面试总结","link":"/categories/前端面试总结/"},{"name":"NodeJS","slug":"NodeJS","link":"/categories/NodeJS/"},{"name":"终端命令","slug":"终端命令","link":"/categories/终端命令/"},{"name":"nginx","slug":"nginx","link":"/categories/nginx/"},{"name":"react","slug":"react","link":"/categories/react/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"uni-app","slug":"uni-app","link":"/categories/uni-app/"},{"name":"网页性能优化","slug":"网页性能优化","link":"/categories/网页性能优化/"}]}